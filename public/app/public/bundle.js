
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
  'use strict';

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var materialize = createCommonjsModule(function (module, exports) {
  /*!
   * Materialize v1.0.0-rc.2 (http://materializecss.com)
   * Copyright 2014-2017 Materialize
   * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
   */
  var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  /*! cash-dom 1.3.5, https://github.com/kenwheeler/cash @license MIT */
  (function (factory) {
    window.cash = factory();
  })(function () {
    var doc = document,
        win = window,
        ArrayProto = Array.prototype,
        slice = ArrayProto.slice,
        filter = ArrayProto.filter,
        push = ArrayProto.push;

    var noop = function () {},
        isFunction = function (item) {
      // @see https://crbug.com/568448
      return typeof item === typeof noop && item.call;
    },
        isString = function (item) {
      return typeof item === typeof "";
    };

    var idMatch = /^#[\w-]*$/,
        classMatch = /^\.[\w-]*$/,
        htmlMatch = /<.+>/,
        singlet = /^\w+$/;

    function find(selector, context) {
      context = context || doc;
      var elems = classMatch.test(selector) ? context.getElementsByClassName(selector.slice(1)) : singlet.test(selector) ? context.getElementsByTagName(selector) : context.querySelectorAll(selector);
      return elems;
    }

    var frag;
    function parseHTML(str) {
      if (!frag) {
        frag = doc.implementation.createHTMLDocument(null);
        var base = frag.createElement("base");
        base.href = doc.location.href;
        frag.head.appendChild(base);
      }

      frag.body.innerHTML = str;

      return frag.body.childNodes;
    }

    function onReady(fn) {
      if (doc.readyState !== "loading") {
        fn();
      } else {
        doc.addEventListener("DOMContentLoaded", fn);
      }
    }

    function Init(selector, context) {
      if (!selector) {
        return this;
      }

      // If already a cash collection, don't do any further processing
      if (selector.cash && selector !== win) {
        return selector;
      }

      var elems = selector,
          i = 0,
          length;

      if (isString(selector)) {
        elems = idMatch.test(selector) ?
        // If an ID use the faster getElementById check
        doc.getElementById(selector.slice(1)) : htmlMatch.test(selector) ?
        // If HTML, parse it into real elements
        parseHTML(selector) :
        // else use `find`
        find(selector, context);

        // If function, use as shortcut for DOM ready
      } else if (isFunction(selector)) {
        onReady(selector);return this;
      }

      if (!elems) {
        return this;
      }

      // If a single DOM element is passed in or received via ID, return the single element
      if (elems.nodeType || elems === win) {
        this[0] = elems;
        this.length = 1;
      } else {
        // Treat like an array and loop through each item.
        length = this.length = elems.length;
        for (; i < length; i++) {
          this[i] = elems[i];
        }
      }

      return this;
    }

    function cash(selector, context) {
      return new Init(selector, context);
    }

    var fn = cash.fn = cash.prototype = Init.prototype = { // jshint ignore:line
      cash: true,
      length: 0,
      push: push,
      splice: ArrayProto.splice,
      map: ArrayProto.map,
      init: Init
    };

    Object.defineProperty(fn, "constructor", { value: cash });

    cash.parseHTML = parseHTML;
    cash.noop = noop;
    cash.isFunction = isFunction;
    cash.isString = isString;

    cash.extend = fn.extend = function (target) {
      target = target || {};

      var args = slice.call(arguments),
          length = args.length,
          i = 1;

      if (args.length === 1) {
        target = this;
        i = 0;
      }

      for (; i < length; i++) {
        if (!args[i]) {
          continue;
        }
        for (var key in args[i]) {
          if (args[i].hasOwnProperty(key)) {
            target[key] = args[i][key];
          }
        }
      }

      return target;
    };

    function each(collection, callback) {
      var l = collection.length,
          i = 0;

      for (; i < l; i++) {
        if (callback.call(collection[i], collection[i], i, collection) === false) {
          break;
        }
      }
    }

    function matches(el, selector) {
      var m = el && (el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector || el.oMatchesSelector);
      return !!m && m.call(el, selector);
    }

    function getCompareFunction(selector) {
      return (
        /* Use browser's `matches` function if string */
        isString(selector) ? matches :
        /* Match a cash element */
        selector.cash ? function (el) {
          return selector.is(el);
        } :
        /* Direct comparison */
        function (el, selector) {
          return el === selector;
        }
      );
    }

    function unique(collection) {
      return cash(slice.call(collection).filter(function (item, index, self) {
        return self.indexOf(item) === index;
      }));
    }

    cash.extend({
      merge: function (first, second) {
        var len = +second.length,
            i = first.length,
            j = 0;

        for (; j < len; i++, j++) {
          first[i] = second[j];
        }

        first.length = i;
        return first;
      },

      each: each,
      matches: matches,
      unique: unique,
      isArray: Array.isArray,
      isNumeric: function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }

    });

    var uid = cash.uid = "_cash" + Date.now();

    function getDataCache(node) {
      return node[uid] = node[uid] || {};
    }

    function setData(node, key, value) {
      return getDataCache(node)[key] = value;
    }

    function getData(node, key) {
      var c = getDataCache(node);
      if (c[key] === undefined) {
        c[key] = node.dataset ? node.dataset[key] : cash(node).attr("data-" + key);
      }
      return c[key];
    }

    function removeData(node, key) {
      var c = getDataCache(node);
      if (c) {
        delete c[key];
      } else if (node.dataset) {
        delete node.dataset[key];
      } else {
        cash(node).removeAttr("data-" + name);
      }
    }

    fn.extend({
      data: function (name, value) {
        if (isString(name)) {
          return value === undefined ? getData(this[0], name) : this.each(function (v) {
            return setData(v, name, value);
          });
        }

        for (var key in name) {
          this.data(key, name[key]);
        }

        return this;
      },

      removeData: function (key) {
        return this.each(function (v) {
          return removeData(v, key);
        });
      }

    });

    var notWhiteMatch = /\S+/g;

    function getClasses(c) {
      return isString(c) && c.match(notWhiteMatch);
    }

    function hasClass(v, c) {
      return v.classList ? v.classList.contains(c) : new RegExp("(^| )" + c + "( |$)", "gi").test(v.className);
    }

    function addClass(v, c, spacedName) {
      if (v.classList) {
        v.classList.add(c);
      } else if (spacedName.indexOf(" " + c + " ")) {
        v.className += " " + c;
      }
    }

    function removeClass(v, c) {
      if (v.classList) {
        v.classList.remove(c);
      } else {
        v.className = v.className.replace(c, "");
      }
    }

    fn.extend({
      addClass: function (c) {
        var classes = getClasses(c);

        return classes ? this.each(function (v) {
          var spacedName = " " + v.className + " ";
          each(classes, function (c) {
            addClass(v, c, spacedName);
          });
        }) : this;
      },

      attr: function (name, value) {
        if (!name) {
          return undefined;
        }

        if (isString(name)) {
          if (value === undefined) {
            return this[0] ? this[0].getAttribute ? this[0].getAttribute(name) : this[0][name] : undefined;
          }

          return this.each(function (v) {
            if (v.setAttribute) {
              v.setAttribute(name, value);
            } else {
              v[name] = value;
            }
          });
        }

        for (var key in name) {
          this.attr(key, name[key]);
        }

        return this;
      },

      hasClass: function (c) {
        var check = false,
            classes = getClasses(c);
        if (classes && classes.length) {
          this.each(function (v) {
            check = hasClass(v, classes[0]);
            return !check;
          });
        }
        return check;
      },

      prop: function (name, value) {
        if (isString(name)) {
          return value === undefined ? this[0][name] : this.each(function (v) {
            v[name] = value;
          });
        }

        for (var key in name) {
          this.prop(key, name[key]);
        }

        return this;
      },

      removeAttr: function (name) {
        return this.each(function (v) {
          if (v.removeAttribute) {
            v.removeAttribute(name);
          } else {
            delete v[name];
          }
        });
      },

      removeClass: function (c) {
        if (!arguments.length) {
          return this.attr("class", "");
        }
        var classes = getClasses(c);
        return classes ? this.each(function (v) {
          each(classes, function (c) {
            removeClass(v, c);
          });
        }) : this;
      },

      removeProp: function (name) {
        return this.each(function (v) {
          delete v[name];
        });
      },

      toggleClass: function (c, state) {
        if (state !== undefined) {
          return this[state ? "addClass" : "removeClass"](c);
        }
        var classes = getClasses(c);
        return classes ? this.each(function (v) {
          var spacedName = " " + v.className + " ";
          each(classes, function (c) {
            if (hasClass(v, c)) {
              removeClass(v, c);
            } else {
              addClass(v, c, spacedName);
            }
          });
        }) : this;
      } });

    fn.extend({
      add: function (selector, context) {
        return unique(cash.merge(this, cash(selector, context)));
      },

      each: function (callback) {
        each(this, callback);
        return this;
      },

      eq: function (index) {
        return cash(this.get(index));
      },

      filter: function (selector) {
        if (!selector) {
          return this;
        }

        var comparator = isFunction(selector) ? selector : getCompareFunction(selector);

        return cash(filter.call(this, function (e) {
          return comparator(e, selector);
        }));
      },

      first: function () {
        return this.eq(0);
      },

      get: function (index) {
        if (index === undefined) {
          return slice.call(this);
        }
        return index < 0 ? this[index + this.length] : this[index];
      },

      index: function (elem) {
        var child = elem ? cash(elem)[0] : this[0],
            collection = elem ? this : cash(child).parent().children();
        return slice.call(collection).indexOf(child);
      },

      last: function () {
        return this.eq(-1);
      }

    });

    var camelCase = function () {
      var camelRegex = /(?:^\w|[A-Z]|\b\w)/g,
          whiteSpace = /[\s-_]+/g;
      return function (str) {
        return str.replace(camelRegex, function (letter, index) {
          return letter[index === 0 ? "toLowerCase" : "toUpperCase"]();
        }).replace(whiteSpace, "");
      };
    }();

    var getPrefixedProp = function () {
      var cache = {},
          doc = document,
          div = doc.createElement("div"),
          style = div.style;

      return function (prop) {
        prop = camelCase(prop);
        if (cache[prop]) {
          return cache[prop];
        }

        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
            prefixes = ["webkit", "moz", "ms", "o"],
            props = (prop + " " + prefixes.join(ucProp + " ") + ucProp).split(" ");

        each(props, function (p) {
          if (p in style) {
            cache[p] = prop = cache[prop] = p;
            return false;
          }
        });

        return cache[prop];
      };
    }();

    cash.prefixedProp = getPrefixedProp;
    cash.camelCase = camelCase;

    fn.extend({
      css: function (prop, value) {
        if (isString(prop)) {
          prop = getPrefixedProp(prop);
          return arguments.length > 1 ? this.each(function (v) {
            return v.style[prop] = value;
          }) : win.getComputedStyle(this[0])[prop];
        }

        for (var key in prop) {
          this.css(key, prop[key]);
        }

        return this;
      }

    });

    function compute(el, prop) {
      return parseInt(win.getComputedStyle(el[0], null)[prop], 10) || 0;
    }

    each(["Width", "Height"], function (v) {
      var lower = v.toLowerCase();

      fn[lower] = function () {
        return this[0].getBoundingClientRect()[lower];
      };

      fn["inner" + v] = function () {
        return this[0]["client" + v];
      };

      fn["outer" + v] = function (margins) {
        return this[0]["offset" + v] + (margins ? compute(this, "margin" + (v === "Width" ? "Left" : "Top")) + compute(this, "margin" + (v === "Width" ? "Right" : "Bottom")) : 0);
      };
    });

    function registerEvent(node, eventName, callback) {
      var eventCache = getData(node, "_cashEvents") || setData(node, "_cashEvents", {});
      eventCache[eventName] = eventCache[eventName] || [];
      eventCache[eventName].push(callback);
      node.addEventListener(eventName, callback);
    }

    function removeEvent(node, eventName, callback) {
      var events = getData(node, "_cashEvents"),
          eventCache = events && events[eventName],
          index;

      if (!eventCache) {
        return;
      }

      if (callback) {
        node.removeEventListener(eventName, callback);
        index = eventCache.indexOf(callback);
        if (index >= 0) {
          eventCache.splice(index, 1);
        }
      } else {
        each(eventCache, function (event) {
          node.removeEventListener(eventName, event);
        });
        eventCache = [];
      }
    }

    fn.extend({
      off: function (eventName, callback) {
        return this.each(function (v) {
          return removeEvent(v, eventName, callback);
        });
      },

      on: function (eventName, delegate, callback, runOnce) {
        // jshint ignore:line
        var originalCallback;
        if (!isString(eventName)) {
          for (var key in eventName) {
            this.on(key, delegate, eventName[key]);
          }
          return this;
        }

        if (isFunction(delegate)) {
          callback = delegate;
          delegate = null;
        }

        if (eventName === "ready") {
          onReady(callback);
          return this;
        }

        if (delegate) {
          originalCallback = callback;
          callback = function (e) {
            var t = e.target;
            while (!matches(t, delegate)) {
              if (t === this || t === null) {
                return t = false;
              }

              t = t.parentNode;
            }

            if (t) {
              originalCallback.call(t, e);
            }
          };
        }

        return this.each(function (v) {
          var finalCallback = callback;
          if (runOnce) {
            finalCallback = function () {
              callback.apply(this, arguments);
              removeEvent(v, eventName, finalCallback);
            };
          }
          registerEvent(v, eventName, finalCallback);
        });
      },

      one: function (eventName, delegate, callback) {
        return this.on(eventName, delegate, callback, true);
      },

      ready: onReady,

      /**
       * Modified
       * Triggers browser event
       * @param String eventName
       * @param Object data - Add properties to event object
       */
      trigger: function (eventName, data) {
        if (document.createEvent) {
          var evt = document.createEvent('HTMLEvents');
          evt.initEvent(eventName, true, false);
          evt = this.extend(evt, data);
          return this.each(function (v) {
            return v.dispatchEvent(evt);
          });
        }
      }

    });

    function encode(name, value) {
      return "&" + encodeURIComponent(name) + "=" + encodeURIComponent(value).replace(/%20/g, "+");
    }

    function getSelectMultiple_(el) {
      var values = [];
      each(el.options, function (o) {
        if (o.selected) {
          values.push(o.value);
        }
      });
      return values.length ? values : null;
    }

    function getSelectSingle_(el) {
      var selectedIndex = el.selectedIndex;
      return selectedIndex >= 0 ? el.options[selectedIndex].value : null;
    }

    function getValue(el) {
      var type = el.type;
      if (!type) {
        return null;
      }
      switch (type.toLowerCase()) {
        case "select-one":
          return getSelectSingle_(el);
        case "select-multiple":
          return getSelectMultiple_(el);
        case "radio":
          return el.checked ? el.value : null;
        case "checkbox":
          return el.checked ? el.value : null;
        default:
          return el.value ? el.value : null;
      }
    }

    fn.extend({
      serialize: function () {
        var query = "";

        each(this[0].elements || this, function (el) {
          if (el.disabled || el.tagName === "FIELDSET") {
            return;
          }
          var name = el.name;
          switch (el.type.toLowerCase()) {
            case "file":
            case "reset":
            case "submit":
            case "button":
              break;
            case "select-multiple":
              var values = getValue(el);
              if (values !== null) {
                each(values, function (value) {
                  query += encode(name, value);
                });
              }
              break;
            default:
              var value = getValue(el);
              if (value !== null) {
                query += encode(name, value);
              }
          }
        });

        return query.substr(1);
      },

      val: function (value) {
        if (value === undefined) {
          return getValue(this[0]);
        }

        return this.each(function (v) {
          return v.value = value;
        });
      }

    });

    function insertElement(el, child, prepend) {
      if (prepend) {
        var first = el.childNodes[0];
        el.insertBefore(child, first);
      } else {
        el.appendChild(child);
      }
    }

    function insertContent(parent, child, prepend) {
      var str = isString(child);

      if (!str && child.length) {
        each(child, function (v) {
          return insertContent(parent, v, prepend);
        });
        return;
      }

      each(parent, str ? function (v) {
        return v.insertAdjacentHTML(prepend ? "afterbegin" : "beforeend", child);
      } : function (v, i) {
        return insertElement(v, i === 0 ? child : child.cloneNode(true), prepend);
      });
    }

    fn.extend({
      after: function (selector) {
        cash(selector).insertAfter(this);
        return this;
      },

      append: function (content) {
        insertContent(this, content);
        return this;
      },

      appendTo: function (parent) {
        insertContent(cash(parent), this);
        return this;
      },

      before: function (selector) {
        cash(selector).insertBefore(this);
        return this;
      },

      clone: function () {
        return cash(this.map(function (v) {
          return v.cloneNode(true);
        }));
      },

      empty: function () {
        this.html("");
        return this;
      },

      html: function (content) {
        if (content === undefined) {
          return this[0].innerHTML;
        }
        var source = content.nodeType ? content[0].outerHTML : content;
        return this.each(function (v) {
          return v.innerHTML = source;
        });
      },

      insertAfter: function (selector) {
        var _this = this;

        cash(selector).each(function (el, i) {
          var parent = el.parentNode,
              sibling = el.nextSibling;
          _this.each(function (v) {
            parent.insertBefore(i === 0 ? v : v.cloneNode(true), sibling);
          });
        });

        return this;
      },

      insertBefore: function (selector) {
        var _this2 = this;
        cash(selector).each(function (el, i) {
          var parent = el.parentNode;
          _this2.each(function (v) {
            parent.insertBefore(i === 0 ? v : v.cloneNode(true), el);
          });
        });
        return this;
      },

      prepend: function (content) {
        insertContent(this, content, true);
        return this;
      },

      prependTo: function (parent) {
        insertContent(cash(parent), this, true);
        return this;
      },

      remove: function () {
        return this.each(function (v) {
          if (!!v.parentNode) {
            return v.parentNode.removeChild(v);
          }
        });
      },

      text: function (content) {
        if (content === undefined) {
          return this[0].textContent;
        }
        return this.each(function (v) {
          return v.textContent = content;
        });
      }

    });

    var docEl = doc.documentElement;

    fn.extend({
      position: function () {
        var el = this[0];
        return {
          left: el.offsetLeft,
          top: el.offsetTop
        };
      },

      offset: function () {
        var rect = this[0].getBoundingClientRect();
        return {
          top: rect.top + win.pageYOffset - docEl.clientTop,
          left: rect.left + win.pageXOffset - docEl.clientLeft
        };
      },

      offsetParent: function () {
        return cash(this[0].offsetParent);
      }

    });

    fn.extend({
      children: function (selector) {
        var elems = [];
        this.each(function (el) {
          push.apply(elems, el.children);
        });
        elems = unique(elems);

        return !selector ? elems : elems.filter(function (v) {
          return matches(v, selector);
        });
      },

      closest: function (selector) {
        if (!selector || this.length < 1) {
          return cash();
        }
        if (this.is(selector)) {
          return this.filter(selector);
        }
        return this.parent().closest(selector);
      },

      is: function (selector) {
        if (!selector) {
          return false;
        }

        var match = false,
            comparator = getCompareFunction(selector);

        this.each(function (el) {
          match = comparator(el, selector);
          return !match;
        });

        return match;
      },

      find: function (selector) {
        if (!selector || selector.nodeType) {
          return cash(selector && this.has(selector).length ? selector : null);
        }

        var elems = [];
        this.each(function (el) {
          push.apply(elems, find(selector, el));
        });

        return unique(elems);
      },

      has: function (selector) {
        var comparator = isString(selector) ? function (el) {
          return find(selector, el).length !== 0;
        } : function (el) {
          return el.contains(selector);
        };

        return this.filter(comparator);
      },

      next: function () {
        return cash(this[0].nextElementSibling);
      },

      not: function (selector) {
        if (!selector) {
          return this;
        }

        var comparator = getCompareFunction(selector);

        return this.filter(function (el) {
          return !comparator(el, selector);
        });
      },

      parent: function () {
        var result = [];

        this.each(function (item) {
          if (item && item.parentNode) {
            result.push(item.parentNode);
          }
        });

        return unique(result);
      },

      parents: function (selector) {
        var last,
            result = [];

        this.each(function (item) {
          last = item;

          while (last && last.parentNode && last !== doc.body.parentNode) {
            last = last.parentNode;

            if (!selector || selector && matches(last, selector)) {
              result.push(last);
            }
          }
        });

        return unique(result);
      },

      prev: function () {
        return cash(this[0].previousElementSibling);
      },

      siblings: function (selector) {
        var collection = this.parent().children(selector),
            el = this[0];

        return collection.filter(function (i) {
          return i !== el;
        });
      }

    });

    return cash;
  });
  var Component = function () {
    /**
     * Generic constructor for all components
     * @constructor
     * @param {Element} el
     * @param {Object} options
     */
    function Component(classDef, el, options) {
      _classCallCheck(this, Component);

      // Display error if el is valid HTML Element
      if (!(el instanceof Element)) {
        console.error(Error(el + ' is not an HTML Element'));
      }

      // If exists, destroy and reinitialize in child
      var ins = classDef.getInstance(el);
      if (!!ins) {
        ins.destroy();
      }

      this.el = el;
      this.$el = cash(el);
    }

    /**
     * Initializes components
     * @param {class} classDef
     * @param {Element | NodeList | jQuery} els
     * @param {Object} options
     */


    _createClass(Component, null, [{
      key: "init",
      value: function init(classDef, els, options) {
        var instances = null;
        if (els instanceof Element) {
          instances = new classDef(els, options);
        } else if (!!els && (els.jquery || els.cash || els instanceof NodeList)) {
          var instancesArr = [];
          for (var i = 0; i < els.length; i++) {
            instancesArr.push(new classDef(els[i], options));
          }
          instances = instancesArr;
        }

        return instances;
      }
    }]);

    return Component;
  }();
  (function (window) {
    if (window.Package) {
      M = {};
    } else {
      window.M = {};
    }

    // Check for jQuery
    M.jQueryLoaded = !!window.jQuery;
  })(window);

  // AMD
  if ( !exports.nodeType) {
    if ( !module.nodeType && module.exports) {
      exports = module.exports = M;
    }
    exports.default = M;
  }

  M.keys = {
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    ARROW_UP: 38,
    ARROW_DOWN: 40
  };

  /**
   * TabPress Keydown handler
   */
  M.tabPressed = false;
  M.keyDown = false;
  var docHandleKeydown = function (e) {
    M.keyDown = true;
    if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {
      M.tabPressed = true;
    }
  };
  var docHandleKeyup = function (e) {
    M.keyDown = false;
    if (e.which === M.keys.TAB || e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) {
      M.tabPressed = false;
    }
  };
  var docHandleFocus = function (e) {
    if (M.keyDown) {
      document.body.classList.add('keyboard-focused');
    }
  };
  var docHandleBlur = function (e) {
    document.body.classList.remove('keyboard-focused');
  };
  document.addEventListener('keydown', docHandleKeydown, true);
  document.addEventListener('keyup', docHandleKeyup, true);
  document.addEventListener('focus', docHandleFocus, true);
  document.addEventListener('blur', docHandleBlur, true);

  /**
   * Initialize jQuery wrapper for plugin
   * @param {Class} plugin  javascript class
   * @param {string} pluginName  jQuery plugin name
   * @param {string} classRef  Class reference name
   */
  M.initializeJqueryWrapper = function (plugin, pluginName, classRef) {
    jQuery.fn[pluginName] = function (methodOrOptions) {
      // Call plugin method if valid method name is passed in
      if (plugin.prototype[methodOrOptions]) {
        var params = Array.prototype.slice.call(arguments, 1);

        // Getter methods
        if (methodOrOptions.slice(0, 3) === 'get') {
          var instance = this.first()[0][classRef];
          return instance[methodOrOptions].apply(instance, params);
        }

        // Void methods
        return this.each(function () {
          var instance = this[classRef];
          instance[methodOrOptions].apply(instance, params);
        });

        // Initialize plugin if options or no argument is passed in
      } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {
        plugin.init(this, arguments[0]);
        return this;
      }

      // Return error if an unrecognized  method name is passed in
      jQuery.error("Method " + methodOrOptions + " does not exist on jQuery." + pluginName);
    };
  };

  /**
   * Automatically initialize components
   * @param {Element} context  DOM Element to search within for components
   */
  M.AutoInit = function (context) {
    // Use document.body if no context is given
    var root = !!context ? context : document.body;

    var registry = {
      Autocomplete: root.querySelectorAll('.autocomplete:not(.no-autoinit)'),
      Carousel: root.querySelectorAll('.carousel:not(.no-autoinit)'),
      Chips: root.querySelectorAll('.chips:not(.no-autoinit)'),
      Collapsible: root.querySelectorAll('.collapsible:not(.no-autoinit)'),
      Datepicker: root.querySelectorAll('.datepicker:not(.no-autoinit)'),
      Dropdown: root.querySelectorAll('.dropdown-trigger:not(.no-autoinit)'),
      Materialbox: root.querySelectorAll('.materialboxed:not(.no-autoinit)'),
      Modal: root.querySelectorAll('.modal:not(.no-autoinit)'),
      Parallax: root.querySelectorAll('.parallax:not(.no-autoinit)'),
      Pushpin: root.querySelectorAll('.pushpin:not(.no-autoinit)'),
      ScrollSpy: root.querySelectorAll('.scrollspy:not(.no-autoinit)'),
      FormSelect: root.querySelectorAll('select:not(.no-autoinit)'),
      Sidenav: root.querySelectorAll('.sidenav:not(.no-autoinit)'),
      Tabs: root.querySelectorAll('.tabs:not(.no-autoinit)'),
      TapTarget: root.querySelectorAll('.tap-target:not(.no-autoinit)'),
      Timepicker: root.querySelectorAll('.timepicker:not(.no-autoinit)'),
      Tooltip: root.querySelectorAll('.tooltipped:not(.no-autoinit)'),
      FloatingActionButton: root.querySelectorAll('.fixed-action-btn:not(.no-autoinit)')
    };

    for (var pluginName in registry) {
      var plugin = M[pluginName];
      plugin.init(registry[pluginName]);
    }
  };

  /**
   * Generate approximated selector string for a jQuery object
   * @param {jQuery} obj  jQuery object to be parsed
   * @returns {string}
   */
  M.objectSelectorString = function (obj) {
    var tagStr = obj.prop('tagName') || '';
    var idStr = obj.attr('id') || '';
    var classStr = obj.attr('class') || '';
    return (tagStr + idStr + classStr).replace(/\s/g, '');
  };

  // Unique Random ID
  M.guid = function () {
    function s4() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return function () {
      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    };
  }();

  /**
   * Escapes hash from special characters
   * @param {string} hash  String returned from this.hash
   * @returns {string}
   */
  M.escapeHash = function (hash) {
    return hash.replace(/(:|\.|\[|\]|,|=|\/)/g, '\\$1');
  };

  M.elementOrParentIsFixed = function (element) {
    var $element = $(element);
    var $checkElements = $element.add($element.parents());
    var isFixed = false;
    $checkElements.each(function () {
      if ($(this).css('position') === 'fixed') {
        isFixed = true;
        return false;
      }
    });
    return isFixed;
  };

  /**
   * @typedef {Object} Edges
   * @property {Boolean} top  If the top edge was exceeded
   * @property {Boolean} right  If the right edge was exceeded
   * @property {Boolean} bottom  If the bottom edge was exceeded
   * @property {Boolean} left  If the left edge was exceeded
   */

  /**
   * @typedef {Object} Bounding
   * @property {Number} left  left offset coordinate
   * @property {Number} top  top offset coordinate
   * @property {Number} width
   * @property {Number} height
   */

  /**
   * Escapes hash from special characters
   * @param {Element} container  Container element that acts as the boundary
   * @param {Bounding} bounding  element bounding that is being checked
   * @param {Number} offset  offset from edge that counts as exceeding
   * @returns {Edges}
   */
  M.checkWithinContainer = function (container, bounding, offset) {
    var edges = {
      top: false,
      right: false,
      bottom: false,
      left: false
    };

    var containerRect = container.getBoundingClientRect();
    // If body element is smaller than viewport, use viewport height instead.
    var containerBottom = container === document.body ? Math.max(containerRect.bottom, window.innerHeight) : containerRect.bottom;

    var scrollLeft = container.scrollLeft;
    var scrollTop = container.scrollTop;

    var scrolledX = bounding.left - scrollLeft;
    var scrolledY = bounding.top - scrollTop;

    // Check for container and viewport for each edge
    if (scrolledX < containerRect.left + offset || scrolledX < offset) {
      edges.left = true;
    }

    if (scrolledX + bounding.width > containerRect.right - offset || scrolledX + bounding.width > window.innerWidth - offset) {
      edges.right = true;
    }

    if (scrolledY < containerRect.top + offset || scrolledY < offset) {
      edges.top = true;
    }

    if (scrolledY + bounding.height > containerBottom - offset || scrolledY + bounding.height > window.innerHeight - offset) {
      edges.bottom = true;
    }

    return edges;
  };

  M.checkPossibleAlignments = function (el, container, bounding, offset) {
    var canAlign = {
      top: true,
      right: true,
      bottom: true,
      left: true,
      spaceOnTop: null,
      spaceOnRight: null,
      spaceOnBottom: null,
      spaceOnLeft: null
    };

    var containerAllowsOverflow = getComputedStyle(container).overflow === 'visible';
    var containerRect = container.getBoundingClientRect();
    var containerHeight = Math.min(containerRect.height, window.innerHeight);
    var containerWidth = Math.min(containerRect.width, window.innerWidth);
    var elOffsetRect = el.getBoundingClientRect();

    var scrollLeft = container.scrollLeft;
    var scrollTop = container.scrollTop;

    var scrolledX = bounding.left - scrollLeft;
    var scrolledYTopEdge = bounding.top - scrollTop;
    var scrolledYBottomEdge = bounding.top + elOffsetRect.height - scrollTop;

    // Check for container and viewport for left
    canAlign.spaceOnRight = !containerAllowsOverflow ? containerWidth - (scrolledX + bounding.width) : window.innerWidth - (elOffsetRect.left + bounding.width);
    if (canAlign.spaceOnRight < 0) {
      canAlign.left = false;
    }

    // Check for container and viewport for Right
    canAlign.spaceOnLeft = !containerAllowsOverflow ? scrolledX - bounding.width + elOffsetRect.width : elOffsetRect.right - bounding.width;
    if (canAlign.spaceOnLeft < 0) {
      canAlign.right = false;
    }

    // Check for container and viewport for Top
    canAlign.spaceOnBottom = !containerAllowsOverflow ? containerHeight - (scrolledYTopEdge + bounding.height + offset) : window.innerHeight - (elOffsetRect.top + bounding.height + offset);
    if (canAlign.spaceOnBottom < 0) {
      canAlign.top = false;
    }

    // Check for container and viewport for Bottom
    canAlign.spaceOnTop = !containerAllowsOverflow ? scrolledYBottomEdge - (bounding.height - offset) : elOffsetRect.bottom - (bounding.height + offset);
    if (canAlign.spaceOnTop < 0) {
      canAlign.bottom = false;
    }

    return canAlign;
  };

  M.getOverflowParent = function (element) {
    if (element == null) {
      return null;
    }

    if (element === document.body || getComputedStyle(element).overflow !== 'visible') {
      return element;
    }

    return M.getOverflowParent(element.parentElement);
  };

  /**
   * Gets id of component from a trigger
   * @param {Element} trigger  trigger
   * @returns {string}
   */
  M.getIdFromTrigger = function (trigger) {
    var id = trigger.getAttribute('data-target');
    if (!id) {
      id = trigger.getAttribute('href');
      if (id) {
        id = id.slice(1);
      } else {
        id = '';
      }
    }
    return id;
  };

  /**
   * Multi browser support for document scroll top
   * @returns {Number}
   */
  M.getDocumentScrollTop = function () {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  };

  /**
   * Multi browser support for document scroll left
   * @returns {Number}
   */
  M.getDocumentScrollLeft = function () {
    return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
  };

  /**
   * @typedef {Object} Edges
   * @property {Boolean} top  If the top edge was exceeded
   * @property {Boolean} right  If the right edge was exceeded
   * @property {Boolean} bottom  If the bottom edge was exceeded
   * @property {Boolean} left  If the left edge was exceeded
   */

  /**
   * @typedef {Object} Bounding
   * @property {Number} left  left offset coordinate
   * @property {Number} top  top offset coordinate
   * @property {Number} width
   * @property {Number} height
   */

  /**
   * Get time in ms
   * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
   * @type {function}
   * @return {number}
   */
  var getTime = Date.now || function () {
    return new Date().getTime();
  };

  /**
   * Returns a function, that, when invoked, will only be triggered at most once
   * during a given window of time. Normally, the throttled function will run
   * as much as it can, without ever going more than once per `wait` duration;
   * but if you'd like to disable the execution on the leading edge, pass
   * `{leading: false}`. To disable execution on the trailing edge, ditto.
   * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
   * @param {function} func
   * @param {number} wait
   * @param {Object=} options
   * @returns {Function}
   */
  M.throttle = function (func, wait, options) {
    var context = void 0,
        args = void 0,
        result = void 0;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : getTime();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function () {
      var now = getTime();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
  var $jscomp = { scope: {} };$jscomp.defineProperty = "function" == typeof Object.defineProperties ? Object.defineProperty : function (e, r, p) {
    if (p.get || p.set) throw new TypeError("ES3 does not support getters and setters.");e != Array.prototype && e != Object.prototype && (e[r] = p.value);
  };$jscomp.getGlobal = function (e) {
    return "undefined" != typeof window && window === e ? e : "undefined" != typeof commonjsGlobal && null != commonjsGlobal ? commonjsGlobal : e;
  };$jscomp.global = $jscomp.getGlobal(commonjsGlobal);$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
  $jscomp.initSymbol = function () {
    $jscomp.initSymbol = function () {};$jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
  };$jscomp.symbolCounter_ = 0;$jscomp.Symbol = function (e) {
    return $jscomp.SYMBOL_PREFIX + (e || "") + $jscomp.symbolCounter_++;
  };
  $jscomp.initSymbolIterator = function () {
    $jscomp.initSymbol();var e = $jscomp.global.Symbol.iterator;e || (e = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));"function" != typeof Array.prototype[e] && $jscomp.defineProperty(Array.prototype, e, { configurable: !0, writable: !0, value: function () {
        return $jscomp.arrayIterator(this);
      } });$jscomp.initSymbolIterator = function () {};
  };$jscomp.arrayIterator = function (e) {
    var r = 0;return $jscomp.iteratorPrototype(function () {
      return r < e.length ? { done: !1, value: e[r++] } : { done: !0 };
    });
  };
  $jscomp.iteratorPrototype = function (e) {
    $jscomp.initSymbolIterator();e = { next: e };e[$jscomp.global.Symbol.iterator] = function () {
      return this;
    };return e;
  };$jscomp.array = $jscomp.array || {};$jscomp.iteratorFromArray = function (e, r) {
    $jscomp.initSymbolIterator();e instanceof String && (e += "");var p = 0,
        m = { next: function () {
        if (p < e.length) {
          var u = p++;return { value: r(u, e[u]), done: !1 };
        }m.next = function () {
          return { done: !0, value: void 0 };
        };return m.next();
      } };m[Symbol.iterator] = function () {
      return m;
    };return m;
  };
  $jscomp.polyfill = function (e, r, p, m) {
    if (r) {
      p = $jscomp.global;e = e.split(".");for (m = 0; m < e.length - 1; m++) {
        var u = e[m];u in p || (p[u] = {});p = p[u];
      }e = e[e.length - 1];m = p[e];r = r(m);r != m && null != r && $jscomp.defineProperty(p, e, { configurable: !0, writable: !0, value: r });
    }
  };$jscomp.polyfill("Array.prototype.keys", function (e) {
    return e ? e : function () {
      return $jscomp.iteratorFromArray(this, function (e) {
        return e;
      });
    };
  }, "es6-impl", "es3");var $jscomp$this = commonjsGlobal;
  (function (r) {
    M.anime = r();
  })(function () {
    function e(a) {
      if (!h.col(a)) try {
        return document.querySelectorAll(a);
      } catch (c) {}
    }function r(a, c) {
      for (var d = a.length, b = 2 <= arguments.length ? arguments[1] : void 0, f = [], n = 0; n < d; n++) {
        if (n in a) {
          var k = a[n];c.call(b, k, n, a) && f.push(k);
        }
      }return f;
    }function p(a) {
      return a.reduce(function (a, d) {
        return a.concat(h.arr(d) ? p(d) : d);
      }, []);
    }function m(a) {
      if (h.arr(a)) return a;
      h.str(a) && (a = e(a) || a);return a instanceof NodeList || a instanceof HTMLCollection ? [].slice.call(a) : [a];
    }function u(a, c) {
      return a.some(function (a) {
        return a === c;
      });
    }function C(a) {
      var c = {},
          d;for (d in a) {
        c[d] = a[d];
      }return c;
    }function D(a, c) {
      var d = C(a),
          b;for (b in a) {
        d[b] = c.hasOwnProperty(b) ? c[b] : a[b];
      }return d;
    }function z(a, c) {
      var d = C(a),
          b;for (b in c) {
        d[b] = h.und(a[b]) ? c[b] : a[b];
      }return d;
    }function T(a) {
      a = a.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (a, c, d, k) {
        return c + c + d + d + k + k;
      });var c = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
      a = parseInt(c[1], 16);var d = parseInt(c[2], 16),
          c = parseInt(c[3], 16);return "rgba(" + a + "," + d + "," + c + ",1)";
    }function U(a) {
      function c(a, c, b) {
        0 > b && (b += 1);1 < b && --b;return b < 1 / 6 ? a + 6 * (c - a) * b : .5 > b ? c : b < 2 / 3 ? a + (c - a) * (2 / 3 - b) * 6 : a;
      }var d = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(a) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(a);a = parseInt(d[1]) / 360;var b = parseInt(d[2]) / 100,
          f = parseInt(d[3]) / 100,
          d = d[4] || 1;if (0 == b) f = b = a = f;else {
        var n = .5 > f ? f * (1 + b) : f + b - f * b,
            k = 2 * f - n,
            f = c(k, n, a + 1 / 3),
            b = c(k, n, a);a = c(k, n, a - 1 / 3);
      }return "rgba(" + 255 * f + "," + 255 * b + "," + 255 * a + "," + d + ")";
    }function y(a) {
      if (a = /([\+\-]?[0-9#\.]+)(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(a)) return a[2];
    }function V(a) {
      if (-1 < a.indexOf("translate") || "perspective" === a) return "px";if (-1 < a.indexOf("rotate") || -1 < a.indexOf("skew")) return "deg";
    }function I(a, c) {
      return h.fnc(a) ? a(c.target, c.id, c.total) : a;
    }function E(a, c) {
      if (c in a.style) return getComputedStyle(a).getPropertyValue(c.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()) || "0";
    }function J(a, c) {
      if (h.dom(a) && u(W, c)) return "transform";if (h.dom(a) && (a.getAttribute(c) || h.svg(a) && a[c])) return "attribute";if (h.dom(a) && "transform" !== c && E(a, c)) return "css";if (null != a[c]) return "object";
    }function X(a, c) {
      var d = V(c),
          d = -1 < c.indexOf("scale") ? 1 : 0 + d;a = a.style.transform;if (!a) return d;for (var b = [], f = [], n = [], k = /(\w+)\((.+?)\)/g; b = k.exec(a);) {
        f.push(b[1]), n.push(b[2]);
      }a = r(n, function (a, b) {
        return f[b] === c;
      });return a.length ? a[0] : d;
    }function K(a, c) {
      switch (J(a, c)) {case "transform":
          return X(a, c);case "css":
          return E(a, c);case "attribute":
          return a.getAttribute(c);}return a[c] || 0;
    }function L(a, c) {
      var d = /^(\*=|\+=|-=)/.exec(a);if (!d) return a;var b = y(a) || 0;c = parseFloat(c);a = parseFloat(a.replace(d[0], ""));switch (d[0][0]) {case "+":
          return c + a + b;case "-":
          return c - a + b;case "*":
          return c * a + b;}
    }function F(a, c) {
      return Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));
    }function M(a) {
      a = a.points;for (var c = 0, d, b = 0; b < a.numberOfItems; b++) {
        var f = a.getItem(b);0 < b && (c += F(d, f));d = f;
      }return c;
    }function N(a) {
      if (a.getTotalLength) return a.getTotalLength();switch (a.tagName.toLowerCase()) {case "circle":
          return 2 * Math.PI * a.getAttribute("r");case "rect":
          return 2 * a.getAttribute("width") + 2 * a.getAttribute("height");case "line":
          return F({ x: a.getAttribute("x1"), y: a.getAttribute("y1") }, { x: a.getAttribute("x2"), y: a.getAttribute("y2") });case "polyline":
          return M(a);case "polygon":
          var c = a.points;return M(a) + F(c.getItem(c.numberOfItems - 1), c.getItem(0));}
    }function Y(a, c) {
      function d(b) {
        b = void 0 === b ? 0 : b;return a.el.getPointAtLength(1 <= c + b ? c + b : 0);
      }var b = d(),
          f = d(-1),
          n = d(1);switch (a.property) {case "x":
          return b.x;case "y":
          return b.y;
        case "angle":
          return 180 * Math.atan2(n.y - f.y, n.x - f.x) / Math.PI;}
    }function O(a, c) {
      var d = /-?\d*\.?\d+/g,
          b;b = h.pth(a) ? a.totalLength : a;if (h.col(b)) {
        if (h.rgb(b)) {
          var f = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(b);b = f ? "rgba(" + f[1] + ",1)" : b;
        } else b = h.hex(b) ? T(b) : h.hsl(b) ? U(b) : void 0;
      } else f = (f = y(b)) ? b.substr(0, b.length - f.length) : b, b = c && !/\s/g.test(b) ? f + c : f;b += "";return { original: b, numbers: b.match(d) ? b.match(d).map(Number) : [0], strings: h.str(a) || c ? b.split(d) : [] };
    }function P(a) {
      a = a ? p(h.arr(a) ? a.map(m) : m(a)) : [];return r(a, function (a, d, b) {
        return b.indexOf(a) === d;
      });
    }function Z(a) {
      var c = P(a);return c.map(function (a, b) {
        return { target: a, id: b, total: c.length };
      });
    }function aa(a, c) {
      var d = C(c);if (h.arr(a)) {
        var b = a.length;2 !== b || h.obj(a[0]) ? h.fnc(c.duration) || (d.duration = c.duration / b) : a = { value: a };
      }return m(a).map(function (a, b) {
        b = b ? 0 : c.delay;a = h.obj(a) && !h.pth(a) ? a : { value: a };h.und(a.delay) && (a.delay = b);return a;
      }).map(function (a) {
        return z(a, d);
      });
    }function ba(a, c) {
      var d = {},
          b;for (b in a) {
        var f = I(a[b], c);h.arr(f) && (f = f.map(function (a) {
          return I(a, c);
        }), 1 === f.length && (f = f[0]));d[b] = f;
      }d.duration = parseFloat(d.duration);d.delay = parseFloat(d.delay);return d;
    }function ca(a) {
      return h.arr(a) ? A.apply(this, a) : Q[a];
    }function da(a, c) {
      var d;return a.tweens.map(function (b) {
        b = ba(b, c);var f = b.value,
            e = K(c.target, a.name),
            k = d ? d.to.original : e,
            k = h.arr(f) ? f[0] : k,
            w = L(h.arr(f) ? f[1] : f, k),
            e = y(w) || y(k) || y(e);b.from = O(k, e);b.to = O(w, e);b.start = d ? d.end : a.offset;b.end = b.start + b.delay + b.duration;b.easing = ca(b.easing);b.elasticity = (1E3 - Math.min(Math.max(b.elasticity, 1), 999)) / 1E3;b.isPath = h.pth(f);b.isColor = h.col(b.from.original);b.isColor && (b.round = 1);return d = b;
      });
    }function ea(a, c) {
      return r(p(a.map(function (a) {
        return c.map(function (b) {
          var c = J(a.target, b.name);if (c) {
            var d = da(b, a);b = { type: c, property: b.name, animatable: a, tweens: d, duration: d[d.length - 1].end, delay: d[0].delay };
          } else b = void 0;return b;
        });
      })), function (a) {
        return !h.und(a);
      });
    }function R(a, c, d, b) {
      var f = "delay" === a;return c.length ? (f ? Math.min : Math.max).apply(Math, c.map(function (b) {
        return b[a];
      })) : f ? b.delay : d.offset + b.delay + b.duration;
    }function fa(a) {
      var c = D(ga, a),
          d = D(S, a),
          b = Z(a.targets),
          f = [],
          e = z(c, d),
          k;for (k in a) {
        e.hasOwnProperty(k) || "targets" === k || f.push({ name: k, offset: e.offset, tweens: aa(a[k], d) });
      }a = ea(b, f);return z(c, { children: [], animatables: b, animations: a, duration: R("duration", a, c, d), delay: R("delay", a, c, d) });
    }function q(a) {
      function c() {
        return window.Promise && new Promise(function (a) {
          return p = a;
        });
      }function d(a) {
        return g.reversed ? g.duration - a : a;
      }function b(a) {
        for (var b = 0, c = {}, d = g.animations, f = d.length; b < f;) {
          var e = d[b],
              k = e.animatable,
              h = e.tweens,
              n = h.length - 1,
              l = h[n];n && (l = r(h, function (b) {
            return a < b.end;
          })[0] || l);for (var h = Math.min(Math.max(a - l.start - l.delay, 0), l.duration) / l.duration, w = isNaN(h) ? 1 : l.easing(h, l.elasticity), h = l.to.strings, p = l.round, n = [], m = void 0, m = l.to.numbers.length, t = 0; t < m; t++) {
            var x = void 0,
                x = l.to.numbers[t],
                q = l.from.numbers[t],
                x = l.isPath ? Y(l.value, w * x) : q + w * (x - q);p && (l.isColor && 2 < t || (x = Math.round(x * p) / p));n.push(x);
          }if (l = h.length) for (m = h[0], w = 0; w < l; w++) {
            p = h[w + 1], t = n[w], isNaN(t) || (m = p ? m + (t + p) : m + (t + " "));
          } else m = n[0];ha[e.type](k.target, e.property, m, c, k.id);e.currentValue = m;b++;
        }if (b = Object.keys(c).length) for (d = 0; d < b; d++) {
          H || (H = E(document.body, "transform") ? "transform" : "-webkit-transform"), g.animatables[d].target.style[H] = c[d].join(" ");
        }g.currentTime = a;g.progress = a / g.duration * 100;
      }function f(a) {
        if (g[a]) g[a](g);
      }function e() {
        g.remaining && !0 !== g.remaining && g.remaining--;
      }function k(a) {
        var k = g.duration,
            n = g.offset,
            w = n + g.delay,
            r = g.currentTime,
            x = g.reversed,
            q = d(a);if (g.children.length) {
          var u = g.children,
              v = u.length;
          if (q >= g.currentTime) for (var G = 0; G < v; G++) {
            u[G].seek(q);
          } else for (; v--;) {
            u[v].seek(q);
          }
        }if (q >= w || !k) g.began || (g.began = !0, f("begin")), f("run");if (q > n && q < k) b(q);else if (q <= n && 0 !== r && (b(0), x && e()), q >= k && r !== k || !k) b(k), x || e();f("update");a >= k && (g.remaining ? (t = h, "alternate" === g.direction && (g.reversed = !g.reversed)) : (g.pause(), g.completed || (g.completed = !0, f("complete"), "Promise" in window && (p(), m = c()))), l = 0);
      }a = void 0 === a ? {} : a;var h,
          t,
          l = 0,
          p = null,
          m = c(),
          g = fa(a);g.reset = function () {
        var a = g.direction,
            c = g.loop;g.currentTime = 0;g.progress = 0;g.paused = !0;g.began = !1;g.completed = !1;g.reversed = "reverse" === a;g.remaining = "alternate" === a && 1 === c ? 2 : c;b(0);for (a = g.children.length; a--;) {
          g.children[a].reset();
        }
      };g.tick = function (a) {
        h = a;t || (t = h);k((l + h - t) * q.speed);
      };g.seek = function (a) {
        k(d(a));
      };g.pause = function () {
        var a = v.indexOf(g);-1 < a && v.splice(a, 1);g.paused = !0;
      };g.play = function () {
        g.paused && (g.paused = !1, t = 0, l = d(g.currentTime), v.push(g), B || ia());
      };g.reverse = function () {
        g.reversed = !g.reversed;t = 0;l = d(g.currentTime);
      };g.restart = function () {
        g.pause();
        g.reset();g.play();
      };g.finished = m;g.reset();g.autoplay && g.play();return g;
    }var ga = { update: void 0, begin: void 0, run: void 0, complete: void 0, loop: 1, direction: "normal", autoplay: !0, offset: 0 },
        S = { duration: 1E3, delay: 0, easing: "easeOutElastic", elasticity: 500, round: 0 },
        W = "translateX translateY translateZ rotate rotateX rotateY rotateZ scale scaleX scaleY scaleZ skewX skewY perspective".split(" "),
        H,
        h = { arr: function (a) {
        return Array.isArray(a);
      }, obj: function (a) {
        return -1 < Object.prototype.toString.call(a).indexOf("Object");
      },
      pth: function (a) {
        return h.obj(a) && a.hasOwnProperty("totalLength");
      }, svg: function (a) {
        return a instanceof SVGElement;
      }, dom: function (a) {
        return a.nodeType || h.svg(a);
      }, str: function (a) {
        return "string" === typeof a;
      }, fnc: function (a) {
        return "function" === typeof a;
      }, und: function (a) {
        return "undefined" === typeof a;
      }, hex: function (a) {
        return (/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a)
        );
      }, rgb: function (a) {
        return (/^rgb/.test(a)
        );
      }, hsl: function (a) {
        return (/^hsl/.test(a)
        );
      }, col: function (a) {
        return h.hex(a) || h.rgb(a) || h.hsl(a);
      } },
        A = function () {
      function a(a, d, b) {
        return (((1 - 3 * b + 3 * d) * a + (3 * b - 6 * d)) * a + 3 * d) * a;
      }return function (c, d, b, f) {
        if (0 <= c && 1 >= c && 0 <= b && 1 >= b) {
          var e = new Float32Array(11);if (c !== d || b !== f) for (var k = 0; 11 > k; ++k) {
            e[k] = a(.1 * k, c, b);
          }return function (k) {
            if (c === d && b === f) return k;if (0 === k) return 0;if (1 === k) return 1;for (var h = 0, l = 1; 10 !== l && e[l] <= k; ++l) {
              h += .1;
            }--l;var l = h + (k - e[l]) / (e[l + 1] - e[l]) * .1,
                n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;if (.001 <= n) {
              for (h = 0; 4 > h; ++h) {
                n = 3 * (1 - 3 * b + 3 * c) * l * l + 2 * (3 * b - 6 * c) * l + 3 * c;if (0 === n) break;var m = a(l, c, b) - k,
                    l = l - m / n;
              }k = l;
            } else if (0 === n) k = l;else {
              var l = h,
                  h = h + .1,
                  g = 0;do {
                m = l + (h - l) / 2, n = a(m, c, b) - k, 0 < n ? h = m : l = m;
              } while (1e-7 < Math.abs(n) && 10 > ++g);k = m;
            }return a(k, d, f);
          };
        }
      };
    }(),
        Q = function () {
      function a(a, b) {
        return 0 === a || 1 === a ? a : -Math.pow(2, 10 * (a - 1)) * Math.sin(2 * (a - 1 - b / (2 * Math.PI) * Math.asin(1)) * Math.PI / b);
      }var c = "Quad Cubic Quart Quint Sine Expo Circ Back Elastic".split(" "),
          d = { In: [[.55, .085, .68, .53], [.55, .055, .675, .19], [.895, .03, .685, .22], [.755, .05, .855, .06], [.47, 0, .745, .715], [.95, .05, .795, .035], [.6, .04, .98, .335], [.6, -.28, .735, .045], a], Out: [[.25, .46, .45, .94], [.215, .61, .355, 1], [.165, .84, .44, 1], [.23, 1, .32, 1], [.39, .575, .565, 1], [.19, 1, .22, 1], [.075, .82, .165, 1], [.175, .885, .32, 1.275], function (b, c) {
          return 1 - a(1 - b, c);
        }], InOut: [[.455, .03, .515, .955], [.645, .045, .355, 1], [.77, 0, .175, 1], [.86, 0, .07, 1], [.445, .05, .55, .95], [1, 0, 0, 1], [.785, .135, .15, .86], [.68, -.55, .265, 1.55], function (b, c) {
          return .5 > b ? a(2 * b, c) / 2 : 1 - a(-2 * b + 2, c) / 2;
        }] },
          b = { linear: A(.25, .25, .75, .75) },
          f = {},
          e;for (e in d) {
        f.type = e, d[f.type].forEach(function (a) {
          return function (d, f) {
            b["ease" + a.type + c[f]] = h.fnc(d) ? d : A.apply($jscomp$this, d);
          };
        }(f)), f = { type: f.type };
      }return b;
    }(),
        ha = { css: function (a, c, d) {
        return a.style[c] = d;
      }, attribute: function (a, c, d) {
        return a.setAttribute(c, d);
      }, object: function (a, c, d) {
        return a[c] = d;
      }, transform: function (a, c, d, b, f) {
        b[f] || (b[f] = []);b[f].push(c + "(" + d + ")");
      } },
        v = [],
        B = 0,
        ia = function () {
      function a() {
        B = requestAnimationFrame(c);
      }function c(c) {
        var b = v.length;if (b) {
          for (var d = 0; d < b;) {
            v[d] && v[d].tick(c), d++;
          }a();
        } else cancelAnimationFrame(B), B = 0;
      }return a;
    }();q.version = "2.2.0";q.speed = 1;q.running = v;q.remove = function (a) {
      a = P(a);for (var c = v.length; c--;) {
        for (var d = v[c], b = d.animations, f = b.length; f--;) {
          u(a, b[f].animatable.target) && (b.splice(f, 1), b.length || d.pause());
        }
      }
    };q.getValue = K;q.path = function (a, c) {
      var d = h.str(a) ? e(a)[0] : a,
          b = c || 100;return function (a) {
        return { el: d, property: a, totalLength: N(d) * (b / 100) };
      };
    };q.setDashoffset = function (a) {
      var c = N(a);a.setAttribute("stroke-dasharray", c);return c;
    };q.bezier = A;q.easings = Q;q.timeline = function (a) {
      var c = q(a);c.pause();c.duration = 0;c.add = function (d) {
        c.children.forEach(function (a) {
          a.began = !0;a.completed = !0;
        });m(d).forEach(function (b) {
          var d = z(b, D(S, a || {}));d.targets = d.targets || a.targets;b = c.duration;var e = d.offset;d.autoplay = !1;d.direction = c.direction;d.offset = h.und(e) ? b : L(e, b);c.began = !0;c.completed = !0;c.seek(d.offset);d = q(d);d.began = !0;d.completed = !0;d.duration > b && (c.duration = d.duration);c.children.push(d);
        });c.seek(0);c.reset();c.autoplay && c.restart();return c;
      };return c;
    };q.random = function (a, c) {
      return Math.floor(Math.random() * (c - a + 1)) + a;
    };return q;
  });
  (function ($, anim) {

    var _defaults = {
      accordion: true,
      onOpenStart: undefined,
      onOpenEnd: undefined,
      onCloseStart: undefined,
      onCloseEnd: undefined,
      inDuration: 300,
      outDuration: 300
    };

    /**
     * @class
     *
     */

    var Collapsible = function (_Component) {
      _inherits(Collapsible, _Component);

      /**
       * Construct Collapsible instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Collapsible(el, options) {
        _classCallCheck(this, Collapsible);

        var _this3 = _possibleConstructorReturn(this, (Collapsible.__proto__ || Object.getPrototypeOf(Collapsible)).call(this, Collapsible, el, options));

        _this3.el.M_Collapsible = _this3;

        /**
         * Options for the collapsible
         * @member Collapsible#options
         * @prop {Boolean} [accordion=false] - Type of the collapsible
         * @prop {Function} onOpenStart - Callback function called before collapsible is opened
         * @prop {Function} onOpenEnd - Callback function called after collapsible is opened
         * @prop {Function} onCloseStart - Callback function called before collapsible is closed
         * @prop {Function} onCloseEnd - Callback function called after collapsible is closed
         * @prop {Number} inDuration - Transition in duration in milliseconds.
         * @prop {Number} outDuration - Transition duration in milliseconds.
         */
        _this3.options = $.extend({}, Collapsible.defaults, options);

        // Setup tab indices
        _this3.$headers = _this3.$el.children('li').children('.collapsible-header');
        _this3.$headers.attr('tabindex', 0);

        _this3._setupEventHandlers();

        // Open first active
        var $activeBodies = _this3.$el.children('li.active').children('.collapsible-body');
        if (_this3.options.accordion) {
          // Handle Accordion
          $activeBodies.first().css('display', 'block');
        } else {
          // Handle Expandables
          $activeBodies.css('display', 'block');
        }
        return _this3;
      }

      _createClass(Collapsible, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.el.M_Collapsible = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          var _this4 = this;

          this._handleCollapsibleClickBound = this._handleCollapsibleClick.bind(this);
          this._handleCollapsibleKeydownBound = this._handleCollapsibleKeydown.bind(this);
          this.el.addEventListener('click', this._handleCollapsibleClickBound);
          this.$headers.each(function (header) {
            header.addEventListener('keydown', _this4._handleCollapsibleKeydownBound);
          });
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          var _this5 = this;

          this.el.removeEventListener('click', this._handleCollapsibleClickBound);
          this.$headers.each(function (header) {
            header.removeEventListener('keydown', _this5._handleCollapsibleKeydownBound);
          });
        }

        /**
         * Handle Collapsible Click
         * @param {Event} e
         */

      }, {
        key: "_handleCollapsibleClick",
        value: function _handleCollapsibleClick(e) {
          var $header = $(e.target).closest('.collapsible-header');
          if (e.target && $header.length) {
            var $collapsible = $header.closest('.collapsible');
            if ($collapsible[0] === this.el) {
              var $collapsibleLi = $header.closest('li');
              var $collapsibleLis = $collapsible.children('li');
              var isActive = $collapsibleLi[0].classList.contains('active');
              var index = $collapsibleLis.index($collapsibleLi);

              if (isActive) {
                this.close(index);
              } else {
                this.open(index);
              }
            }
          }
        }

        /**
         * Handle Collapsible Keydown
         * @param {Event} e
         */

      }, {
        key: "_handleCollapsibleKeydown",
        value: function _handleCollapsibleKeydown(e) {
          if (e.keyCode === 13) {
            this._handleCollapsibleClickBound(e);
          }
        }

        /**
         * Animate in collapsible slide
         * @param {Number} index - 0th index of slide
         */

      }, {
        key: "_animateIn",
        value: function _animateIn(index) {
          var _this6 = this;

          var $collapsibleLi = this.$el.children('li').eq(index);
          if ($collapsibleLi.length) {
            var $body = $collapsibleLi.children('.collapsible-body');

            anim.remove($body[0]);
            $body.css({
              display: 'block',
              overflow: 'hidden',
              height: 0,
              paddingTop: '',
              paddingBottom: ''
            });

            var pTop = $body.css('padding-top');
            var pBottom = $body.css('padding-bottom');
            var finalHeight = $body[0].scrollHeight;
            $body.css({
              paddingTop: 0,
              paddingBottom: 0
            });

            anim({
              targets: $body[0],
              height: finalHeight,
              paddingTop: pTop,
              paddingBottom: pBottom,
              duration: this.options.inDuration,
              easing: 'easeInOutCubic',
              complete: function (anim) {
                $body.css({
                  overflow: '',
                  paddingTop: '',
                  paddingBottom: '',
                  height: ''
                });

                // onOpenEnd callback
                if (typeof _this6.options.onOpenEnd === 'function') {
                  _this6.options.onOpenEnd.call(_this6, $collapsibleLi[0]);
                }
              }
            });
          }
        }

        /**
         * Animate out collapsible slide
         * @param {Number} index - 0th index of slide to open
         */

      }, {
        key: "_animateOut",
        value: function _animateOut(index) {
          var _this7 = this;

          var $collapsibleLi = this.$el.children('li').eq(index);
          if ($collapsibleLi.length) {
            var $body = $collapsibleLi.children('.collapsible-body');
            anim.remove($body[0]);
            $body.css('overflow', 'hidden');
            anim({
              targets: $body[0],
              height: 0,
              paddingTop: 0,
              paddingBottom: 0,
              duration: this.options.outDuration,
              easing: 'easeInOutCubic',
              complete: function () {
                $body.css({
                  height: '',
                  overflow: '',
                  padding: '',
                  display: ''
                });

                // onCloseEnd callback
                if (typeof _this7.options.onCloseEnd === 'function') {
                  _this7.options.onCloseEnd.call(_this7, $collapsibleLi[0]);
                }
              }
            });
          }
        }

        /**
         * Open Collapsible
         * @param {Number} index - 0th index of slide
         */

      }, {
        key: "open",
        value: function open(index) {
          var _this8 = this;

          var $collapsibleLi = this.$el.children('li').eq(index);
          if ($collapsibleLi.length && !$collapsibleLi[0].classList.contains('active')) {
            // onOpenStart callback
            if (typeof this.options.onOpenStart === 'function') {
              this.options.onOpenStart.call(this, $collapsibleLi[0]);
            }

            // Handle accordion behavior
            if (this.options.accordion) {
              var $collapsibleLis = this.$el.children('li');
              var $activeLis = this.$el.children('li.active');
              $activeLis.each(function (el) {
                var index = $collapsibleLis.index($(el));
                _this8.close(index);
              });
            }

            // Animate in
            $collapsibleLi[0].classList.add('active');
            this._animateIn(index);
          }
        }

        /**
         * Close Collapsible
         * @param {Number} index - 0th index of slide
         */

      }, {
        key: "close",
        value: function close(index) {
          var $collapsibleLi = this.$el.children('li').eq(index);
          if ($collapsibleLi.length && $collapsibleLi[0].classList.contains('active')) {
            // onCloseStart callback
            if (typeof this.options.onCloseStart === 'function') {
              this.options.onCloseStart.call(this, $collapsibleLi[0]);
            }

            // Animate out
            $collapsibleLi[0].classList.remove('active');
            this._animateOut(index);
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Collapsible.__proto__ || Object.getPrototypeOf(Collapsible), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Collapsible;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Collapsible;
    }(Component);

    M.Collapsible = Collapsible;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Collapsible, 'collapsible', 'M_Collapsible');
    }
  })(cash, M.anime);
  (function ($, anim) {

    var _defaults = {
      alignment: 'left',
      autoFocus: true,
      constrainWidth: true,
      container: null,
      coverTrigger: true,
      closeOnClick: true,
      hover: false,
      inDuration: 150,
      outDuration: 250,
      onOpenStart: null,
      onOpenEnd: null,
      onCloseStart: null,
      onCloseEnd: null,
      onItemClick: null
    };

    /**
     * @class
     */

    var Dropdown = function (_Component2) {
      _inherits(Dropdown, _Component2);

      function Dropdown(el, options) {
        _classCallCheck(this, Dropdown);

        var _this9 = _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, Dropdown, el, options));

        _this9.el.M_Dropdown = _this9;
        Dropdown._dropdowns.push(_this9);

        _this9.id = M.getIdFromTrigger(el);
        _this9.dropdownEl = document.getElementById(_this9.id);
        _this9.$dropdownEl = $(_this9.dropdownEl);

        /**
         * Options for the dropdown
         * @member Dropdown#options
         * @prop {String} [alignment='left'] - Edge which the dropdown is aligned to
         * @prop {Boolean} [autoFocus=true] - Automatically focus dropdown el for keyboard
         * @prop {Boolean} [constrainWidth=true] - Constrain width to width of the button
         * @prop {Element} container - Container element to attach dropdown to (optional)
         * @prop {Boolean} [coverTrigger=true] - Place dropdown over trigger
         * @prop {Boolean} [closeOnClick=true] - Close on click of dropdown item
         * @prop {Boolean} [hover=false] - Open dropdown on hover
         * @prop {Number} [inDuration=150] - Duration of open animation in ms
         * @prop {Number} [outDuration=250] - Duration of close animation in ms
         * @prop {Function} onOpenStart - Function called when dropdown starts opening
         * @prop {Function} onOpenEnd - Function called when dropdown finishes opening
         * @prop {Function} onCloseStart - Function called when dropdown starts closing
         * @prop {Function} onCloseEnd - Function called when dropdown finishes closing
         */
        _this9.options = $.extend({}, Dropdown.defaults, options);

        /**
         * Describes open/close state of dropdown
         * @type {Boolean}
         */
        _this9.isOpen = false;

        /**
         * Describes if dropdown content is scrollable
         * @type {Boolean}
         */
        _this9.isScrollable = false;

        /**
         * Describes if touch moving on dropdown content
         * @type {Boolean}
         */
        _this9.isTouchMoving = false;

        _this9.focusedIndex = -1;
        _this9.filterQuery = [];

        // Move dropdown-content after dropdown-trigger
        if (!!_this9.options.container) {
          $(_this9.options.container).append(_this9.dropdownEl);
        } else {
          _this9.$el.after(_this9.dropdownEl);
        }

        _this9._makeDropdownFocusable();
        _this9._resetFilterQueryBound = _this9._resetFilterQuery.bind(_this9);
        _this9._handleDocumentClickBound = _this9._handleDocumentClick.bind(_this9);
        _this9._handleDocumentTouchmoveBound = _this9._handleDocumentTouchmove.bind(_this9);
        _this9._handleDropdownClickBound = _this9._handleDropdownClick.bind(_this9);
        _this9._handleDropdownKeydownBound = _this9._handleDropdownKeydown.bind(_this9);
        _this9._handleTriggerKeydownBound = _this9._handleTriggerKeydown.bind(_this9);
        _this9._setupEventHandlers();
        return _this9;
      }

      _createClass(Dropdown, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._resetDropdownStyles();
          this._removeEventHandlers();
          Dropdown._dropdowns.splice(Dropdown._dropdowns.indexOf(this), 1);
          this.el.M_Dropdown = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          // Trigger keydown handler
          this.el.addEventListener('keydown', this._handleTriggerKeydownBound);

          // Item click handler
          this.dropdownEl.addEventListener('click', this._handleDropdownClickBound);

          // Hover event handlers
          if (this.options.hover) {
            this._handleMouseEnterBound = this._handleMouseEnter.bind(this);
            this.el.addEventListener('mouseenter', this._handleMouseEnterBound);
            this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);
            this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);
            this.dropdownEl.addEventListener('mouseleave', this._handleMouseLeaveBound);

            // Click event handlers
          } else {
            this._handleClickBound = this._handleClick.bind(this);
            this.el.addEventListener('click', this._handleClickBound);
          }
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('keydown', this._handleTriggerKeydownBound);
          this.dropdownEl.removeEventListener('click', this._handleDropdownClickBound);

          if (this.options.hover) {
            this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);
            this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);
            this.dropdownEl.removeEventListener('mouseleave', this._handleMouseLeaveBound);
          } else {
            this.el.removeEventListener('click', this._handleClickBound);
          }
        }
      }, {
        key: "_setupTemporaryEventHandlers",
        value: function _setupTemporaryEventHandlers() {
          // Use capture phase event handler to prevent click
          document.body.addEventListener('click', this._handleDocumentClickBound, true);
          document.body.addEventListener('touchend', this._handleDocumentClickBound);
          document.body.addEventListener('touchmove', this._handleDocumentTouchmoveBound);
          this.dropdownEl.addEventListener('keydown', this._handleDropdownKeydownBound);
        }
      }, {
        key: "_removeTemporaryEventHandlers",
        value: function _removeTemporaryEventHandlers() {
          // Use capture phase event handler to prevent click
          document.body.removeEventListener('click', this._handleDocumentClickBound, true);
          document.body.removeEventListener('touchend', this._handleDocumentClickBound);
          document.body.removeEventListener('touchmove', this._handleDocumentTouchmoveBound);
          this.dropdownEl.removeEventListener('keydown', this._handleDropdownKeydownBound);
        }
      }, {
        key: "_handleClick",
        value: function _handleClick(e) {
          e.preventDefault();
          this.open();
        }
      }, {
        key: "_handleMouseEnter",
        value: function _handleMouseEnter() {
          this.open();
        }
      }, {
        key: "_handleMouseLeave",
        value: function _handleMouseLeave(e) {
          var toEl = e.toElement || e.relatedTarget;
          var leaveToDropdownContent = !!$(toEl).closest('.dropdown-content').length;
          var leaveToActiveDropdownTrigger = false;

          var $closestTrigger = $(toEl).closest('.dropdown-trigger');
          if ($closestTrigger.length && !!$closestTrigger[0].M_Dropdown && $closestTrigger[0].M_Dropdown.isOpen) {
            leaveToActiveDropdownTrigger = true;
          }

          // Close hover dropdown if mouse did not leave to either active dropdown-trigger or dropdown-content
          if (!leaveToActiveDropdownTrigger && !leaveToDropdownContent) {
            this.close();
          }
        }
      }, {
        key: "_handleDocumentClick",
        value: function _handleDocumentClick(e) {
          var _this10 = this;

          var $target = $(e.target);
          if (this.options.closeOnClick && $target.closest('.dropdown-content').length && !this.isTouchMoving) {
            // isTouchMoving to check if scrolling on mobile.
            setTimeout(function () {
              _this10.close();
            }, 0);
          } else if ($target.closest('.dropdown-trigger').length || !$target.closest('.dropdown-content').length) {
            setTimeout(function () {
              _this10.close();
            }, 0);
          }
          this.isTouchMoving = false;
        }
      }, {
        key: "_handleTriggerKeydown",
        value: function _handleTriggerKeydown(e) {
          // ARROW DOWN OR ENTER WHEN SELECT IS CLOSED - open Dropdown
          if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ENTER) && !this.isOpen) {
            e.preventDefault();
            this.open();
          }
        }

        /**
         * Handle Document Touchmove
         * @param {Event} e
         */

      }, {
        key: "_handleDocumentTouchmove",
        value: function _handleDocumentTouchmove(e) {
          var $target = $(e.target);
          if ($target.closest('.dropdown-content').length) {
            this.isTouchMoving = true;
          }
        }

        /**
         * Handle Dropdown Click
         * @param {Event} e
         */

      }, {
        key: "_handleDropdownClick",
        value: function _handleDropdownClick(e) {
          // onItemClick callback
          if (typeof this.options.onItemClick === 'function') {
            var itemEl = $(e.target).closest('li')[0];
            this.options.onItemClick.call(this, itemEl);
          }
        }

        /**
         * Handle Dropdown Keydown
         * @param {Event} e
         */

      }, {
        key: "_handleDropdownKeydown",
        value: function _handleDropdownKeydown(e) {
          if (e.which === M.keys.TAB) {
            e.preventDefault();
            this.close();

            // Navigate down dropdown list
          } else if ((e.which === M.keys.ARROW_DOWN || e.which === M.keys.ARROW_UP) && this.isOpen) {
            e.preventDefault();
            var direction = e.which === M.keys.ARROW_DOWN ? 1 : -1;
            var newFocusedIndex = this.focusedIndex;
            var foundNewIndex = false;
            do {
              newFocusedIndex = newFocusedIndex + direction;

              if (!!this.dropdownEl.children[newFocusedIndex] && this.dropdownEl.children[newFocusedIndex].tabIndex !== -1) {
                foundNewIndex = true;
                break;
              }
            } while (newFocusedIndex < this.dropdownEl.children.length && newFocusedIndex >= 0);

            if (foundNewIndex) {
              this.focusedIndex = newFocusedIndex;
              this._focusFocusedItem();
            }

            // ENTER selects choice on focused item
          } else if (e.which === M.keys.ENTER && this.isOpen) {
            // Search for <a> and <button>
            var focusedElement = this.dropdownEl.children[this.focusedIndex];
            var $activatableElement = $(focusedElement).find('a, button').first();

            // Click a or button tag if exists, otherwise click li tag
            !!$activatableElement.length ? $activatableElement[0].click() : focusedElement.click();

            // Close dropdown on ESC
          } else if (e.which === M.keys.ESC && this.isOpen) {
            e.preventDefault();
            this.close();
          }

          // CASE WHEN USER TYPE LETTERS
          var letter = String.fromCharCode(e.which).toLowerCase(),
              nonLetters = [9, 13, 27, 38, 40];
          if (letter && nonLetters.indexOf(e.which) === -1) {
            this.filterQuery.push(letter);

            var string = this.filterQuery.join(''),
                newOptionEl = $(this.dropdownEl).find('li').filter(function (el) {
              return $(el).text().toLowerCase().indexOf(string) === 0;
            })[0];

            if (newOptionEl) {
              this.focusedIndex = $(newOptionEl).index();
              this._focusFocusedItem();
            }
          }

          this.filterTimeout = setTimeout(this._resetFilterQueryBound, 1000);
        }

        /**
         * Setup dropdown
         */

      }, {
        key: "_resetFilterQuery",
        value: function _resetFilterQuery() {
          this.filterQuery = [];
        }
      }, {
        key: "_resetDropdownStyles",
        value: function _resetDropdownStyles() {
          this.$dropdownEl.css({
            display: '',
            width: '',
            height: '',
            left: '',
            top: '',
            'transform-origin': '',
            transform: '',
            opacity: ''
          });
        }
      }, {
        key: "_makeDropdownFocusable",
        value: function _makeDropdownFocusable() {
          // Needed for arrow key navigation
          this.dropdownEl.tabIndex = 0;

          // Only set tabindex if it hasn't been set by user
          $(this.dropdownEl).children().each(function (el) {
            if (!el.getAttribute('tabindex')) {
              el.setAttribute('tabindex', 0);
            }
          });
        }
      }, {
        key: "_focusFocusedItem",
        value: function _focusFocusedItem() {
          if (this.focusedIndex >= 0 && this.focusedIndex < this.dropdownEl.children.length && this.options.autoFocus) {
            this.dropdownEl.children[this.focusedIndex].focus();
          }
        }
      }, {
        key: "_getDropdownPosition",
        value: function _getDropdownPosition() {
          var offsetParentBRect = this.el.offsetParent.getBoundingClientRect();
          var triggerBRect = this.el.getBoundingClientRect();
          var dropdownBRect = this.dropdownEl.getBoundingClientRect();

          var idealHeight = dropdownBRect.height;
          var idealWidth = dropdownBRect.width;
          var idealXPos = triggerBRect.left - dropdownBRect.left;
          var idealYPos = triggerBRect.top - dropdownBRect.top;

          var dropdownBounds = {
            left: idealXPos,
            top: idealYPos,
            height: idealHeight,
            width: idealWidth
          };

          // Countainer here will be closest ancestor with overflow: hidden
          var closestOverflowParent = !!this.dropdownEl.offsetParent ? this.dropdownEl.offsetParent : this.dropdownEl.parentNode;

          var alignments = M.checkPossibleAlignments(this.el, closestOverflowParent, dropdownBounds, this.options.coverTrigger ? 0 : triggerBRect.height);

          var verticalAlignment = 'top';
          var horizontalAlignment = this.options.alignment;
          idealYPos += this.options.coverTrigger ? 0 : triggerBRect.height;

          // Reset isScrollable
          this.isScrollable = false;

          if (!alignments.top) {
            if (alignments.bottom) {
              verticalAlignment = 'bottom';
            } else {
              this.isScrollable = true;

              // Determine which side has most space and cutoff at correct height
              if (alignments.spaceOnTop > alignments.spaceOnBottom) {
                verticalAlignment = 'bottom';
                idealHeight += alignments.spaceOnTop;
                idealYPos -= alignments.spaceOnTop;
              } else {
                idealHeight += alignments.spaceOnBottom;
              }
            }
          }

          // If preferred horizontal alignment is possible
          if (!alignments[horizontalAlignment]) {
            var oppositeAlignment = horizontalAlignment === 'left' ? 'right' : 'left';
            if (alignments[oppositeAlignment]) {
              horizontalAlignment = oppositeAlignment;
            } else {
              // Determine which side has most space and cutoff at correct height
              if (alignments.spaceOnLeft > alignments.spaceOnRight) {
                horizontalAlignment = 'right';
                idealWidth += alignments.spaceOnLeft;
                idealXPos -= alignments.spaceOnLeft;
              } else {
                horizontalAlignment = 'left';
                idealWidth += alignments.spaceOnRight;
              }
            }
          }

          if (verticalAlignment === 'bottom') {
            idealYPos = idealYPos - dropdownBRect.height + (this.options.coverTrigger ? triggerBRect.height : 0);
          }
          if (horizontalAlignment === 'right') {
            idealXPos = idealXPos - dropdownBRect.width + triggerBRect.width;
          }
          return {
            x: idealXPos,
            y: idealYPos,
            verticalAlignment: verticalAlignment,
            horizontalAlignment: horizontalAlignment,
            height: idealHeight,
            width: idealWidth
          };
        }

        /**
         * Animate in dropdown
         */

      }, {
        key: "_animateIn",
        value: function _animateIn() {
          var _this11 = this;

          anim.remove(this.dropdownEl);
          anim({
            targets: this.dropdownEl,
            opacity: {
              value: [0, 1],
              easing: 'easeOutQuad'
            },
            scaleX: [0.3, 1],
            scaleY: [0.3, 1],
            duration: this.options.inDuration,
            easing: 'easeOutQuint',
            complete: function (anim) {
              if (_this11.options.autoFocus) {
                _this11.dropdownEl.focus();
              }

              // onOpenEnd callback
              if (typeof _this11.options.onOpenEnd === 'function') {
                var elem = anim.animatables[0].target;
                _this11.options.onOpenEnd.call(elem, _this11.el);
              }
            }
          });
        }

        /**
         * Animate out dropdown
         */

      }, {
        key: "_animateOut",
        value: function _animateOut() {
          var _this12 = this;

          anim.remove(this.dropdownEl);
          anim({
            targets: this.dropdownEl,
            opacity: {
              value: 0,
              easing: 'easeOutQuint'
            },
            scaleX: 0.3,
            scaleY: 0.3,
            duration: this.options.outDuration,
            easing: 'easeOutQuint',
            complete: function (anim) {
              _this12._resetDropdownStyles();

              // onCloseEnd callback
              if (typeof _this12.options.onCloseEnd === 'function') {
                var elem = anim.animatables[0].target;
                _this12.options.onCloseEnd.call(_this12, _this12.el);
              }
            }
          });
        }

        /**
         * Place dropdown
         */

      }, {
        key: "_placeDropdown",
        value: function _placeDropdown() {
          // Set width before calculating positionInfo
          var idealWidth = this.options.constrainWidth ? this.el.getBoundingClientRect().width : this.dropdownEl.getBoundingClientRect().width;
          this.dropdownEl.style.width = idealWidth + 'px';

          var positionInfo = this._getDropdownPosition();
          this.dropdownEl.style.left = positionInfo.x + 'px';
          this.dropdownEl.style.top = positionInfo.y + 'px';
          this.dropdownEl.style.height = positionInfo.height + 'px';
          this.dropdownEl.style.width = positionInfo.width + 'px';
          this.dropdownEl.style.transformOrigin = (positionInfo.horizontalAlignment === 'left' ? '0' : '100%') + " " + (positionInfo.verticalAlignment === 'top' ? '0' : '100%');
        }

        /**
         * Open Dropdown
         */

      }, {
        key: "open",
        value: function open() {
          if (this.isOpen) {
            return;
          }
          this.isOpen = true;

          // onOpenStart callback
          if (typeof this.options.onOpenStart === 'function') {
            this.options.onOpenStart.call(this, this.el);
          }

          // Reset styles
          this._resetDropdownStyles();
          this.dropdownEl.style.display = 'block';

          this._placeDropdown();
          this._animateIn();
          this._setupTemporaryEventHandlers();
        }

        /**
         * Close Dropdown
         */

      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen) {
            return;
          }
          this.isOpen = false;
          this.focusedIndex = -1;

          // onCloseStart callback
          if (typeof this.options.onCloseStart === 'function') {
            this.options.onCloseStart.call(this, this.el);
          }

          this._animateOut();
          this._removeTemporaryEventHandlers();

          if (this.options.autoFocus) {
            this.el.focus();
          }
        }

        /**
         * Recalculate dimensions
         */

      }, {
        key: "recalculateDimensions",
        value: function recalculateDimensions() {
          if (this.isOpen) {
            this.$dropdownEl.css({
              width: '',
              height: '',
              left: '',
              top: '',
              'transform-origin': ''
            });
            this._placeDropdown();
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Dropdown.__proto__ || Object.getPrototypeOf(Dropdown), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Dropdown;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Dropdown;
    }(Component);

    /**
     * @static
     * @memberof Dropdown
     */


    Dropdown._dropdowns = [];

    window.M.Dropdown = Dropdown;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Dropdown, 'dropdown', 'M_Dropdown');
    }
  })(cash, M.anime);
  (function ($, anim) {

    var _defaults = {
      opacity: 0.5,
      inDuration: 250,
      outDuration: 250,
      onOpenStart: null,
      onOpenEnd: null,
      onCloseStart: null,
      onCloseEnd: null,
      preventScrolling: true,
      dismissible: true,
      startingTop: '4%',
      endingTop: '10%'
    };

    /**
     * @class
     *
     */

    var Modal = function (_Component3) {
      _inherits(Modal, _Component3);

      /**
       * Construct Modal instance and set up overlay
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Modal(el, options) {
        _classCallCheck(this, Modal);

        var _this13 = _possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, Modal, el, options));

        _this13.el.M_Modal = _this13;

        /**
         * Options for the modal
         * @member Modal#options
         * @prop {Number} [opacity=0.5] - Opacity of the modal overlay
         * @prop {Number} [inDuration=250] - Length in ms of enter transition
         * @prop {Number} [outDuration=250] - Length in ms of exit transition
         * @prop {Function} onOpenStart - Callback function called before modal is opened
         * @prop {Function} onOpenEnd - Callback function called after modal is opened
         * @prop {Function} onCloseStart - Callback function called before modal is closed
         * @prop {Function} onCloseEnd - Callback function called after modal is closed
         * @prop {Boolean} [dismissible=true] - Allow modal to be dismissed by keyboard or overlay click
         * @prop {String} [startingTop='4%'] - startingTop
         * @prop {String} [endingTop='10%'] - endingTop
         */
        _this13.options = $.extend({}, Modal.defaults, options);

        /**
         * Describes open/close state of modal
         * @type {Boolean}
         */
        _this13.isOpen = false;

        _this13.id = _this13.$el.attr('id');
        _this13._openingTrigger = undefined;
        _this13.$overlay = $('<div class="modal-overlay"></div>');
        _this13.el.tabIndex = 0;
        _this13._nthModalOpened = 0;

        Modal._count++;
        _this13._setupEventHandlers();
        return _this13;
      }

      _createClass(Modal, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          Modal._count--;
          this._removeEventHandlers();
          this.el.removeAttribute('style');
          this.$overlay.remove();
          this.el.M_Modal = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleOverlayClickBound = this._handleOverlayClick.bind(this);
          this._handleModalCloseClickBound = this._handleModalCloseClick.bind(this);

          if (Modal._count === 1) {
            document.body.addEventListener('click', this._handleTriggerClick);
          }
          this.$overlay[0].addEventListener('click', this._handleOverlayClickBound);
          this.el.addEventListener('click', this._handleModalCloseClickBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          if (Modal._count === 0) {
            document.body.removeEventListener('click', this._handleTriggerClick);
          }
          this.$overlay[0].removeEventListener('click', this._handleOverlayClickBound);
          this.el.removeEventListener('click', this._handleModalCloseClickBound);
        }

        /**
         * Handle Trigger Click
         * @param {Event} e
         */

      }, {
        key: "_handleTriggerClick",
        value: function _handleTriggerClick(e) {
          var $trigger = $(e.target).closest('.modal-trigger');
          if ($trigger.length) {
            var modalId = M.getIdFromTrigger($trigger[0]);
            var modalInstance = document.getElementById(modalId).M_Modal;
            if (modalInstance) {
              modalInstance.open($trigger);
            }
            e.preventDefault();
          }
        }

        /**
         * Handle Overlay Click
         */

      }, {
        key: "_handleOverlayClick",
        value: function _handleOverlayClick() {
          if (this.options.dismissible) {
            this.close();
          }
        }

        /**
         * Handle Modal Close Click
         * @param {Event} e
         */

      }, {
        key: "_handleModalCloseClick",
        value: function _handleModalCloseClick(e) {
          var $closeTrigger = $(e.target).closest('.modal-close');
          if ($closeTrigger.length) {
            this.close();
          }
        }

        /**
         * Handle Keydown
         * @param {Event} e
         */

      }, {
        key: "_handleKeydown",
        value: function _handleKeydown(e) {
          // ESC key
          if (e.keyCode === 27 && this.options.dismissible) {
            this.close();
          }
        }

        /**
         * Handle Focus
         * @param {Event} e
         */

      }, {
        key: "_handleFocus",
        value: function _handleFocus(e) {
          // Only trap focus if this modal is the last model opened (prevents loops in nested modals).
          if (!this.el.contains(e.target) && this._nthModalOpened === Modal._modalsOpen) {
            this.el.focus();
          }
        }

        /**
         * Animate in modal
         */

      }, {
        key: "_animateIn",
        value: function _animateIn() {
          var _this14 = this;

          // Set initial styles
          $.extend(this.el.style, {
            display: 'block',
            opacity: 0
          });
          $.extend(this.$overlay[0].style, {
            display: 'block',
            opacity: 0
          });

          // Animate overlay
          anim({
            targets: this.$overlay[0],
            opacity: this.options.opacity,
            duration: this.options.inDuration,
            easing: 'easeOutQuad'
          });

          // Define modal animation options
          var enterAnimOptions = {
            targets: this.el,
            duration: this.options.inDuration,
            easing: 'easeOutCubic',
            // Handle modal onOpenEnd callback
            complete: function () {
              if (typeof _this14.options.onOpenEnd === 'function') {
                _this14.options.onOpenEnd.call(_this14, _this14.el, _this14._openingTrigger);
              }
            }
          };

          // Bottom sheet animation
          if (this.el.classList.contains('bottom-sheet')) {
            $.extend(enterAnimOptions, {
              bottom: 0,
              opacity: 1
            });
            anim(enterAnimOptions);

            // Normal modal animation
          } else {
            $.extend(enterAnimOptions, {
              top: [this.options.startingTop, this.options.endingTop],
              opacity: 1,
              scaleX: [0.8, 1],
              scaleY: [0.8, 1]
            });
            anim(enterAnimOptions);
          }
        }

        /**
         * Animate out modal
         */

      }, {
        key: "_animateOut",
        value: function _animateOut() {
          var _this15 = this;

          // Animate overlay
          anim({
            targets: this.$overlay[0],
            opacity: 0,
            duration: this.options.outDuration,
            easing: 'easeOutQuart'
          });

          // Define modal animation options
          var exitAnimOptions = {
            targets: this.el,
            duration: this.options.outDuration,
            easing: 'easeOutCubic',
            // Handle modal ready callback
            complete: function () {
              _this15.el.style.display = 'none';
              _this15.$overlay.remove();

              // Call onCloseEnd callback
              if (typeof _this15.options.onCloseEnd === 'function') {
                _this15.options.onCloseEnd.call(_this15, _this15.el);
              }
            }
          };

          // Bottom sheet animation
          if (this.el.classList.contains('bottom-sheet')) {
            $.extend(exitAnimOptions, {
              bottom: '-100%',
              opacity: 0
            });
            anim(exitAnimOptions);

            // Normal modal animation
          } else {
            $.extend(exitAnimOptions, {
              top: [this.options.endingTop, this.options.startingTop],
              opacity: 0,
              scaleX: 0.8,
              scaleY: 0.8
            });
            anim(exitAnimOptions);
          }
        }

        /**
         * Open Modal
         * @param {cash} [$trigger]
         */

      }, {
        key: "open",
        value: function open($trigger) {
          if (this.isOpen) {
            return;
          }

          this.isOpen = true;
          Modal._modalsOpen++;
          this._nthModalOpened = Modal._modalsOpen;

          // Set Z-Index based on number of currently open modals
          this.$overlay[0].style.zIndex = 1000 + Modal._modalsOpen * 2;
          this.el.style.zIndex = 1000 + Modal._modalsOpen * 2 + 1;

          // Set opening trigger, undefined indicates modal was opened by javascript
          this._openingTrigger = !!$trigger ? $trigger[0] : undefined;

          // onOpenStart callback
          if (typeof this.options.onOpenStart === 'function') {
            this.options.onOpenStart.call(this, this.el, this._openingTrigger);
          }

          if (this.options.preventScrolling) {
            document.body.style.overflow = 'hidden';
          }

          this.el.classList.add('open');
          this.el.insertAdjacentElement('afterend', this.$overlay[0]);

          if (this.options.dismissible) {
            this._handleKeydownBound = this._handleKeydown.bind(this);
            this._handleFocusBound = this._handleFocus.bind(this);
            document.addEventListener('keydown', this._handleKeydownBound);
            document.addEventListener('focus', this._handleFocusBound, true);
          }

          anim.remove(this.el);
          anim.remove(this.$overlay[0]);
          this._animateIn();

          // Focus modal
          this.el.focus();

          return this;
        }

        /**
         * Close Modal
         */

      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen) {
            return;
          }

          this.isOpen = false;
          Modal._modalsOpen--;
          this._nthModalOpened = 0;

          // Call onCloseStart callback
          if (typeof this.options.onCloseStart === 'function') {
            this.options.onCloseStart.call(this, this.el);
          }

          this.el.classList.remove('open');

          // Enable body scrolling only if there are no more modals open.
          if (Modal._modalsOpen === 0) {
            document.body.style.overflow = '';
          }

          if (this.options.dismissible) {
            document.removeEventListener('keydown', this._handleKeydownBound);
            document.removeEventListener('focus', this._handleFocusBound, true);
          }

          anim.remove(this.el);
          anim.remove(this.$overlay[0]);
          this._animateOut();
          return this;
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Modal.__proto__ || Object.getPrototypeOf(Modal), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Modal;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Modal;
    }(Component);

    /**
     * @static
     * @memberof Modal
     */


    Modal._modalsOpen = 0;

    /**
     * @static
     * @memberof Modal
     */
    Modal._count = 0;

    M.Modal = Modal;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Modal, 'modal', 'M_Modal');
    }
  })(cash, M.anime);
  (function ($, anim) {

    var _defaults = {
      inDuration: 275,
      outDuration: 200,
      onOpenStart: null,
      onOpenEnd: null,
      onCloseStart: null,
      onCloseEnd: null
    };

    /**
     * @class
     *
     */

    var Materialbox = function (_Component4) {
      _inherits(Materialbox, _Component4);

      /**
       * Construct Materialbox instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Materialbox(el, options) {
        _classCallCheck(this, Materialbox);

        var _this16 = _possibleConstructorReturn(this, (Materialbox.__proto__ || Object.getPrototypeOf(Materialbox)).call(this, Materialbox, el, options));

        _this16.el.M_Materialbox = _this16;

        /**
         * Options for the modal
         * @member Materialbox#options
         * @prop {Number} [inDuration=275] - Length in ms of enter transition
         * @prop {Number} [outDuration=200] - Length in ms of exit transition
         * @prop {Function} onOpenStart - Callback function called before materialbox is opened
         * @prop {Function} onOpenEnd - Callback function called after materialbox is opened
         * @prop {Function} onCloseStart - Callback function called before materialbox is closed
         * @prop {Function} onCloseEnd - Callback function called after materialbox is closed
         */
        _this16.options = $.extend({}, Materialbox.defaults, options);

        _this16.overlayActive = false;
        _this16.doneAnimating = true;
        _this16.placeholder = $('<div></div>').addClass('material-placeholder');
        _this16.originalWidth = 0;
        _this16.originalHeight = 0;
        _this16.originInlineStyles = _this16.$el.attr('style');
        _this16.caption = _this16.el.getAttribute('data-caption') || '';

        // Wrap
        _this16.$el.before(_this16.placeholder);
        _this16.placeholder.append(_this16.$el);

        _this16._setupEventHandlers();
        return _this16;
      }

      _createClass(Materialbox, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.el.M_Materialbox = undefined;

          // Unwrap image
          $(this.placeholder).after(this.el).remove();

          this.$el.removeAttr('style');
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleMaterialboxClickBound = this._handleMaterialboxClick.bind(this);
          this.el.addEventListener('click', this._handleMaterialboxClickBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('click', this._handleMaterialboxClickBound);
        }

        /**
         * Handle Materialbox Click
         * @param {Event} e
         */

      }, {
        key: "_handleMaterialboxClick",
        value: function _handleMaterialboxClick(e) {
          // If already modal, return to original
          if (this.doneAnimating === false || this.overlayActive && this.doneAnimating) {
            this.close();
          } else {
            this.open();
          }
        }

        /**
         * Handle Window Scroll
         */

      }, {
        key: "_handleWindowScroll",
        value: function _handleWindowScroll() {
          if (this.overlayActive) {
            this.close();
          }
        }

        /**
         * Handle Window Resize
         */

      }, {
        key: "_handleWindowResize",
        value: function _handleWindowResize() {
          if (this.overlayActive) {
            this.close();
          }
        }

        /**
         * Handle Window Resize
         * @param {Event} e
         */

      }, {
        key: "_handleWindowEscape",
        value: function _handleWindowEscape(e) {
          // ESC key
          if (e.keyCode === 27 && this.doneAnimating && this.overlayActive) {
            this.close();
          }
        }

        /**
         * Find ancestors with overflow: hidden; and make visible
         */

      }, {
        key: "_makeAncestorsOverflowVisible",
        value: function _makeAncestorsOverflowVisible() {
          this.ancestorsChanged = $();
          var ancestor = this.placeholder[0].parentNode;
          while (ancestor !== null && !$(ancestor).is(document)) {
            var curr = $(ancestor);
            if (curr.css('overflow') !== 'visible') {
              curr.css('overflow', 'visible');
              if (this.ancestorsChanged === undefined) {
                this.ancestorsChanged = curr;
              } else {
                this.ancestorsChanged = this.ancestorsChanged.add(curr);
              }
            }
            ancestor = ancestor.parentNode;
          }
        }

        /**
         * Animate image in
         */

      }, {
        key: "_animateImageIn",
        value: function _animateImageIn() {
          var _this17 = this;

          var animOptions = {
            targets: this.el,
            height: [this.originalHeight, this.newHeight],
            width: [this.originalWidth, this.newWidth],
            left: M.getDocumentScrollLeft() + this.windowWidth / 2 - this.placeholder.offset().left - this.newWidth / 2,
            top: M.getDocumentScrollTop() + this.windowHeight / 2 - this.placeholder.offset().top - this.newHeight / 2,
            duration: this.options.inDuration,
            easing: 'easeOutQuad',
            complete: function () {
              _this17.doneAnimating = true;

              // onOpenEnd callback
              if (typeof _this17.options.onOpenEnd === 'function') {
                _this17.options.onOpenEnd.call(_this17, _this17.el);
              }
            }
          };

          // Override max-width or max-height if needed
          this.maxWidth = this.$el.css('max-width');
          this.maxHeight = this.$el.css('max-height');
          if (this.maxWidth !== 'none') {
            animOptions.maxWidth = this.newWidth;
          }
          if (this.maxHeight !== 'none') {
            animOptions.maxHeight = this.newHeight;
          }

          anim(animOptions);
        }

        /**
         * Animate image out
         */

      }, {
        key: "_animateImageOut",
        value: function _animateImageOut() {
          var _this18 = this;

          var animOptions = {
            targets: this.el,
            width: this.originalWidth,
            height: this.originalHeight,
            left: 0,
            top: 0,
            duration: this.options.outDuration,
            easing: 'easeOutQuad',
            complete: function () {
              _this18.placeholder.css({
                height: '',
                width: '',
                position: '',
                top: '',
                left: ''
              });

              // Revert to width or height attribute
              if (_this18.attrWidth) {
                _this18.$el.attr('width', _this18.attrWidth);
              }
              if (_this18.attrHeight) {
                _this18.$el.attr('height', _this18.attrHeight);
              }

              _this18.$el.removeAttr('style');
              _this18.originInlineStyles && _this18.$el.attr('style', _this18.originInlineStyles);

              // Remove class
              _this18.$el.removeClass('active');
              _this18.doneAnimating = true;

              // Remove overflow overrides on ancestors
              if (_this18.ancestorsChanged.length) {
                _this18.ancestorsChanged.css('overflow', '');
              }

              // onCloseEnd callback
              if (typeof _this18.options.onCloseEnd === 'function') {
                _this18.options.onCloseEnd.call(_this18, _this18.el);
              }
            }
          };

          anim(animOptions);
        }

        /**
         * Update open and close vars
         */

      }, {
        key: "_updateVars",
        value: function _updateVars() {
          this.windowWidth = window.innerWidth;
          this.windowHeight = window.innerHeight;
          this.caption = this.el.getAttribute('data-caption') || '';
        }

        /**
         * Open Materialbox
         */

      }, {
        key: "open",
        value: function open() {
          var _this19 = this;

          this._updateVars();
          this.originalWidth = this.el.getBoundingClientRect().width;
          this.originalHeight = this.el.getBoundingClientRect().height;

          // Set states
          this.doneAnimating = false;
          this.$el.addClass('active');
          this.overlayActive = true;

          // onOpenStart callback
          if (typeof this.options.onOpenStart === 'function') {
            this.options.onOpenStart.call(this, this.el);
          }

          // Set positioning for placeholder
          this.placeholder.css({
            width: this.placeholder[0].getBoundingClientRect().width + 'px',
            height: this.placeholder[0].getBoundingClientRect().height + 'px',
            position: 'relative',
            top: 0,
            left: 0
          });

          this._makeAncestorsOverflowVisible();

          // Set css on origin
          this.$el.css({
            position: 'absolute',
            'z-index': 1000,
            'will-change': 'left, top, width, height'
          });

          // Change from width or height attribute to css
          this.attrWidth = this.$el.attr('width');
          this.attrHeight = this.$el.attr('height');
          if (this.attrWidth) {
            this.$el.css('width', this.attrWidth + 'px');
            this.$el.removeAttr('width');
          }
          if (this.attrHeight) {
            this.$el.css('width', this.attrHeight + 'px');
            this.$el.removeAttr('height');
          }

          // Add overlay
          this.$overlay = $('<div id="materialbox-overlay"></div>').css({
            opacity: 0
          }).one('click', function () {
            if (_this19.doneAnimating) {
              _this19.close();
            }
          });

          // Put before in origin image to preserve z-index layering.
          this.$el.before(this.$overlay);

          // Set dimensions if needed
          var overlayOffset = this.$overlay[0].getBoundingClientRect();
          this.$overlay.css({
            width: this.windowWidth + 'px',
            height: this.windowHeight + 'px',
            left: -1 * overlayOffset.left + 'px',
            top: -1 * overlayOffset.top + 'px'
          });

          anim.remove(this.el);
          anim.remove(this.$overlay[0]);

          // Animate Overlay
          anim({
            targets: this.$overlay[0],
            opacity: 1,
            duration: this.options.inDuration,
            easing: 'easeOutQuad'
          });

          // Add and animate caption if it exists
          if (this.caption !== '') {
            if (this.$photocaption) {
              anim.remove(this.$photoCaption[0]);
            }
            this.$photoCaption = $('<div class="materialbox-caption"></div>');
            this.$photoCaption.text(this.caption);
            $('body').append(this.$photoCaption);
            this.$photoCaption.css({ display: 'inline' });

            anim({
              targets: this.$photoCaption[0],
              opacity: 1,
              duration: this.options.inDuration,
              easing: 'easeOutQuad'
            });
          }

          // Resize Image
          var ratio = 0;
          var widthPercent = this.originalWidth / this.windowWidth;
          var heightPercent = this.originalHeight / this.windowHeight;
          this.newWidth = 0;
          this.newHeight = 0;

          if (widthPercent > heightPercent) {
            ratio = this.originalHeight / this.originalWidth;
            this.newWidth = this.windowWidth * 0.9;
            this.newHeight = this.windowWidth * 0.9 * ratio;
          } else {
            ratio = this.originalWidth / this.originalHeight;
            this.newWidth = this.windowHeight * 0.9 * ratio;
            this.newHeight = this.windowHeight * 0.9;
          }

          this._animateImageIn();

          // Handle Exit triggers
          this._handleWindowScrollBound = this._handleWindowScroll.bind(this);
          this._handleWindowResizeBound = this._handleWindowResize.bind(this);
          this._handleWindowEscapeBound = this._handleWindowEscape.bind(this);

          window.addEventListener('scroll', this._handleWindowScrollBound);
          window.addEventListener('resize', this._handleWindowResizeBound);
          window.addEventListener('keyup', this._handleWindowEscapeBound);
        }

        /**
         * Close Materialbox
         */

      }, {
        key: "close",
        value: function close() {
          var _this20 = this;

          this._updateVars();
          this.doneAnimating = false;

          // onCloseStart callback
          if (typeof this.options.onCloseStart === 'function') {
            this.options.onCloseStart.call(this, this.el);
          }

          anim.remove(this.el);
          anim.remove(this.$overlay[0]);

          if (this.caption !== '') {
            anim.remove(this.$photoCaption[0]);
          }

          // disable exit handlers
          window.removeEventListener('scroll', this._handleWindowScrollBound);
          window.removeEventListener('resize', this._handleWindowResizeBound);
          window.removeEventListener('keyup', this._handleWindowEscapeBound);

          anim({
            targets: this.$overlay[0],
            opacity: 0,
            duration: this.options.outDuration,
            easing: 'easeOutQuad',
            complete: function () {
              _this20.overlayActive = false;
              _this20.$overlay.remove();
            }
          });

          this._animateImageOut();

          // Remove Caption + reset css settings on image
          if (this.caption !== '') {
            anim({
              targets: this.$photoCaption[0],
              opacity: 0,
              duration: this.options.outDuration,
              easing: 'easeOutQuad',
              complete: function () {
                _this20.$photoCaption.remove();
              }
            });
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Materialbox.__proto__ || Object.getPrototypeOf(Materialbox), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Materialbox;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Materialbox;
    }(Component);

    M.Materialbox = Materialbox;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Materialbox, 'materialbox', 'M_Materialbox');
    }
  })(cash, M.anime);
  (function ($) {

    var _defaults = {
      responsiveThreshold: 0 // breakpoint for swipeable
    };

    var Parallax = function (_Component5) {
      _inherits(Parallax, _Component5);

      function Parallax(el, options) {
        _classCallCheck(this, Parallax);

        var _this21 = _possibleConstructorReturn(this, (Parallax.__proto__ || Object.getPrototypeOf(Parallax)).call(this, Parallax, el, options));

        _this21.el.M_Parallax = _this21;

        /**
         * Options for the Parallax
         * @member Parallax#options
         * @prop {Number} responsiveThreshold
         */
        _this21.options = $.extend({}, Parallax.defaults, options);
        _this21._enabled = window.innerWidth > _this21.options.responsiveThreshold;

        _this21.$img = _this21.$el.find('img').first();
        _this21.$img.each(function () {
          var el = this;
          if (el.complete) $(el).trigger('load');
        });

        _this21._updateParallax();
        _this21._setupEventHandlers();
        _this21._setupStyles();

        Parallax._parallaxes.push(_this21);
        return _this21;
      }

      _createClass(Parallax, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          Parallax._parallaxes.splice(Parallax._parallaxes.indexOf(this), 1);
          this.$img[0].style.transform = '';
          this._removeEventHandlers();

          this.$el[0].M_Parallax = undefined;
        }
      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleImageLoadBound = this._handleImageLoad.bind(this);
          this.$img[0].addEventListener('load', this._handleImageLoadBound);

          if (Parallax._parallaxes.length === 0) {
            Parallax._handleScrollThrottled = M.throttle(Parallax._handleScroll, 5);
            window.addEventListener('scroll', Parallax._handleScrollThrottled);

            Parallax._handleWindowResizeThrottled = M.throttle(Parallax._handleWindowResize, 5);
            window.addEventListener('resize', Parallax._handleWindowResizeThrottled);
          }
        }
      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.$img[0].removeEventListener('load', this._handleImageLoadBound);

          if (Parallax._parallaxes.length === 0) {
            window.removeEventListener('scroll', Parallax._handleScrollThrottled);
            window.removeEventListener('resize', Parallax._handleWindowResizeThrottled);
          }
        }
      }, {
        key: "_setupStyles",
        value: function _setupStyles() {
          this.$img[0].style.opacity = 1;
        }
      }, {
        key: "_handleImageLoad",
        value: function _handleImageLoad() {
          this._updateParallax();
        }
      }, {
        key: "_updateParallax",
        value: function _updateParallax() {
          var containerHeight = this.$el.height() > 0 ? this.el.parentNode.offsetHeight : 500;
          var imgHeight = this.$img[0].offsetHeight;
          var parallaxDist = imgHeight - containerHeight;
          var bottom = this.$el.offset().top + containerHeight;
          var top = this.$el.offset().top;
          var scrollTop = M.getDocumentScrollTop();
          var windowHeight = window.innerHeight;
          var windowBottom = scrollTop + windowHeight;
          var percentScrolled = (windowBottom - top) / (containerHeight + windowHeight);
          var parallax = parallaxDist * percentScrolled;

          if (!this._enabled) {
            this.$img[0].style.transform = '';
          } else if (bottom > scrollTop && top < scrollTop + windowHeight) {
            this.$img[0].style.transform = "translate3D(-50%, " + parallax + "px, 0)";
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Parallax.__proto__ || Object.getPrototypeOf(Parallax), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Parallax;
        }
      }, {
        key: "_handleScroll",
        value: function _handleScroll() {
          for (var i = 0; i < Parallax._parallaxes.length; i++) {
            var parallaxInstance = Parallax._parallaxes[i];
            parallaxInstance._updateParallax.call(parallaxInstance);
          }
        }
      }, {
        key: "_handleWindowResize",
        value: function _handleWindowResize() {
          for (var i = 0; i < Parallax._parallaxes.length; i++) {
            var parallaxInstance = Parallax._parallaxes[i];
            parallaxInstance._enabled = window.innerWidth > parallaxInstance.options.responsiveThreshold;
          }
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Parallax;
    }(Component);

    /**
     * @static
     * @memberof Parallax
     */


    Parallax._parallaxes = [];

    M.Parallax = Parallax;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Parallax, 'parallax', 'M_Parallax');
    }
  })(cash);
  (function ($, anim) {

    var _defaults = {
      duration: 300,
      onShow: null,
      swipeable: false,
      responsiveThreshold: Infinity // breakpoint for swipeable
    };

    /**
     * @class
     *
     */

    var Tabs = function (_Component6) {
      _inherits(Tabs, _Component6);

      /**
       * Construct Tabs instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Tabs(el, options) {
        _classCallCheck(this, Tabs);

        var _this22 = _possibleConstructorReturn(this, (Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call(this, Tabs, el, options));

        _this22.el.M_Tabs = _this22;

        /**
         * Options for the Tabs
         * @member Tabs#options
         * @prop {Number} duration
         * @prop {Function} onShow
         * @prop {Boolean} swipeable
         * @prop {Number} responsiveThreshold
         */
        _this22.options = $.extend({}, Tabs.defaults, options);

        // Setup
        _this22.$tabLinks = _this22.$el.children('li.tab').children('a');
        _this22.index = 0;
        _this22._setupActiveTabLink();

        // Setup tabs content
        if (_this22.options.swipeable) {
          _this22._setupSwipeableTabs();
        } else {
          _this22._setupNormalTabs();
        }

        // Setup tabs indicator after content to ensure accurate widths
        _this22._setTabsAndTabWidth();
        _this22._createIndicator();

        _this22._setupEventHandlers();
        return _this22;
      }

      _createClass(Tabs, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this._indicator.parentNode.removeChild(this._indicator);

          if (this.options.swipeable) {
            this._teardownSwipeableTabs();
          } else {
            this._teardownNormalTabs();
          }

          this.$el[0].M_Tabs = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleWindowResizeBound = this._handleWindowResize.bind(this);
          window.addEventListener('resize', this._handleWindowResizeBound);

          this._handleTabClickBound = this._handleTabClick.bind(this);
          this.el.addEventListener('click', this._handleTabClickBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          window.removeEventListener('resize', this._handleWindowResizeBound);
          this.el.removeEventListener('click', this._handleTabClickBound);
        }

        /**
         * Handle window Resize
         */

      }, {
        key: "_handleWindowResize",
        value: function _handleWindowResize() {
          this._setTabsAndTabWidth();

          if (this.tabWidth !== 0 && this.tabsWidth !== 0) {
            this._indicator.style.left = this._calcLeftPos(this.$activeTabLink) + 'px';
            this._indicator.style.right = this._calcRightPos(this.$activeTabLink) + 'px';
          }
        }

        /**
         * Handle tab click
         * @param {Event} e
         */

      }, {
        key: "_handleTabClick",
        value: function _handleTabClick(e) {
          var _this23 = this;

          var tab = $(e.target).closest('li.tab');
          var tabLink = $(e.target).closest('a');

          // Handle click on tab link only
          if (!tabLink.length || !tabLink.parent().hasClass('tab')) {
            return;
          }

          if (tab.hasClass('disabled')) {
            e.preventDefault();
            return;
          }

          // Act as regular link if target attribute is specified.
          if (!!tabLink.attr('target')) {
            return;
          }

          // Make the old tab inactive.
          this.$activeTabLink.removeClass('active');
          var $oldContent = this.$content;

          // Update the variables with the new link and content
          this.$activeTabLink = tabLink;
          this.$content = $(M.escapeHash(tabLink[0].hash));
          this.$tabLinks = this.$el.children('li.tab').children('a');

          // Make the tab active.
          this.$activeTabLink.addClass('active');
          var prevIndex = this.index;
          this.index = Math.max(this.$tabLinks.index(tabLink), 0);

          // Swap content
          if (this.options.swipeable) {
            if (this._tabsCarousel) {
              this._tabsCarousel.set(this.index, function () {
                if (typeof _this23.options.onShow === 'function') {
                  _this23.options.onShow.call(_this23, _this23.$content[0]);
                }
              });
            }
          } else {
            if (this.$content.length) {
              this.$content[0].style.display = 'block';
              this.$content.addClass('active');
              if (typeof this.options.onShow === 'function') {
                this.options.onShow.call(this, this.$content[0]);
              }

              if ($oldContent.length && !$oldContent.is(this.$content)) {
                $oldContent[0].style.display = 'none';
                $oldContent.removeClass('active');
              }
            }
          }

          // Update widths after content is swapped (scrollbar bugfix)
          this._setTabsAndTabWidth();

          // Update indicator
          this._animateIndicator(prevIndex);

          // Prevent the anchor's default click action
          e.preventDefault();
        }

        /**
         * Generate elements for tab indicator.
         */

      }, {
        key: "_createIndicator",
        value: function _createIndicator() {
          var _this24 = this;

          var indicator = document.createElement('li');
          indicator.classList.add('indicator');

          this.el.appendChild(indicator);
          this._indicator = indicator;

          setTimeout(function () {
            _this24._indicator.style.left = _this24._calcLeftPos(_this24.$activeTabLink) + 'px';
            _this24._indicator.style.right = _this24._calcRightPos(_this24.$activeTabLink) + 'px';
          }, 0);
        }

        /**
         * Setup first active tab link.
         */

      }, {
        key: "_setupActiveTabLink",
        value: function _setupActiveTabLink() {
          // If the location.hash matches one of the links, use that as the active tab.
          this.$activeTabLink = $(this.$tabLinks.filter('[href="' + location.hash + '"]'));

          // If no match is found, use the first link or any with class 'active' as the initial active tab.
          if (this.$activeTabLink.length === 0) {
            this.$activeTabLink = this.$el.children('li.tab').children('a.active').first();
          }
          if (this.$activeTabLink.length === 0) {
            this.$activeTabLink = this.$el.children('li.tab').children('a').first();
          }

          this.$tabLinks.removeClass('active');
          this.$activeTabLink[0].classList.add('active');

          this.index = Math.max(this.$tabLinks.index(this.$activeTabLink), 0);

          if (this.$activeTabLink.length) {
            this.$content = $(M.escapeHash(this.$activeTabLink[0].hash));
            this.$content.addClass('active');
          }
        }

        /**
         * Setup swipeable tabs
         */

      }, {
        key: "_setupSwipeableTabs",
        value: function _setupSwipeableTabs() {
          var _this25 = this;

          // Change swipeable according to responsive threshold
          if (window.innerWidth > this.options.responsiveThreshold) {
            this.options.swipeable = false;
          }

          var $tabsContent = $();
          this.$tabLinks.each(function (link) {
            var $currContent = $(M.escapeHash(link.hash));
            $currContent.addClass('carousel-item');
            $tabsContent = $tabsContent.add($currContent);
          });

          var $tabsWrapper = $('<div class="tabs-content carousel carousel-slider"></div>');
          $tabsContent.first().before($tabsWrapper);
          $tabsWrapper.append($tabsContent);
          $tabsContent[0].style.display = '';

          // Keep active tab index to set initial carousel slide
          var activeTabIndex = this.$activeTabLink.closest('.tab').index();

          this._tabsCarousel = M.Carousel.init($tabsWrapper[0], {
            fullWidth: true,
            noWrap: true,
            onCycleTo: function (item) {
              var prevIndex = _this25.index;
              _this25.index = $(item).index();
              _this25.$activeTabLink.removeClass('active');
              _this25.$activeTabLink = _this25.$tabLinks.eq(_this25.index);
              _this25.$activeTabLink.addClass('active');
              _this25._animateIndicator(prevIndex);
              if (typeof _this25.options.onShow === 'function') {
                _this25.options.onShow.call(_this25, _this25.$content[0]);
              }
            }
          });

          // Set initial carousel slide to active tab
          this._tabsCarousel.set(activeTabIndex);
        }

        /**
         * Teardown normal tabs.
         */

      }, {
        key: "_teardownSwipeableTabs",
        value: function _teardownSwipeableTabs() {
          var $tabsWrapper = this._tabsCarousel.$el;
          this._tabsCarousel.destroy();

          // Unwrap
          $tabsWrapper.after($tabsWrapper.children());
          $tabsWrapper.remove();
        }

        /**
         * Setup normal tabs.
         */

      }, {
        key: "_setupNormalTabs",
        value: function _setupNormalTabs() {
          // Hide Tabs Content
          this.$tabLinks.not(this.$activeTabLink).each(function (link) {
            if (!!link.hash) {
              var $currContent = $(M.escapeHash(link.hash));
              if ($currContent.length) {
                $currContent[0].style.display = 'none';
              }
            }
          });
        }

        /**
         * Teardown normal tabs.
         */

      }, {
        key: "_teardownNormalTabs",
        value: function _teardownNormalTabs() {
          // show Tabs Content
          this.$tabLinks.each(function (link) {
            if (!!link.hash) {
              var $currContent = $(M.escapeHash(link.hash));
              if ($currContent.length) {
                $currContent[0].style.display = '';
              }
            }
          });
        }

        /**
         * set tabs and tab width
         */

      }, {
        key: "_setTabsAndTabWidth",
        value: function _setTabsAndTabWidth() {
          this.tabsWidth = this.$el.width();
          this.tabWidth = Math.max(this.tabsWidth, this.el.scrollWidth) / this.$tabLinks.length;
        }

        /**
         * Finds right attribute for indicator based on active tab.
         * @param {cash} el
         */

      }, {
        key: "_calcRightPos",
        value: function _calcRightPos(el) {
          return Math.ceil(this.tabsWidth - el.position().left - el[0].getBoundingClientRect().width);
        }

        /**
         * Finds left attribute for indicator based on active tab.
         * @param {cash} el
         */

      }, {
        key: "_calcLeftPos",
        value: function _calcLeftPos(el) {
          return Math.floor(el.position().left);
        }
      }, {
        key: "updateTabIndicator",
        value: function updateTabIndicator() {
          this._setTabsAndTabWidth();
          this._animateIndicator(this.index);
        }

        /**
         * Animates Indicator to active tab.
         * @param {Number} prevIndex
         */

      }, {
        key: "_animateIndicator",
        value: function _animateIndicator(prevIndex) {
          var leftDelay = 0,
              rightDelay = 0;

          if (this.index - prevIndex >= 0) {
            leftDelay = 90;
          } else {
            rightDelay = 90;
          }

          // Animate
          var animOptions = {
            targets: this._indicator,
            left: {
              value: this._calcLeftPos(this.$activeTabLink),
              delay: leftDelay
            },
            right: {
              value: this._calcRightPos(this.$activeTabLink),
              delay: rightDelay
            },
            duration: this.options.duration,
            easing: 'easeOutQuad'
          };
          anim.remove(this._indicator);
          anim(animOptions);
        }

        /**
         * Select tab.
         * @param {String} tabId
         */

      }, {
        key: "select",
        value: function select(tabId) {
          var tab = this.$tabLinks.filter('[href="#' + tabId + '"]');
          if (tab.length) {
            tab.trigger('click');
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Tabs.__proto__ || Object.getPrototypeOf(Tabs), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Tabs;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Tabs;
    }(Component);

    window.M.Tabs = Tabs;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Tabs, 'tabs', 'M_Tabs');
    }
  })(cash, M.anime);
  (function ($, anim) {

    var _defaults = {
      exitDelay: 200,
      enterDelay: 0,
      html: null,
      margin: 5,
      inDuration: 250,
      outDuration: 200,
      position: 'bottom',
      transitionMovement: 10
    };

    /**
     * @class
     *
     */

    var Tooltip = function (_Component7) {
      _inherits(Tooltip, _Component7);

      /**
       * Construct Tooltip instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Tooltip(el, options) {
        _classCallCheck(this, Tooltip);

        var _this26 = _possibleConstructorReturn(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, Tooltip, el, options));

        _this26.el.M_Tooltip = _this26;
        _this26.options = $.extend({}, Tooltip.defaults, options);

        _this26.isOpen = false;
        _this26.isHovered = false;
        _this26.isFocused = false;
        _this26._appendTooltipEl();
        _this26._setupEventHandlers();
        return _this26;
      }

      _createClass(Tooltip, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          $(this.tooltipEl).remove();
          this._removeEventHandlers();
          this.el.M_Tooltip = undefined;
        }
      }, {
        key: "_appendTooltipEl",
        value: function _appendTooltipEl() {
          var tooltipEl = document.createElement('div');
          tooltipEl.classList.add('material-tooltip');
          this.tooltipEl = tooltipEl;

          var tooltipContentEl = document.createElement('div');
          tooltipContentEl.classList.add('tooltip-content');
          tooltipContentEl.innerHTML = this.options.html;
          tooltipEl.appendChild(tooltipContentEl);
          document.body.appendChild(tooltipEl);
        }
      }, {
        key: "_updateTooltipContent",
        value: function _updateTooltipContent() {
          this.tooltipEl.querySelector('.tooltip-content').innerHTML = this.options.html;
        }
      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleMouseEnterBound = this._handleMouseEnter.bind(this);
          this._handleMouseLeaveBound = this._handleMouseLeave.bind(this);
          this._handleFocusBound = this._handleFocus.bind(this);
          this._handleBlurBound = this._handleBlur.bind(this);
          this.el.addEventListener('mouseenter', this._handleMouseEnterBound);
          this.el.addEventListener('mouseleave', this._handleMouseLeaveBound);
          this.el.addEventListener('focus', this._handleFocusBound, true);
          this.el.addEventListener('blur', this._handleBlurBound, true);
        }
      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('mouseenter', this._handleMouseEnterBound);
          this.el.removeEventListener('mouseleave', this._handleMouseLeaveBound);
          this.el.removeEventListener('focus', this._handleFocusBound, true);
          this.el.removeEventListener('blur', this._handleBlurBound, true);
        }
      }, {
        key: "open",
        value: function open(isManual) {
          if (this.isOpen) {
            return;
          }
          isManual = isManual === undefined ? true : undefined; // Default value true
          this.isOpen = true;
          // Update tooltip content with HTML attribute options
          this.options = $.extend({}, this.options, this._getAttributeOptions());
          this._updateTooltipContent();
          this._setEnterDelayTimeout(isManual);
        }
      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen) {
            return;
          }

          this.isHovered = false;
          this.isFocused = false;
          this.isOpen = false;
          this._setExitDelayTimeout();
        }

        /**
         * Create timeout which delays when the tooltip closes
         */

      }, {
        key: "_setExitDelayTimeout",
        value: function _setExitDelayTimeout() {
          var _this27 = this;

          clearTimeout(this._exitDelayTimeout);

          this._exitDelayTimeout = setTimeout(function () {
            if (_this27.isHovered || _this27.isFocused) {
              return;
            }

            _this27._animateOut();
          }, this.options.exitDelay);
        }

        /**
         * Create timeout which delays when the toast closes
         */

      }, {
        key: "_setEnterDelayTimeout",
        value: function _setEnterDelayTimeout(isManual) {
          var _this28 = this;

          clearTimeout(this._enterDelayTimeout);

          this._enterDelayTimeout = setTimeout(function () {
            if (!_this28.isHovered && !_this28.isFocused && !isManual) {
              return;
            }

            _this28._animateIn();
          }, this.options.enterDelay);
        }
      }, {
        key: "_positionTooltip",
        value: function _positionTooltip() {
          var origin = this.el,
              tooltip = this.tooltipEl,
              originHeight = origin.offsetHeight,
              originWidth = origin.offsetWidth,
              tooltipHeight = tooltip.offsetHeight,
              tooltipWidth = tooltip.offsetWidth,
              newCoordinates = void 0,
              margin = this.options.margin,
              targetTop = void 0,
              targetLeft = void 0;

          this.xMovement = 0, this.yMovement = 0;

          targetTop = origin.getBoundingClientRect().top + M.getDocumentScrollTop();
          targetLeft = origin.getBoundingClientRect().left + M.getDocumentScrollLeft();

          if (this.options.position === 'top') {
            targetTop += -tooltipHeight - margin;
            targetLeft += originWidth / 2 - tooltipWidth / 2;
            this.yMovement = -this.options.transitionMovement;
          } else if (this.options.position === 'right') {
            targetTop += originHeight / 2 - tooltipHeight / 2;
            targetLeft += originWidth + margin;
            this.xMovement = this.options.transitionMovement;
          } else if (this.options.position === 'left') {
            targetTop += originHeight / 2 - tooltipHeight / 2;
            targetLeft += -tooltipWidth - margin;
            this.xMovement = -this.options.transitionMovement;
          } else {
            targetTop += originHeight + margin;
            targetLeft += originWidth / 2 - tooltipWidth / 2;
            this.yMovement = this.options.transitionMovement;
          }

          newCoordinates = this._repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);
          $(tooltip).css({
            top: newCoordinates.y + 'px',
            left: newCoordinates.x + 'px'
          });
        }
      }, {
        key: "_repositionWithinScreen",
        value: function _repositionWithinScreen(x, y, width, height) {
          var scrollLeft = M.getDocumentScrollLeft();
          var scrollTop = M.getDocumentScrollTop();
          var newX = x - scrollLeft;
          var newY = y - scrollTop;

          var bounding = {
            left: newX,
            top: newY,
            width: width,
            height: height
          };

          var offset = this.options.margin + this.options.transitionMovement;
          var edges = M.checkWithinContainer(document.body, bounding, offset);

          if (edges.left) {
            newX = offset;
          } else if (edges.right) {
            newX -= newX + width - window.innerWidth;
          }

          if (edges.top) {
            newY = offset;
          } else if (edges.bottom) {
            newY -= newY + height - window.innerHeight;
          }

          return {
            x: newX + scrollLeft,
            y: newY + scrollTop
          };
        }
      }, {
        key: "_animateIn",
        value: function _animateIn() {
          this._positionTooltip();
          this.tooltipEl.style.visibility = 'visible';
          anim.remove(this.tooltipEl);
          anim({
            targets: this.tooltipEl,
            opacity: 1,
            translateX: this.xMovement,
            translateY: this.yMovement,
            duration: this.options.inDuration,
            easing: 'easeOutCubic'
          });
        }
      }, {
        key: "_animateOut",
        value: function _animateOut() {
          anim.remove(this.tooltipEl);
          anim({
            targets: this.tooltipEl,
            opacity: 0,
            translateX: 0,
            translateY: 0,
            duration: this.options.outDuration,
            easing: 'easeOutCubic'
          });
        }
      }, {
        key: "_handleMouseEnter",
        value: function _handleMouseEnter() {
          this.isHovered = true;
          this.isFocused = false; // Allows close of tooltip when opened by focus.
          this.open(false);
        }
      }, {
        key: "_handleMouseLeave",
        value: function _handleMouseLeave() {
          this.isHovered = false;
          this.isFocused = false; // Allows close of tooltip when opened by focus.
          this.close();
        }
      }, {
        key: "_handleFocus",
        value: function _handleFocus() {
          if (M.tabPressed) {
            this.isFocused = true;
            this.open(false);
          }
        }
      }, {
        key: "_handleBlur",
        value: function _handleBlur() {
          this.isFocused = false;
          this.close();
        }
      }, {
        key: "_getAttributeOptions",
        value: function _getAttributeOptions() {
          var attributeOptions = {};
          var tooltipTextOption = this.el.getAttribute('data-tooltip');
          var positionOption = this.el.getAttribute('data-position');

          if (tooltipTextOption) {
            attributeOptions.html = tooltipTextOption;
          }

          if (positionOption) {
            attributeOptions.position = positionOption;
          }
          return attributeOptions;
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Tooltip.__proto__ || Object.getPrototypeOf(Tooltip), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Tooltip;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Tooltip;
    }(Component);

    M.Tooltip = Tooltip;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Tooltip, 'tooltip', 'M_Tooltip');
    }
  })(cash, M.anime);
  (function (window) {

    var Waves = Waves || {};
    var $$ = document.querySelectorAll.bind(document);

    // Find exact position of element
    function isWindow(obj) {
      return obj !== null && obj === obj.window;
    }

    function getWindow(elem) {
      return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    function offset(elem) {
      var docElem,
          win,
          box = { top: 0, left: 0 },
          doc = elem && elem.ownerDocument;

      docElem = doc.documentElement;

      if (typeof elem.getBoundingClientRect !== typeof undefined) {
        box = elem.getBoundingClientRect();
      }
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    }

    function convertStyle(obj) {
      var style = '';

      for (var a in obj) {
        if (obj.hasOwnProperty(a)) {
          style += a + ':' + obj[a] + ';';
        }
      }

      return style;
    }

    var Effect = {

      // Effect delay
      duration: 750,

      show: function (e, element) {

        // Disable right click
        if (e.button === 2) {
          return false;
        }

        var el = element || this;

        // Create ripple
        var ripple = document.createElement('div');
        ripple.className = 'waves-ripple';
        el.appendChild(ripple);

        // Get click coordinate and element witdh
        var pos = offset(el);
        var relativeY = e.pageY - pos.top;
        var relativeX = e.pageX - pos.left;
        var scale = 'scale(' + el.clientWidth / 100 * 10 + ')';

        // Support for touch devices
        if ('touches' in e) {
          relativeY = e.touches[0].pageY - pos.top;
          relativeX = e.touches[0].pageX - pos.left;
        }

        // Attach data to element
        ripple.setAttribute('data-hold', Date.now());
        ripple.setAttribute('data-scale', scale);
        ripple.setAttribute('data-x', relativeX);
        ripple.setAttribute('data-y', relativeY);

        // Set ripple position
        var rippleStyle = {
          'top': relativeY + 'px',
          'left': relativeX + 'px'
        };

        ripple.className = ripple.className + ' waves-notransition';
        ripple.setAttribute('style', convertStyle(rippleStyle));
        ripple.className = ripple.className.replace('waves-notransition', '');

        // Scale the ripple
        rippleStyle['-webkit-transform'] = scale;
        rippleStyle['-moz-transform'] = scale;
        rippleStyle['-ms-transform'] = scale;
        rippleStyle['-o-transform'] = scale;
        rippleStyle.transform = scale;
        rippleStyle.opacity = '1';

        rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';
        rippleStyle['-moz-transition-duration'] = Effect.duration + 'ms';
        rippleStyle['-o-transition-duration'] = Effect.duration + 'ms';
        rippleStyle['transition-duration'] = Effect.duration + 'ms';

        rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
        rippleStyle['-moz-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
        rippleStyle['-o-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';
        rippleStyle['transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';

        ripple.setAttribute('style', convertStyle(rippleStyle));
      },

      hide: function (e) {
        TouchHandler.touchup(e);

        var el = this;
        var width = el.clientWidth * 1.4;

        // Get first ripple
        var ripple = null;
        var ripples = el.getElementsByClassName('waves-ripple');
        if (ripples.length > 0) {
          ripple = ripples[ripples.length - 1];
        } else {
          return false;
        }

        var relativeX = ripple.getAttribute('data-x');
        var relativeY = ripple.getAttribute('data-y');
        var scale = ripple.getAttribute('data-scale');

        // Get delay beetween mousedown and mouse leave
        var diff = Date.now() - Number(ripple.getAttribute('data-hold'));
        var delay = 350 - diff;

        if (delay < 0) {
          delay = 0;
        }

        // Fade out ripple after delay
        setTimeout(function () {
          var style = {
            'top': relativeY + 'px',
            'left': relativeX + 'px',
            'opacity': '0',

            // Duration
            '-webkit-transition-duration': Effect.duration + 'ms',
            '-moz-transition-duration': Effect.duration + 'ms',
            '-o-transition-duration': Effect.duration + 'ms',
            'transition-duration': Effect.duration + 'ms',
            '-webkit-transform': scale,
            '-moz-transform': scale,
            '-ms-transform': scale,
            '-o-transform': scale,
            'transform': scale
          };

          ripple.setAttribute('style', convertStyle(style));

          setTimeout(function () {
            try {
              el.removeChild(ripple);
            } catch (e) {
              return false;
            }
          }, Effect.duration);
        }, delay);
      },

      // Little hack to make <input> can perform waves effect
      wrapInput: function (elements) {
        for (var a = 0; a < elements.length; a++) {
          var el = elements[a];

          if (el.tagName.toLowerCase() === 'input') {
            var parent = el.parentNode;

            // If input already have parent just pass through
            if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {
              continue;
            }

            // Put element class and style to the specified parent
            var wrapper = document.createElement('i');
            wrapper.className = el.className + ' waves-input-wrapper';

            var elementStyle = el.getAttribute('style');

            if (!elementStyle) {
              elementStyle = '';
            }

            wrapper.setAttribute('style', elementStyle);

            el.className = 'waves-button-input';
            el.removeAttribute('style');

            // Put element as child
            parent.replaceChild(wrapper, el);
            wrapper.appendChild(el);
          }
        }
      }
    };

    /**
     * Disable mousedown event for 500ms during and after touch
     */
    var TouchHandler = {
      /* uses an integer rather than bool so there's no issues with
       * needing to clear timeouts if another touch event occurred
       * within the 500ms. Cannot mouseup between touchstart and
       * touchend, nor in the 500ms after touchend. */
      touches: 0,
      allowEvent: function (e) {
        var allow = true;

        if (e.type === 'touchstart') {
          TouchHandler.touches += 1; //push
        } else if (e.type === 'touchend' || e.type === 'touchcancel') {
          setTimeout(function () {
            if (TouchHandler.touches > 0) {
              TouchHandler.touches -= 1; //pop after 500ms
            }
          }, 500);
        } else if (e.type === 'mousedown' && TouchHandler.touches > 0) {
          allow = false;
        }

        return allow;
      },
      touchup: function (e) {
        TouchHandler.allowEvent(e);
      }
    };

    /**
     * Delegated click handler for .waves-effect element.
     * returns null when .waves-effect element not in "click tree"
     */
    function getWavesEffectElement(e) {
      if (TouchHandler.allowEvent(e) === false) {
        return null;
      }

      var element = null;
      var target = e.target || e.srcElement;

      while (target.parentNode !== null) {
        if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {
          element = target;
          break;
        }
        target = target.parentNode;
      }
      return element;
    }

    /**
     * Bubble the click and show effect if .waves-effect elem was found
     */
    function showEffect(e) {
      var element = getWavesEffectElement(e);

      if (element !== null) {
        Effect.show(e, element);

        if ('ontouchstart' in window) {
          element.addEventListener('touchend', Effect.hide, false);
          element.addEventListener('touchcancel', Effect.hide, false);
        }

        element.addEventListener('mouseup', Effect.hide, false);
        element.addEventListener('mouseleave', Effect.hide, false);
        element.addEventListener('dragend', Effect.hide, false);
      }
    }

    Waves.displayEffect = function (options) {
      options = options || {};

      if ('duration' in options) {
        Effect.duration = options.duration;
      }

      //Wrap input inside <i> tag
      Effect.wrapInput($$('.waves-effect'));

      if ('ontouchstart' in window) {
        document.body.addEventListener('touchstart', showEffect, false);
      }

      document.body.addEventListener('mousedown', showEffect, false);
    };

    /**
     * Attach Waves to an input element (or any element which doesn't
     * bubble mouseup/mousedown events).
     *   Intended to be used with dynamically loaded forms/inputs, or
     * where the user doesn't want a delegated click handler.
     */
    Waves.attach = function (element) {
      //FUTURE: automatically add waves classes and allow users
      // to specify them with an options param? Eg. light/classic/button
      if (element.tagName.toLowerCase() === 'input') {
        Effect.wrapInput([element]);
        element = element.parentNode;
      }

      if ('ontouchstart' in window) {
        element.addEventListener('touchstart', showEffect, false);
      }

      element.addEventListener('mousedown', showEffect, false);
    };

    window.Waves = Waves;

    document.addEventListener('DOMContentLoaded', function () {
      Waves.displayEffect();
    }, false);
  })(window);
  (function ($, anim) {

    var _defaults = {
      html: '',
      displayLength: 4000,
      inDuration: 300,
      outDuration: 375,
      classes: '',
      completeCallback: null,
      activationPercent: 0.8
    };

    var Toast = function () {
      function Toast(options) {
        _classCallCheck(this, Toast);

        /**
         * Options for the toast
         * @member Toast#options
         */
        this.options = $.extend({}, Toast.defaults, options);
        this.message = this.options.html;

        /**
         * Describes current pan state toast
         * @type {Boolean}
         */
        this.panning = false;

        /**
         * Time remaining until toast is removed
         */
        this.timeRemaining = this.options.displayLength;

        if (Toast._toasts.length === 0) {
          Toast._createContainer();
        }

        // Create new toast
        Toast._toasts.push(this);
        var toastElement = this._createToast();
        toastElement.M_Toast = this;
        this.el = toastElement;
        this.$el = $(toastElement);
        this._animateIn();
        this._setTimer();
      }

      _createClass(Toast, [{
        key: "_createToast",


        /**
         * Create toast and append it to toast container
         */
        value: function _createToast() {
          var toast = document.createElement('div');
          toast.classList.add('toast');

          // Add custom classes onto toast
          if (!!this.options.classes.length) {
            $(toast).addClass(this.options.classes);
          }

          // Set content
          if (typeof HTMLElement === 'object' ? this.message instanceof HTMLElement : this.message && typeof this.message === 'object' && this.message !== null && this.message.nodeType === 1 && typeof this.message.nodeName === 'string') {
            toast.appendChild(this.message);

            // Check if it is jQuery object
          } else if (!!this.message.jquery) {
            $(toast).append(this.message[0]);

            // Insert as html;
          } else {
            toast.innerHTML = this.message;
          }

          // Append toasft
          Toast._container.appendChild(toast);
          return toast;
        }

        /**
         * Animate in toast
         */

      }, {
        key: "_animateIn",
        value: function _animateIn() {
          // Animate toast in
          anim({
            targets: this.el,
            top: 0,
            opacity: 1,
            duration: this.options.inDuration,
            easing: 'easeOutCubic'
          });
        }

        /**
         * Create setInterval which automatically removes toast when timeRemaining >= 0
         * has been reached
         */

      }, {
        key: "_setTimer",
        value: function _setTimer() {
          var _this29 = this;

          if (this.timeRemaining !== Infinity) {
            this.counterInterval = setInterval(function () {
              // If toast is not being dragged, decrease its time remaining
              if (!_this29.panning) {
                _this29.timeRemaining -= 20;
              }

              // Animate toast out
              if (_this29.timeRemaining <= 0) {
                _this29.dismiss();
              }
            }, 20);
          }
        }

        /**
         * Dismiss toast with animation
         */

      }, {
        key: "dismiss",
        value: function dismiss() {
          var _this30 = this;

          window.clearInterval(this.counterInterval);
          var activationDistance = this.el.offsetWidth * this.options.activationPercent;

          if (this.wasSwiped) {
            this.el.style.transition = 'transform .05s, opacity .05s';
            this.el.style.transform = "translateX(" + activationDistance + "px)";
            this.el.style.opacity = 0;
          }

          anim({
            targets: this.el,
            opacity: 0,
            marginTop: -40,
            duration: this.options.outDuration,
            easing: 'easeOutExpo',
            complete: function () {
              // Call the optional callback
              if (typeof _this30.options.completeCallback === 'function') {
                _this30.options.completeCallback();
              }
              // Remove toast from DOM
              _this30.$el.remove();
              Toast._toasts.splice(Toast._toasts.indexOf(_this30), 1);
              if (Toast._toasts.length === 0) {
                Toast._removeContainer();
              }
            }
          });
        }
      }], [{
        key: "getInstance",


        /**
         * Get Instance
         */
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Toast;
        }

        /**
         * Append toast container and add event handlers
         */

      }, {
        key: "_createContainer",
        value: function _createContainer() {
          var container = document.createElement('div');
          container.setAttribute('id', 'toast-container');

          // Add event handler
          container.addEventListener('touchstart', Toast._onDragStart);
          container.addEventListener('touchmove', Toast._onDragMove);
          container.addEventListener('touchend', Toast._onDragEnd);

          container.addEventListener('mousedown', Toast._onDragStart);
          document.addEventListener('mousemove', Toast._onDragMove);
          document.addEventListener('mouseup', Toast._onDragEnd);

          document.body.appendChild(container);
          Toast._container = container;
        }

        /**
         * Remove toast container and event handlers
         */

      }, {
        key: "_removeContainer",
        value: function _removeContainer() {
          // Add event handler
          document.removeEventListener('mousemove', Toast._onDragMove);
          document.removeEventListener('mouseup', Toast._onDragEnd);

          $(Toast._container).remove();
          Toast._container = null;
        }

        /**
         * Begin drag handler
         * @param {Event} e
         */

      }, {
        key: "_onDragStart",
        value: function _onDragStart(e) {
          if (e.target && $(e.target).closest('.toast').length) {
            var $toast = $(e.target).closest('.toast');
            var toast = $toast[0].M_Toast;
            toast.panning = true;
            Toast._draggedToast = toast;
            toast.el.classList.add('panning');
            toast.el.style.transition = '';
            toast.startingXPos = Toast._xPos(e);
            toast.time = Date.now();
            toast.xPos = Toast._xPos(e);
          }
        }

        /**
         * Drag move handler
         * @param {Event} e
         */

      }, {
        key: "_onDragMove",
        value: function _onDragMove(e) {
          if (!!Toast._draggedToast) {
            e.preventDefault();
            var toast = Toast._draggedToast;
            toast.deltaX = Math.abs(toast.xPos - Toast._xPos(e));
            toast.xPos = Toast._xPos(e);
            toast.velocityX = toast.deltaX / (Date.now() - toast.time);
            toast.time = Date.now();

            var totalDeltaX = toast.xPos - toast.startingXPos;
            var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;
            toast.el.style.transform = "translateX(" + totalDeltaX + "px)";
            toast.el.style.opacity = 1 - Math.abs(totalDeltaX / activationDistance);
          }
        }

        /**
         * End drag handler
         */

      }, {
        key: "_onDragEnd",
        value: function _onDragEnd() {
          if (!!Toast._draggedToast) {
            var toast = Toast._draggedToast;
            toast.panning = false;
            toast.el.classList.remove('panning');

            var totalDeltaX = toast.xPos - toast.startingXPos;
            var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;
            var shouldBeDismissed = Math.abs(totalDeltaX) > activationDistance || toast.velocityX > 1;

            // Remove toast
            if (shouldBeDismissed) {
              toast.wasSwiped = true;
              toast.dismiss();

              // Animate toast back to original position
            } else {
              toast.el.style.transition = 'transform .2s, opacity .2s';
              toast.el.style.transform = '';
              toast.el.style.opacity = '';
            }
            Toast._draggedToast = null;
          }
        }

        /**
         * Get x position of mouse or touch event
         * @param {Event} e
         */

      }, {
        key: "_xPos",
        value: function _xPos(e) {
          if (e.targetTouches && e.targetTouches.length >= 1) {
            return e.targetTouches[0].clientX;
          }
          // mouse event
          return e.clientX;
        }

        /**
         * Remove all toasts
         */

      }, {
        key: "dismissAll",
        value: function dismissAll() {
          for (var toastIndex in Toast._toasts) {
            Toast._toasts[toastIndex].dismiss();
          }
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Toast;
    }();

    /**
     * @static
     * @memberof Toast
     * @type {Array.<Toast>}
     */


    Toast._toasts = [];

    /**
     * @static
     * @memberof Toast
     */
    Toast._container = null;

    /**
     * @static
     * @memberof Toast
     * @type {Toast}
     */
    Toast._draggedToast = null;

    M.Toast = Toast;
    M.toast = function (options) {
      return new Toast(options);
    };
  })(cash, M.anime);
  (function ($, anim) {

    var _defaults = {
      edge: 'left',
      draggable: true,
      inDuration: 250,
      outDuration: 200,
      onOpenStart: null,
      onOpenEnd: null,
      onCloseStart: null,
      onCloseEnd: null,
      preventScrolling: true
    };

    /**
     * @class
     */

    var Sidenav = function (_Component8) {
      _inherits(Sidenav, _Component8);

      /**
       * Construct Sidenav instance and set up overlay
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Sidenav(el, options) {
        _classCallCheck(this, Sidenav);

        var _this31 = _possibleConstructorReturn(this, (Sidenav.__proto__ || Object.getPrototypeOf(Sidenav)).call(this, Sidenav, el, options));

        _this31.el.M_Sidenav = _this31;
        _this31.id = _this31.$el.attr('id');

        /**
         * Options for the Sidenav
         * @member Sidenav#options
         * @prop {String} [edge='left'] - Side of screen on which Sidenav appears
         * @prop {Boolean} [draggable=true] - Allow swipe gestures to open/close Sidenav
         * @prop {Number} [inDuration=250] - Length in ms of enter transition
         * @prop {Number} [outDuration=200] - Length in ms of exit transition
         * @prop {Function} onOpenStart - Function called when sidenav starts entering
         * @prop {Function} onOpenEnd - Function called when sidenav finishes entering
         * @prop {Function} onCloseStart - Function called when sidenav starts exiting
         * @prop {Function} onCloseEnd - Function called when sidenav finishes exiting
         */
        _this31.options = $.extend({}, Sidenav.defaults, options);

        /**
         * Describes open/close state of Sidenav
         * @type {Boolean}
         */
        _this31.isOpen = false;

        /**
         * Describes if Sidenav is fixed
         * @type {Boolean}
         */
        _this31.isFixed = _this31.el.classList.contains('sidenav-fixed');

        /**
         * Describes if Sidenav is being draggeed
         * @type {Boolean}
         */
        _this31.isDragged = false;

        // Window size variables for window resize checks
        _this31.lastWindowWidth = window.innerWidth;
        _this31.lastWindowHeight = window.innerHeight;

        _this31._createOverlay();
        _this31._createDragTarget();
        _this31._setupEventHandlers();
        _this31._setupClasses();
        _this31._setupFixed();

        Sidenav._sidenavs.push(_this31);
        return _this31;
      }

      _createClass(Sidenav, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this._enableBodyScrolling();
          this._overlay.parentNode.removeChild(this._overlay);
          this.dragTarget.parentNode.removeChild(this.dragTarget);
          this.el.M_Sidenav = undefined;
          this.el.style.transform = '';

          var index = Sidenav._sidenavs.indexOf(this);
          if (index >= 0) {
            Sidenav._sidenavs.splice(index, 1);
          }
        }
      }, {
        key: "_createOverlay",
        value: function _createOverlay() {
          var overlay = document.createElement('div');
          this._closeBound = this.close.bind(this);
          overlay.classList.add('sidenav-overlay');

          overlay.addEventListener('click', this._closeBound);

          document.body.appendChild(overlay);
          this._overlay = overlay;
        }
      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          if (Sidenav._sidenavs.length === 0) {
            document.body.addEventListener('click', this._handleTriggerClick);
          }

          this._handleDragTargetDragBound = this._handleDragTargetDrag.bind(this);
          this._handleDragTargetReleaseBound = this._handleDragTargetRelease.bind(this);
          this._handleCloseDragBound = this._handleCloseDrag.bind(this);
          this._handleCloseReleaseBound = this._handleCloseRelease.bind(this);
          this._handleCloseTriggerClickBound = this._handleCloseTriggerClick.bind(this);

          this.dragTarget.addEventListener('touchmove', this._handleDragTargetDragBound);
          this.dragTarget.addEventListener('touchend', this._handleDragTargetReleaseBound);
          this._overlay.addEventListener('touchmove', this._handleCloseDragBound);
          this._overlay.addEventListener('touchend', this._handleCloseReleaseBound);
          this.el.addEventListener('touchmove', this._handleCloseDragBound);
          this.el.addEventListener('touchend', this._handleCloseReleaseBound);
          this.el.addEventListener('click', this._handleCloseTriggerClickBound);

          // Add resize for side nav fixed
          if (this.isFixed) {
            this._handleWindowResizeBound = this._handleWindowResize.bind(this);
            window.addEventListener('resize', this._handleWindowResizeBound);
          }
        }
      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          if (Sidenav._sidenavs.length === 1) {
            document.body.removeEventListener('click', this._handleTriggerClick);
          }

          this.dragTarget.removeEventListener('touchmove', this._handleDragTargetDragBound);
          this.dragTarget.removeEventListener('touchend', this._handleDragTargetReleaseBound);
          this._overlay.removeEventListener('touchmove', this._handleCloseDragBound);
          this._overlay.removeEventListener('touchend', this._handleCloseReleaseBound);
          this.el.removeEventListener('touchmove', this._handleCloseDragBound);
          this.el.removeEventListener('touchend', this._handleCloseReleaseBound);
          this.el.removeEventListener('click', this._handleCloseTriggerClickBound);

          // Remove resize for side nav fixed
          if (this.isFixed) {
            window.removeEventListener('resize', this._handleWindowResizeBound);
          }
        }

        /**
         * Handle Trigger Click
         * @param {Event} e
         */

      }, {
        key: "_handleTriggerClick",
        value: function _handleTriggerClick(e) {
          var $trigger = $(e.target).closest('.sidenav-trigger');
          if (e.target && $trigger.length) {
            var sidenavId = M.getIdFromTrigger($trigger[0]);

            var sidenavInstance = document.getElementById(sidenavId).M_Sidenav;
            if (sidenavInstance) {
              sidenavInstance.open($trigger);
            }
            e.preventDefault();
          }
        }

        /**
         * Set variables needed at the beggining of drag
         * and stop any current transition.
         * @param {Event} e
         */

      }, {
        key: "_startDrag",
        value: function _startDrag(e) {
          var clientX = e.targetTouches[0].clientX;
          this.isDragged = true;
          this._startingXpos = clientX;
          this._xPos = this._startingXpos;
          this._time = Date.now();
          this._width = this.el.getBoundingClientRect().width;
          this._overlay.style.display = 'block';
          this._initialScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();
          this._verticallyScrolling = false;
          anim.remove(this.el);
          anim.remove(this._overlay);
        }

        /**
         * Set variables needed at each drag move update tick
         * @param {Event} e
         */

      }, {
        key: "_dragMoveUpdate",
        value: function _dragMoveUpdate(e) {
          var clientX = e.targetTouches[0].clientX;
          var currentScrollTop = this.isOpen ? this.el.scrollTop : M.getDocumentScrollTop();
          this.deltaX = Math.abs(this._xPos - clientX);
          this._xPos = clientX;
          this.velocityX = this.deltaX / (Date.now() - this._time);
          this._time = Date.now();
          if (this._initialScrollTop !== currentScrollTop) {
            this._verticallyScrolling = true;
          }
        }

        /**
         * Handles Dragging of Sidenav
         * @param {Event} e
         */

      }, {
        key: "_handleDragTargetDrag",
        value: function _handleDragTargetDrag(e) {
          // Check if draggable
          if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) {
            return;
          }

          // If not being dragged, set initial drag start variables
          if (!this.isDragged) {
            this._startDrag(e);
          }

          // Run touchmove updates
          this._dragMoveUpdate(e);

          // Calculate raw deltaX
          var totalDeltaX = this._xPos - this._startingXpos;

          // dragDirection is the attempted user drag direction
          var dragDirection = totalDeltaX > 0 ? 'right' : 'left';

          // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction
          totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));
          if (this.options.edge === dragDirection) {
            totalDeltaX = 0;
          }

          /**
           * transformX is the drag displacement
           * transformPrefix is the initial transform placement
           * Invert values if Sidenav is right edge
           */
          var transformX = totalDeltaX;
          var transformPrefix = 'translateX(-100%)';
          if (this.options.edge === 'right') {
            transformPrefix = 'translateX(100%)';
            transformX = -transformX;
          }

          // Calculate open/close percentage of sidenav, with open = 1 and close = 0
          this.percentOpen = Math.min(1, totalDeltaX / this._width);

          // Set transform and opacity styles
          this.el.style.transform = transformPrefix + " translateX(" + transformX + "px)";
          this._overlay.style.opacity = this.percentOpen;
        }

        /**
         * Handle Drag Target Release
         */

      }, {
        key: "_handleDragTargetRelease",
        value: function _handleDragTargetRelease() {
          if (this.isDragged) {
            if (this.percentOpen > 0.2) {
              this.open();
            } else {
              this._animateOut();
            }

            this.isDragged = false;
            this._verticallyScrolling = false;
          }
        }

        /**
         * Handle Close Drag
         * @param {Event} e
         */

      }, {
        key: "_handleCloseDrag",
        value: function _handleCloseDrag(e) {
          if (this.isOpen) {
            // Check if draggable
            if (!this.options.draggable || this._isCurrentlyFixed() || this._verticallyScrolling) {
              return;
            }

            // If not being dragged, set initial drag start variables
            if (!this.isDragged) {
              this._startDrag(e);
            }

            // Run touchmove updates
            this._dragMoveUpdate(e);

            // Calculate raw deltaX
            var totalDeltaX = this._xPos - this._startingXpos;

            // dragDirection is the attempted user drag direction
            var dragDirection = totalDeltaX > 0 ? 'right' : 'left';

            // Don't allow totalDeltaX to exceed Sidenav width or be dragged in the opposite direction
            totalDeltaX = Math.min(this._width, Math.abs(totalDeltaX));
            if (this.options.edge !== dragDirection) {
              totalDeltaX = 0;
            }

            var transformX = -totalDeltaX;
            if (this.options.edge === 'right') {
              transformX = -transformX;
            }

            // Calculate open/close percentage of sidenav, with open = 1 and close = 0
            this.percentOpen = Math.min(1, 1 - totalDeltaX / this._width);

            // Set transform and opacity styles
            this.el.style.transform = "translateX(" + transformX + "px)";
            this._overlay.style.opacity = this.percentOpen;
          }
        }

        /**
         * Handle Close Release
         */

      }, {
        key: "_handleCloseRelease",
        value: function _handleCloseRelease() {
          if (this.isOpen && this.isDragged) {
            if (this.percentOpen > 0.8) {
              this._animateIn();
            } else {
              this.close();
            }

            this.isDragged = false;
            this._verticallyScrolling = false;
          }
        }

        /**
         * Handles closing of Sidenav when element with class .sidenav-close
         */

      }, {
        key: "_handleCloseTriggerClick",
        value: function _handleCloseTriggerClick(e) {
          var $closeTrigger = $(e.target).closest('.sidenav-close');
          if ($closeTrigger.length && !this._isCurrentlyFixed()) {
            this.close();
          }
        }

        /**
         * Handle Window Resize
         */

      }, {
        key: "_handleWindowResize",
        value: function _handleWindowResize() {
          // Only handle horizontal resizes
          if (this.lastWindowWidth !== window.innerWidth) {
            if (window.innerWidth > 992) {
              this.open();
            } else {
              this.close();
            }
          }

          this.lastWindowWidth = window.innerWidth;
          this.lastWindowHeight = window.innerHeight;
        }
      }, {
        key: "_setupClasses",
        value: function _setupClasses() {
          if (this.options.edge === 'right') {
            this.el.classList.add('right-aligned');
            this.dragTarget.classList.add('right-aligned');
          }
        }
      }, {
        key: "_removeClasses",
        value: function _removeClasses() {
          this.el.classList.remove('right-aligned');
          this.dragTarget.classList.remove('right-aligned');
        }
      }, {
        key: "_setupFixed",
        value: function _setupFixed() {
          if (this._isCurrentlyFixed()) {
            this.open();
          }
        }
      }, {
        key: "_isCurrentlyFixed",
        value: function _isCurrentlyFixed() {
          return this.isFixed && window.innerWidth > 992;
        }
      }, {
        key: "_createDragTarget",
        value: function _createDragTarget() {
          var dragTarget = document.createElement('div');
          dragTarget.classList.add('drag-target');
          document.body.appendChild(dragTarget);
          this.dragTarget = dragTarget;
        }
      }, {
        key: "_preventBodyScrolling",
        value: function _preventBodyScrolling() {
          var body = document.body;
          body.style.overflow = 'hidden';
        }
      }, {
        key: "_enableBodyScrolling",
        value: function _enableBodyScrolling() {
          var body = document.body;
          body.style.overflow = '';
        }
      }, {
        key: "open",
        value: function open() {
          if (this.isOpen === true) {
            return;
          }

          this.isOpen = true;

          // Run onOpenStart callback
          if (typeof this.options.onOpenStart === 'function') {
            this.options.onOpenStart.call(this, this.el);
          }

          // Handle fixed Sidenav
          if (this._isCurrentlyFixed()) {
            anim.remove(this.el);
            anim({
              targets: this.el,
              translateX: 0,
              duration: 0,
              easing: 'easeOutQuad'
            });
            this._enableBodyScrolling();
            this._overlay.style.display = 'none';

            // Handle non-fixed Sidenav
          } else {
            if (this.options.preventScrolling) {
              this._preventBodyScrolling();
            }

            if (!this.isDragged || this.percentOpen != 1) {
              this._animateIn();
            }
          }
        }
      }, {
        key: "close",
        value: function close() {
          if (this.isOpen === false) {
            return;
          }

          this.isOpen = false;

          // Run onCloseStart callback
          if (typeof this.options.onCloseStart === 'function') {
            this.options.onCloseStart.call(this, this.el);
          }

          // Handle fixed Sidenav
          if (this._isCurrentlyFixed()) {
            var transformX = this.options.edge === 'left' ? '-105%' : '105%';
            this.el.style.transform = "translateX(" + transformX + ")";

            // Handle non-fixed Sidenav
          } else {
            this._enableBodyScrolling();

            if (!this.isDragged || this.percentOpen != 0) {
              this._animateOut();
            } else {
              this._overlay.style.display = 'none';
            }
          }
        }
      }, {
        key: "_animateIn",
        value: function _animateIn() {
          this._animateSidenavIn();
          this._animateOverlayIn();
        }
      }, {
        key: "_animateSidenavIn",
        value: function _animateSidenavIn() {
          var _this32 = this;

          var slideOutPercent = this.options.edge === 'left' ? -1 : 1;
          if (this.isDragged) {
            slideOutPercent = this.options.edge === 'left' ? slideOutPercent + this.percentOpen : slideOutPercent - this.percentOpen;
          }

          anim.remove(this.el);
          anim({
            targets: this.el,
            translateX: [slideOutPercent * 100 + "%", 0],
            duration: this.options.inDuration,
            easing: 'easeOutQuad',
            complete: function () {
              // Run onOpenEnd callback
              if (typeof _this32.options.onOpenEnd === 'function') {
                _this32.options.onOpenEnd.call(_this32, _this32.el);
              }
            }
          });
        }
      }, {
        key: "_animateOverlayIn",
        value: function _animateOverlayIn() {
          var start = 0;
          if (this.isDragged) {
            start = this.percentOpen;
          } else {
            $(this._overlay).css({
              display: 'block'
            });
          }

          anim.remove(this._overlay);
          anim({
            targets: this._overlay,
            opacity: [start, 1],
            duration: this.options.inDuration,
            easing: 'easeOutQuad'
          });
        }
      }, {
        key: "_animateOut",
        value: function _animateOut() {
          this._animateSidenavOut();
          this._animateOverlayOut();
        }
      }, {
        key: "_animateSidenavOut",
        value: function _animateSidenavOut() {
          var _this33 = this;

          var endPercent = this.options.edge === 'left' ? -1 : 1;
          var slideOutPercent = 0;
          if (this.isDragged) {
            slideOutPercent = this.options.edge === 'left' ? endPercent + this.percentOpen : endPercent - this.percentOpen;
          }

          anim.remove(this.el);
          anim({
            targets: this.el,
            translateX: [slideOutPercent * 100 + "%", endPercent * 105 + "%"],
            duration: this.options.outDuration,
            easing: 'easeOutQuad',
            complete: function () {
              // Run onOpenEnd callback
              if (typeof _this33.options.onCloseEnd === 'function') {
                _this33.options.onCloseEnd.call(_this33, _this33.el);
              }
            }
          });
        }
      }, {
        key: "_animateOverlayOut",
        value: function _animateOverlayOut() {
          var _this34 = this;

          anim.remove(this._overlay);
          anim({
            targets: this._overlay,
            opacity: 0,
            duration: this.options.outDuration,
            easing: 'easeOutQuad',
            complete: function () {
              $(_this34._overlay).css('display', 'none');
            }
          });
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Sidenav.__proto__ || Object.getPrototypeOf(Sidenav), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Sidenav;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Sidenav;
    }(Component);

    /**
     * @static
     * @memberof Sidenav
     * @type {Array.<Sidenav>}
     */


    Sidenav._sidenavs = [];

    window.M.Sidenav = Sidenav;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Sidenav, 'sidenav', 'M_Sidenav');
    }
  })(cash, M.anime);
  (function ($, anim) {

    var _defaults = {
      throttle: 100,
      scrollOffset: 200, // offset - 200 allows elements near bottom of page to scroll
      activeClass: 'active',
      getActiveElement: function (id) {
        return 'a[href="#' + id + '"]';
      }
    };

    /**
     * @class
     *
     */

    var ScrollSpy = function (_Component9) {
      _inherits(ScrollSpy, _Component9);

      /**
       * Construct ScrollSpy instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function ScrollSpy(el, options) {
        _classCallCheck(this, ScrollSpy);

        var _this35 = _possibleConstructorReturn(this, (ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy)).call(this, ScrollSpy, el, options));

        _this35.el.M_ScrollSpy = _this35;

        /**
         * Options for the modal
         * @member Modal#options
         * @prop {Number} [throttle=100] - Throttle of scroll handler
         * @prop {Number} [scrollOffset=200] - Offset for centering element when scrolled to
         * @prop {String} [activeClass='active'] - Class applied to active elements
         * @prop {Function} [getActiveElement] - Used to find active element
         */
        _this35.options = $.extend({}, ScrollSpy.defaults, options);

        // setup
        ScrollSpy._elements.push(_this35);
        ScrollSpy._count++;
        ScrollSpy._increment++;
        _this35.tickId = -1;
        _this35.id = ScrollSpy._increment;
        _this35._setupEventHandlers();
        _this35._handleWindowScroll();
        return _this35;
      }

      _createClass(ScrollSpy, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          ScrollSpy._elements.splice(ScrollSpy._elements.indexOf(this), 1);
          ScrollSpy._elementsInView.splice(ScrollSpy._elementsInView.indexOf(this), 1);
          ScrollSpy._visibleElements.splice(ScrollSpy._visibleElements.indexOf(this.$el), 1);
          ScrollSpy._count--;
          this._removeEventHandlers();
          $(this.options.getActiveElement(this.$el.attr('id'))).removeClass(this.options.activeClass);
          this.el.M_ScrollSpy = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          var throttledResize = M.throttle(this._handleWindowScroll, 200);
          this._handleThrottledResizeBound = throttledResize.bind(this);
          this._handleWindowScrollBound = this._handleWindowScroll.bind(this);
          if (ScrollSpy._count === 1) {
            window.addEventListener('scroll', this._handleWindowScrollBound);
            window.addEventListener('resize', this._handleThrottledResizeBound);
            document.body.addEventListener('click', this._handleTriggerClick);
          }
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          if (ScrollSpy._count === 0) {
            window.removeEventListener('scroll', this._handleWindowScrollBound);
            window.removeEventListener('resize', this._handleThrottledResizeBound);
            document.body.removeEventListener('click', this._handleTriggerClick);
          }
        }

        /**
         * Handle Trigger Click
         * @param {Event} e
         */

      }, {
        key: "_handleTriggerClick",
        value: function _handleTriggerClick(e) {
          var $trigger = $(e.target);
          for (var i = ScrollSpy._elements.length - 1; i >= 0; i--) {
            var scrollspy = ScrollSpy._elements[i];
            if ($trigger.is('a[href="#' + scrollspy.$el.attr('id') + '"]')) {
              e.preventDefault();
              var offset = scrollspy.$el.offset().top + 1;

              anim({
                targets: [document.documentElement, document.body],
                scrollTop: offset - scrollspy.options.scrollOffset,
                duration: 400,
                easing: 'easeOutCubic'
              });
              break;
            }
          }
        }

        /**
         * Handle Window Scroll
         */

      }, {
        key: "_handleWindowScroll",
        value: function _handleWindowScroll() {
          // unique tick id
          ScrollSpy._ticks++;

          // viewport rectangle
          var top = M.getDocumentScrollTop(),
              left = M.getDocumentScrollLeft(),
              right = left + window.innerWidth,
              bottom = top + window.innerHeight;

          // determine which elements are in view
          var intersections = ScrollSpy._findElements(top, right, bottom, left);
          for (var i = 0; i < intersections.length; i++) {
            var scrollspy = intersections[i];
            var lastTick = scrollspy.tickId;
            if (lastTick < 0) {
              // entered into view
              scrollspy._enter();
            }

            // update tick id
            scrollspy.tickId = ScrollSpy._ticks;
          }

          for (var _i = 0; _i < ScrollSpy._elementsInView.length; _i++) {
            var _scrollspy = ScrollSpy._elementsInView[_i];
            var _lastTick = _scrollspy.tickId;
            if (_lastTick >= 0 && _lastTick !== ScrollSpy._ticks) {
              // exited from view
              _scrollspy._exit();
              _scrollspy.tickId = -1;
            }
          }

          // remember elements in view for next tick
          ScrollSpy._elementsInView = intersections;
        }

        /**
         * Find elements that are within the boundary
         * @param {number} top
         * @param {number} right
         * @param {number} bottom
         * @param {number} left
         * @return {Array.<ScrollSpy>}   A collection of elements
         */

      }, {
        key: "_enter",
        value: function _enter() {
          ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (value) {
            return value.height() != 0;
          });

          if (ScrollSpy._visibleElements[0]) {
            $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);
            if (ScrollSpy._visibleElements[0][0].M_ScrollSpy && this.id < ScrollSpy._visibleElements[0][0].M_ScrollSpy.id) {
              ScrollSpy._visibleElements.unshift(this.$el);
            } else {
              ScrollSpy._visibleElements.push(this.$el);
            }
          } else {
            ScrollSpy._visibleElements.push(this.$el);
          }

          $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);
        }
      }, {
        key: "_exit",
        value: function _exit() {
          var _this36 = this;

          ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (value) {
            return value.height() != 0;
          });

          if (ScrollSpy._visibleElements[0]) {
            $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).removeClass(this.options.activeClass);

            ScrollSpy._visibleElements = ScrollSpy._visibleElements.filter(function (el) {
              return el.attr('id') != _this36.$el.attr('id');
            });
            if (ScrollSpy._visibleElements[0]) {
              // Check if empty
              $(this.options.getActiveElement(ScrollSpy._visibleElements[0].attr('id'))).addClass(this.options.activeClass);
            }
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(ScrollSpy.__proto__ || Object.getPrototypeOf(ScrollSpy), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_ScrollSpy;
        }
      }, {
        key: "_findElements",
        value: function _findElements(top, right, bottom, left) {
          var hits = [];
          for (var i = 0; i < ScrollSpy._elements.length; i++) {
            var scrollspy = ScrollSpy._elements[i];
            var currTop = top + scrollspy.options.scrollOffset || 200;

            if (scrollspy.$el.height() > 0) {
              var elTop = scrollspy.$el.offset().top,
                  elLeft = scrollspy.$el.offset().left,
                  elRight = elLeft + scrollspy.$el.width(),
                  elBottom = elTop + scrollspy.$el.height();

              var isIntersect = !(elLeft > right || elRight < left || elTop > bottom || elBottom < currTop);

              if (isIntersect) {
                hits.push(scrollspy);
              }
            }
          }
          return hits;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return ScrollSpy;
    }(Component);

    /**
     * @static
     * @memberof ScrollSpy
     * @type {Array.<ScrollSpy>}
     */


    ScrollSpy._elements = [];

    /**
     * @static
     * @memberof ScrollSpy
     * @type {Array.<ScrollSpy>}
     */
    ScrollSpy._elementsInView = [];

    /**
     * @static
     * @memberof ScrollSpy
     * @type {Array.<cash>}
     */
    ScrollSpy._visibleElements = [];

    /**
     * @static
     * @memberof ScrollSpy
     */
    ScrollSpy._count = 0;

    /**
     * @static
     * @memberof ScrollSpy
     */
    ScrollSpy._increment = 0;

    /**
     * @static
     * @memberof ScrollSpy
     */
    ScrollSpy._ticks = 0;

    M.ScrollSpy = ScrollSpy;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(ScrollSpy, 'scrollSpy', 'M_ScrollSpy');
    }
  })(cash, M.anime);
  (function ($) {

    var _defaults = {
      data: {}, // Autocomplete data set
      limit: Infinity, // Limit of results the autocomplete shows
      onAutocomplete: null, // Callback for when autocompleted
      minLength: 1, // Min characters before autocomplete starts
      sortFunction: function (a, b, inputString) {
        // Sort function for sorting autocomplete results
        return a.indexOf(inputString) - b.indexOf(inputString);
      }
    };

    /**
     * @class
     *
     */

    var Autocomplete = function (_Component10) {
      _inherits(Autocomplete, _Component10);

      /**
       * Construct Autocomplete instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Autocomplete(el, options) {
        _classCallCheck(this, Autocomplete);

        var _this37 = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, Autocomplete, el, options));

        _this37.el.M_Autocomplete = _this37;

        /**
         * Options for the autocomplete
         * @member Autocomplete#options
         * @prop {Number} duration
         * @prop {Number} dist
         * @prop {number} shift
         * @prop {number} padding
         * @prop {Boolean} fullWidth
         * @prop {Boolean} indicators
         * @prop {Boolean} noWrap
         * @prop {Function} onCycleTo
         */
        _this37.options = $.extend({}, Autocomplete.defaults, options);

        // Setup
        _this37.isOpen = false;
        _this37.count = 0;
        _this37.activeIndex = -1;
        _this37.oldVal;
        _this37.$inputField = _this37.$el.closest('.input-field');
        _this37.$active = $();
        _this37._mousedown = false;
        _this37._setupDropdown();

        _this37._setupEventHandlers();
        return _this37;
      }

      _createClass(Autocomplete, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this._removeDropdown();
          this.el.M_Autocomplete = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleInputBlurBound = this._handleInputBlur.bind(this);
          this._handleInputKeyupAndFocusBound = this._handleInputKeyupAndFocus.bind(this);
          this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
          this._handleInputClickBound = this._handleInputClick.bind(this);
          this._handleContainerMousedownAndTouchstartBound = this._handleContainerMousedownAndTouchstart.bind(this);
          this._handleContainerMouseupAndTouchendBound = this._handleContainerMouseupAndTouchend.bind(this);

          this.el.addEventListener('blur', this._handleInputBlurBound);
          this.el.addEventListener('keyup', this._handleInputKeyupAndFocusBound);
          this.el.addEventListener('focus', this._handleInputKeyupAndFocusBound);
          this.el.addEventListener('keydown', this._handleInputKeydownBound);
          this.el.addEventListener('click', this._handleInputClickBound);
          this.container.addEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);
          this.container.addEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);

          if (typeof window.ontouchstart !== 'undefined') {
            this.container.addEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);
            this.container.addEventListener('touchend', this._handleContainerMouseupAndTouchendBound);
          }
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('blur', this._handleInputBlurBound);
          this.el.removeEventListener('keyup', this._handleInputKeyupAndFocusBound);
          this.el.removeEventListener('focus', this._handleInputKeyupAndFocusBound);
          this.el.removeEventListener('keydown', this._handleInputKeydownBound);
          this.el.removeEventListener('click', this._handleInputClickBound);
          this.container.removeEventListener('mousedown', this._handleContainerMousedownAndTouchstartBound);
          this.container.removeEventListener('mouseup', this._handleContainerMouseupAndTouchendBound);

          if (typeof window.ontouchstart !== 'undefined') {
            this.container.removeEventListener('touchstart', this._handleContainerMousedownAndTouchstartBound);
            this.container.removeEventListener('touchend', this._handleContainerMouseupAndTouchendBound);
          }
        }

        /**
         * Setup dropdown
         */

      }, {
        key: "_setupDropdown",
        value: function _setupDropdown() {
          var _this38 = this;

          this.container = document.createElement('ul');
          this.container.id = "autocomplete-options-" + M.guid();
          $(this.container).addClass('autocomplete-content dropdown-content');
          this.$inputField.append(this.container);
          this.el.setAttribute('data-target', this.container.id);

          this.dropdown = M.Dropdown.init(this.el, {
            autoFocus: false,
            closeOnClick: false,
            coverTrigger: false,
            onItemClick: function (itemEl) {
              _this38.selectOption($(itemEl));
            }
          });

          // Sketchy removal of dropdown click handler
          this.el.removeEventListener('click', this.dropdown._handleClickBound);
        }

        /**
         * Remove dropdown
         */

      }, {
        key: "_removeDropdown",
        value: function _removeDropdown() {
          this.container.parentNode.removeChild(this.container);
        }

        /**
         * Handle Input Blur
         */

      }, {
        key: "_handleInputBlur",
        value: function _handleInputBlur() {
          if (!this._mousedown) {
            this.close();
            this._resetAutocomplete();
          }
        }

        /**
         * Handle Input Keyup and Focus
         * @param {Event} e
         */

      }, {
        key: "_handleInputKeyupAndFocus",
        value: function _handleInputKeyupAndFocus(e) {
          if (e.type === 'keyup') {
            Autocomplete._keydown = false;
          }

          this.count = 0;
          var val = this.el.value.toLowerCase();

          // Don't capture enter or arrow key usage.
          if (e.keyCode === 13 || e.keyCode === 38 || e.keyCode === 40) {
            return;
          }

          // Check if the input isn't empty
          // Check if focus triggered by tab
          if (this.oldVal !== val && (M.tabPressed || e.type !== 'focus')) {
            this.open();
          }

          // Update oldVal
          this.oldVal = val;
        }

        /**
         * Handle Input Keydown
         * @param {Event} e
         */

      }, {
        key: "_handleInputKeydown",
        value: function _handleInputKeydown(e) {
          Autocomplete._keydown = true;

          // Arrow keys and enter key usage
          var keyCode = e.keyCode,
              liElement = void 0,
              numItems = $(this.container).children('li').length;

          // select element on Enter
          if (keyCode === M.keys.ENTER && this.activeIndex >= 0) {
            liElement = $(this.container).children('li').eq(this.activeIndex);
            if (liElement.length) {
              this.selectOption(liElement);
              e.preventDefault();
            }
            return;
          }

          // Capture up and down key
          if (keyCode === M.keys.ARROW_UP || keyCode === M.keys.ARROW_DOWN) {
            e.preventDefault();

            if (keyCode === M.keys.ARROW_UP && this.activeIndex > 0) {
              this.activeIndex--;
            }

            if (keyCode === M.keys.ARROW_DOWN && this.activeIndex < numItems - 1) {
              this.activeIndex++;
            }

            this.$active.removeClass('active');
            if (this.activeIndex >= 0) {
              this.$active = $(this.container).children('li').eq(this.activeIndex);
              this.$active.addClass('active');
            }
          }
        }

        /**
         * Handle Input Click
         * @param {Event} e
         */

      }, {
        key: "_handleInputClick",
        value: function _handleInputClick(e) {
          this.open();
        }

        /**
         * Handle Container Mousedown and Touchstart
         * @param {Event} e
         */

      }, {
        key: "_handleContainerMousedownAndTouchstart",
        value: function _handleContainerMousedownAndTouchstart(e) {
          this._mousedown = true;
        }

        /**
         * Handle Container Mouseup and Touchend
         * @param {Event} e
         */

      }, {
        key: "_handleContainerMouseupAndTouchend",
        value: function _handleContainerMouseupAndTouchend(e) {
          this._mousedown = false;
        }

        /**
         * Highlight partial match
         */

      }, {
        key: "_highlight",
        value: function _highlight(string, $el) {
          var img = $el.find('img');
          var matchStart = $el.text().toLowerCase().indexOf('' + string.toLowerCase() + ''),
              matchEnd = matchStart + string.length - 1,
              beforeMatch = $el.text().slice(0, matchStart),
              matchText = $el.text().slice(matchStart, matchEnd + 1),
              afterMatch = $el.text().slice(matchEnd + 1);
          $el.html("<span>" + beforeMatch + "<span class='highlight'>" + matchText + "</span>" + afterMatch + "</span>");
          if (img.length) {
            $el.prepend(img);
          }
        }

        /**
         * Reset current element position
         */

      }, {
        key: "_resetCurrentElement",
        value: function _resetCurrentElement() {
          this.activeIndex = -1;
          this.$active.removeClass('active');
        }

        /**
         * Reset autocomplete elements
         */

      }, {
        key: "_resetAutocomplete",
        value: function _resetAutocomplete() {
          $(this.container).empty();
          this._resetCurrentElement();
          this.oldVal = null;
          this.isOpen = false;
          this._mousedown = false;
        }

        /**
         * Select autocomplete option
         * @param {Element} el  Autocomplete option list item element
         */

      }, {
        key: "selectOption",
        value: function selectOption(el) {
          var text = el.text().trim();
          this.el.value = text;
          this.$el.trigger('change');
          this._resetAutocomplete();
          this.close();

          // Handle onAutocomplete callback.
          if (typeof this.options.onAutocomplete === 'function') {
            this.options.onAutocomplete.call(this, text);
          }
        }

        /**
         * Render dropdown content
         * @param {Object} data  data set
         * @param {String} val  current input value
         */

      }, {
        key: "_renderDropdown",
        value: function _renderDropdown(data, val) {
          var _this39 = this;

          this._resetAutocomplete();

          var matchingData = [];

          // Gather all matching data
          for (var key in data) {
            if (data.hasOwnProperty(key) && key.toLowerCase().indexOf(val) !== -1) {
              // Break if past limit
              if (this.count >= this.options.limit) {
                break;
              }

              var entry = {
                data: data[key],
                key: key
              };
              matchingData.push(entry);

              this.count++;
            }
          }

          // Sort
          if (this.options.sortFunction) {
            var sortFunctionBound = function (a, b) {
              return _this39.options.sortFunction(a.key.toLowerCase(), b.key.toLowerCase(), val.toLowerCase());
            };
            matchingData.sort(sortFunctionBound);
          }

          // Render
          for (var i = 0; i < matchingData.length; i++) {
            var _entry = matchingData[i];
            var $autocompleteOption = $('<li></li>');
            if (!!_entry.data) {
              $autocompleteOption.append("<img src=\"" + _entry.data + "\" class=\"right circle\"><span>" + _entry.key + "</span>");
            } else {
              $autocompleteOption.append('<span>' + _entry.key + '</span>');
            }

            $(this.container).append($autocompleteOption);
            this._highlight(val, $autocompleteOption);
          }
        }

        /**
         * Open Autocomplete Dropdown
         */

      }, {
        key: "open",
        value: function open() {
          var val = this.el.value.toLowerCase();

          this._resetAutocomplete();

          if (val.length >= this.options.minLength) {
            this.isOpen = true;
            this._renderDropdown(this.options.data, val);
          }

          // Open dropdown
          if (!this.dropdown.isOpen) {
            this.dropdown.open();
          } else {
            // Recalculate dropdown when its already open
            this.dropdown.recalculateDimensions();
          }
        }

        /**
         * Close Autocomplete Dropdown
         */

      }, {
        key: "close",
        value: function close() {
          this.dropdown.close();
        }

        /**
         * Update Data
         * @param {Object} data
         */

      }, {
        key: "updateData",
        value: function updateData(data) {
          var val = this.el.value.toLowerCase();
          this.options.data = data;

          if (this.isOpen) {
            this._renderDropdown(data, val);
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Autocomplete;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Autocomplete;
    }(Component);

    /**
     * @static
     * @memberof Autocomplete
     */


    Autocomplete._keydown = false;

    M.Autocomplete = Autocomplete;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Autocomplete, 'autocomplete', 'M_Autocomplete');
    }
  })(cash);
  (function ($) {
    // Function to update labels of text fields
    M.updateTextFields = function () {
      var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';
      $(input_selector).each(function (element, index) {
        var $this = $(this);
        if (element.value.length > 0 || $(element).is(':focus') || element.autofocus || $this.attr('placeholder') !== null) {
          $this.siblings('label').addClass('active');
        } else if (element.validity) {
          $this.siblings('label').toggleClass('active', element.validity.badInput === true);
        } else {
          $this.siblings('label').removeClass('active');
        }
      });
    };

    M.validate_field = function (object) {
      var hasLength = object.attr('data-length') !== null;
      var lenAttr = parseInt(object.attr('data-length'));
      var len = object[0].value.length;

      if (len === 0 && object[0].validity.badInput === false && !object.is(':required')) {
        if (object.hasClass('validate')) {
          object.removeClass('valid');
          object.removeClass('invalid');
        }
      } else {
        if (object.hasClass('validate')) {
          // Check for character counter attributes
          if (object.is(':valid') && hasLength && len <= lenAttr || object.is(':valid') && !hasLength) {
            object.removeClass('invalid');
            object.addClass('valid');
          } else {
            object.removeClass('valid');
            object.addClass('invalid');
          }
        }
      }
    };

    M.textareaAutoResize = function ($textarea) {
      // Wrap if native element
      if ($textarea instanceof Element) {
        $textarea = $($textarea);
      }

      if (!$textarea.length) {
        console.error('No textarea element found');
        return;
      }

      // Textarea Auto Resize
      var hiddenDiv = $('.hiddendiv').first();
      if (!hiddenDiv.length) {
        hiddenDiv = $('<div class="hiddendiv common"></div>');
        $('body').append(hiddenDiv);
      }

      // Set font properties of hiddenDiv
      var fontFamily = $textarea.css('font-family');
      var fontSize = $textarea.css('font-size');
      var lineHeight = $textarea.css('line-height');

      // Firefox can't handle padding shorthand.
      var paddingTop = $textarea.css('padding-top');
      var paddingRight = $textarea.css('padding-right');
      var paddingBottom = $textarea.css('padding-bottom');
      var paddingLeft = $textarea.css('padding-left');

      if (fontSize) {
        hiddenDiv.css('font-size', fontSize);
      }
      if (fontFamily) {
        hiddenDiv.css('font-family', fontFamily);
      }
      if (lineHeight) {
        hiddenDiv.css('line-height', lineHeight);
      }
      if (paddingTop) {
        hiddenDiv.css('padding-top', paddingTop);
      }
      if (paddingRight) {
        hiddenDiv.css('padding-right', paddingRight);
      }
      if (paddingBottom) {
        hiddenDiv.css('padding-bottom', paddingBottom);
      }
      if (paddingLeft) {
        hiddenDiv.css('padding-left', paddingLeft);
      }

      // Set original-height, if none
      if (!$textarea.data('original-height')) {
        $textarea.data('original-height', $textarea.height());
      }

      if ($textarea.attr('wrap') === 'off') {
        hiddenDiv.css('overflow-wrap', 'normal').css('white-space', 'pre');
      }

      hiddenDiv.text($textarea[0].value + '\n');
      var content = hiddenDiv.html().replace(/\n/g, '<br>');
      hiddenDiv.html(content);

      // When textarea is hidden, width goes crazy.
      // Approximate with half of window size

      if ($textarea[0].offsetWidth > 0 && $textarea[0].offsetHeight > 0) {
        hiddenDiv.css('width', $textarea.width() + 'px');
      } else {
        hiddenDiv.css('width', window.innerWidth / 2 + 'px');
      }

      /**
       * Resize if the new height is greater than the
       * original height of the textarea
       */
      if ($textarea.data('original-height') <= hiddenDiv.innerHeight()) {
        $textarea.css('height', hiddenDiv.innerHeight() + 'px');
      } else if ($textarea[0].value.length < $textarea.data('previous-length')) {
        /**
         * In case the new height is less than original height, it
         * means the textarea has less text than before
         * So we set the height to the original one
         */
        $textarea.css('height', $textarea.data('original-height') + 'px');
      }
      $textarea.data('previous-length', $textarea[0].value.length);
    };

    $(document).ready(function () {
      // Text based inputs
      var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], input[type=date], input[type=time], textarea';

      // Add active if form auto complete
      $(document).on('change', input_selector, function () {
        if (this.value.length !== 0 || $(this).attr('placeholder') !== null) {
          $(this).siblings('label').addClass('active');
        }
        M.validate_field($(this));
      });

      // Add active if input element has been pre-populated on document ready
      $(document).ready(function () {
        M.updateTextFields();
      });

      // HTML DOM FORM RESET handling
      $(document).on('reset', function (e) {
        var formReset = $(e.target);
        if (formReset.is('form')) {
          formReset.find(input_selector).removeClass('valid').removeClass('invalid');
          formReset.find(input_selector).each(function (e) {
            if (this.value.length) {
              $(this).siblings('label').removeClass('active');
            }
          });

          // Reset select (after native reset)
          setTimeout(function () {
            formReset.find('select').each(function () {
              // check if initialized
              if (this.M_FormSelect) {
                $(this).trigger('change');
              }
            });
          }, 0);
        }
      });

      /**
       * Add active when element has focus
       * @param {Event} e
       */
      document.addEventListener('focus', function (e) {
        if ($(e.target).is(input_selector)) {
          $(e.target).siblings('label, .prefix').addClass('active');
        }
      }, true);

      /**
       * Remove active when element is blurred
       * @param {Event} e
       */
      document.addEventListener('blur', function (e) {
        var $inputElement = $(e.target);
        if ($inputElement.is(input_selector)) {
          var selector = '.prefix';

          if ($inputElement[0].value.length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === null) {
            selector += ', label';
          }
          $inputElement.siblings(selector).removeClass('active');
          M.validate_field($inputElement);
        }
      }, true);

      // Radio and Checkbox focus class
      var radio_checkbox = 'input[type=radio], input[type=checkbox]';
      $(document).on('keyup', radio_checkbox, function (e) {
        // TAB, check if tabbing to radio or checkbox.
        if (e.which === M.keys.TAB) {
          $(this).addClass('tabbed');
          var $this = $(this);
          $this.one('blur', function (e) {
            $(this).removeClass('tabbed');
          });
          return;
        }
      });

      var text_area_selector = '.materialize-textarea';
      $(text_area_selector).each(function () {
        var $textarea = $(this);
        /**
         * Resize textarea on document load after storing
         * the original height and the original length
         */
        $textarea.data('original-height', $textarea.height());
        $textarea.data('previous-length', this.value.length);
        M.textareaAutoResize($textarea);
      });

      $(document).on('keyup', text_area_selector, function () {
        M.textareaAutoResize($(this));
      });
      $(document).on('keydown', text_area_selector, function () {
        M.textareaAutoResize($(this));
      });

      // File Input Path
      $(document).on('change', '.file-field input[type="file"]', function () {
        var file_field = $(this).closest('.file-field');
        var path_input = file_field.find('input.file-path');
        var files = $(this)[0].files;
        var file_names = [];
        for (var i = 0; i < files.length; i++) {
          file_names.push(files[i].name);
        }
        path_input[0].value = file_names.join(', ');
        path_input.trigger('change');
      });
    }); // End of $(document).ready
  })(cash);
  (function ($, anim) {

    var _defaults = {
      indicators: true,
      height: 400,
      duration: 500,
      interval: 6000
    };

    /**
     * @class
     *
     */

    var Slider = function (_Component11) {
      _inherits(Slider, _Component11);

      /**
       * Construct Slider instance and set up overlay
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Slider(el, options) {
        _classCallCheck(this, Slider);

        var _this40 = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, Slider, el, options));

        _this40.el.M_Slider = _this40;

        /**
         * Options for the modal
         * @member Slider#options
         * @prop {Boolean} [indicators=true] - Show indicators
         * @prop {Number} [height=400] - height of slider
         * @prop {Number} [duration=500] - Length in ms of slide transition
         * @prop {Number} [interval=6000] - Length in ms of slide interval
         */
        _this40.options = $.extend({}, Slider.defaults, options);

        // setup
        _this40.$slider = _this40.$el.find('.slides');
        _this40.$slides = _this40.$slider.children('li');
        _this40.activeIndex = _this40.$slides.filter(function (item) {
          return $(item).hasClass('active');
        }).first().index();
        if (_this40.activeIndex != -1) {
          _this40.$active = _this40.$slides.eq(_this40.activeIndex);
        }

        _this40._setSliderHeight();

        // Set initial positions of captions
        _this40.$slides.find('.caption').each(function (el) {
          _this40._animateCaptionIn(el, 0);
        });

        // Move img src into background-image
        _this40.$slides.find('img').each(function (el) {
          var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
          if ($(el).attr('src') !== placeholderBase64) {
            $(el).css('background-image', 'url("' + $(el).attr('src') + '")');
            $(el).attr('src', placeholderBase64);
          }
        });

        _this40._setupIndicators();

        // Show active slide
        if (_this40.$active) {
          _this40.$active.css('display', 'block');
        } else {
          _this40.$slides.first().addClass('active');
          anim({
            targets: _this40.$slides.first()[0],
            opacity: 1,
            duration: _this40.options.duration,
            easing: 'easeOutQuad'
          });

          _this40.activeIndex = 0;
          _this40.$active = _this40.$slides.eq(_this40.activeIndex);

          // Update indicators
          if (_this40.options.indicators) {
            _this40.$indicators.eq(_this40.activeIndex).addClass('active');
          }
        }

        // Adjust height to current slide
        _this40.$active.find('img').each(function (el) {
          anim({
            targets: _this40.$active.find('.caption')[0],
            opacity: 1,
            translateX: 0,
            translateY: 0,
            duration: _this40.options.duration,
            easing: 'easeOutQuad'
          });
        });

        _this40._setupEventHandlers();

        // auto scroll
        _this40.start();
        return _this40;
      }

      _createClass(Slider, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this.pause();
          this._removeIndicators();
          this._removeEventHandlers();
          this.el.M_Slider = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          var _this41 = this;

          this._handleIntervalBound = this._handleInterval.bind(this);
          this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);

          if (this.options.indicators) {
            this.$indicators.each(function (el) {
              el.addEventListener('click', _this41._handleIndicatorClickBound);
            });
          }
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          var _this42 = this;

          if (this.options.indicators) {
            this.$indicators.each(function (el) {
              el.removeEventListener('click', _this42._handleIndicatorClickBound);
            });
          }
        }

        /**
         * Handle indicator click
         * @param {Event} e
         */

      }, {
        key: "_handleIndicatorClick",
        value: function _handleIndicatorClick(e) {
          var currIndex = $(e.target).index();
          this.set(currIndex);
        }

        /**
         * Handle Interval
         */

      }, {
        key: "_handleInterval",
        value: function _handleInterval() {
          var newActiveIndex = this.$slider.find('.active').index();
          if (this.$slides.length === newActiveIndex + 1) newActiveIndex = 0;
          // loop to start
          else newActiveIndex += 1;

          this.set(newActiveIndex);
        }

        /**
         * Animate in caption
         * @param {Element} caption
         * @param {Number} duration
         */

      }, {
        key: "_animateCaptionIn",
        value: function _animateCaptionIn(caption, duration) {
          var animOptions = {
            targets: caption,
            opacity: 0,
            duration: duration,
            easing: 'easeOutQuad'
          };

          if ($(caption).hasClass('center-align')) {
            animOptions.translateY = -100;
          } else if ($(caption).hasClass('right-align')) {
            animOptions.translateX = 100;
          } else if ($(caption).hasClass('left-align')) {
            animOptions.translateX = -100;
          }

          anim(animOptions);
        }

        /**
         * Set height of slider
         */

      }, {
        key: "_setSliderHeight",
        value: function _setSliderHeight() {
          // If fullscreen, do nothing
          if (!this.$el.hasClass('fullscreen')) {
            if (this.options.indicators) {
              // Add height if indicators are present
              this.$el.css('height', this.options.height + 40 + 'px');
            } else {
              this.$el.css('height', this.options.height + 'px');
            }
            this.$slider.css('height', this.options.height + 'px');
          }
        }

        /**
         * Setup indicators
         */

      }, {
        key: "_setupIndicators",
        value: function _setupIndicators() {
          var _this43 = this;

          if (this.options.indicators) {
            this.$indicators = $('<ul class="indicators"></ul>');
            this.$slides.each(function (el, index) {
              var $indicator = $('<li class="indicator-item"></li>');
              _this43.$indicators.append($indicator[0]);
            });
            this.$el.append(this.$indicators[0]);
            this.$indicators = this.$indicators.children('li.indicator-item');
          }
        }

        /**
         * Remove indicators
         */

      }, {
        key: "_removeIndicators",
        value: function _removeIndicators() {
          this.$el.find('ul.indicators').remove();
        }

        /**
         * Cycle to nth item
         * @param {Number} index
         */

      }, {
        key: "set",
        value: function set(index) {
          var _this44 = this;

          // Wrap around indices.
          if (index >= this.$slides.length) index = 0;else if (index < 0) index = this.$slides.length - 1;

          // Only do if index changes
          if (this.activeIndex != index) {
            this.$active = this.$slides.eq(this.activeIndex);
            var $caption = this.$active.find('.caption');
            this.$active.removeClass('active');

            anim({
              targets: this.$active[0],
              opacity: 0,
              duration: this.options.duration,
              easing: 'easeOutQuad',
              complete: function () {
                _this44.$slides.not('.active').each(function (el) {
                  anim({
                    targets: el,
                    opacity: 0,
                    translateX: 0,
                    translateY: 0,
                    duration: 0,
                    easing: 'easeOutQuad'
                  });
                });
              }
            });

            this._animateCaptionIn($caption[0], this.options.duration);

            // Update indicators
            if (this.options.indicators) {
              this.$indicators.eq(this.activeIndex).removeClass('active');
              this.$indicators.eq(index).addClass('active');
            }

            anim({
              targets: this.$slides.eq(index)[0],
              opacity: 1,
              duration: this.options.duration,
              easing: 'easeOutQuad'
            });

            anim({
              targets: this.$slides.eq(index).find('.caption')[0],
              opacity: 1,
              translateX: 0,
              translateY: 0,
              duration: this.options.duration,
              delay: this.options.duration,
              easing: 'easeOutQuad'
            });

            this.$slides.eq(index).addClass('active');
            this.activeIndex = index;

            // Reset interval
            this.start();
          }
        }

        /**
         * Pause slider interval
         */

      }, {
        key: "pause",
        value: function pause() {
          clearInterval(this.interval);
        }

        /**
         * Start slider interval
         */

      }, {
        key: "start",
        value: function start() {
          clearInterval(this.interval);
          this.interval = setInterval(this._handleIntervalBound, this.options.duration + this.options.interval);
        }

        /**
         * Move to next slide
         */

      }, {
        key: "next",
        value: function next() {
          var newIndex = this.activeIndex + 1;

          // Wrap around indices.
          if (newIndex >= this.$slides.length) newIndex = 0;else if (newIndex < 0) newIndex = this.$slides.length - 1;

          this.set(newIndex);
        }

        /**
         * Move to previous slide
         */

      }, {
        key: "prev",
        value: function prev() {
          var newIndex = this.activeIndex - 1;

          // Wrap around indices.
          if (newIndex >= this.$slides.length) newIndex = 0;else if (newIndex < 0) newIndex = this.$slides.length - 1;

          this.set(newIndex);
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Slider.__proto__ || Object.getPrototypeOf(Slider), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Slider;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Slider;
    }(Component);

    M.Slider = Slider;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Slider, 'slider', 'M_Slider');
    }
  })(cash, M.anime);
  (function ($, anim) {
    $(document).on('click', '.card', function (e) {
      if ($(this).children('.card-reveal').length) {
        var $card = $(e.target).closest('.card');
        if ($card.data('initialOverflow') === undefined) {
          $card.data('initialOverflow', $card.css('overflow') === undefined ? '' : $card.css('overflow'));
        }
        var $cardReveal = $(this).find('.card-reveal');
        if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {
          // Make Reveal animate down and display none
          anim({
            targets: $cardReveal[0],
            translateY: 0,
            duration: 225,
            easing: 'easeInOutQuad',
            complete: function (anim) {
              var el = anim.animatables[0].target;
              $(el).css({ display: 'none' });
              $card.css('overflow', $card.data('initialOverflow'));
            }
          });
        } else if ($(e.target).is($('.card .activator')) || $(e.target).is($('.card .activator i'))) {
          $card.css('overflow', 'hidden');
          $cardReveal.css({ display: 'block' });
          anim({
            targets: $cardReveal[0],
            translateY: '-100%',
            duration: 300,
            easing: 'easeInOutQuad'
          });
        }
      }
    });
  })(cash, M.anime);
  (function ($) {

    var _defaults = {
      data: [],
      placeholder: '',
      secondaryPlaceholder: '',
      autocompleteOptions: {},
      limit: Infinity,
      onChipAdd: null,
      onChipSelect: null,
      onChipDelete: null
    };

    /**
     * @typedef {Object} chip
     * @property {String} tag  chip tag string
     * @property {String} [image]  chip avatar image string
     */

    /**
     * @class
     *
     */

    var Chips = function (_Component12) {
      _inherits(Chips, _Component12);

      /**
       * Construct Chips instance and set up overlay
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Chips(el, options) {
        _classCallCheck(this, Chips);

        var _this45 = _possibleConstructorReturn(this, (Chips.__proto__ || Object.getPrototypeOf(Chips)).call(this, Chips, el, options));

        _this45.el.M_Chips = _this45;

        /**
         * Options for the modal
         * @member Chips#options
         * @prop {Array} data
         * @prop {String} placeholder
         * @prop {String} secondaryPlaceholder
         * @prop {Object} autocompleteOptions
         */
        _this45.options = $.extend({}, Chips.defaults, options);

        _this45.$el.addClass('chips input-field');
        _this45.chipsData = [];
        _this45.$chips = $();
        _this45._setupInput();
        _this45.hasAutocomplete = Object.keys(_this45.options.autocompleteOptions).length > 0;

        // Set input id
        if (!_this45.$input.attr('id')) {
          _this45.$input.attr('id', M.guid());
        }

        // Render initial chips
        if (_this45.options.data.length) {
          _this45.chipsData = _this45.options.data;
          _this45._renderChips(_this45.chipsData);
        }

        // Setup autocomplete if needed
        if (_this45.hasAutocomplete) {
          _this45._setupAutocomplete();
        }

        _this45._setPlaceholder();
        _this45._setupLabel();
        _this45._setupEventHandlers();
        return _this45;
      }

      _createClass(Chips, [{
        key: "getData",


        /**
         * Get Chips Data
         */
        value: function getData() {
          return this.chipsData;
        }

        /**
         * Teardown component
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this._removeEventHandlers();
          this.$chips.remove();
          this.el.M_Chips = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleChipClickBound = this._handleChipClick.bind(this);
          this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
          this._handleInputFocusBound = this._handleInputFocus.bind(this);
          this._handleInputBlurBound = this._handleInputBlur.bind(this);

          this.el.addEventListener('click', this._handleChipClickBound);
          document.addEventListener('keydown', Chips._handleChipsKeydown);
          document.addEventListener('keyup', Chips._handleChipsKeyup);
          this.el.addEventListener('blur', Chips._handleChipsBlur, true);
          this.$input[0].addEventListener('focus', this._handleInputFocusBound);
          this.$input[0].addEventListener('blur', this._handleInputBlurBound);
          this.$input[0].addEventListener('keydown', this._handleInputKeydownBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('click', this._handleChipClickBound);
          document.removeEventListener('keydown', Chips._handleChipsKeydown);
          document.removeEventListener('keyup', Chips._handleChipsKeyup);
          this.el.removeEventListener('blur', Chips._handleChipsBlur, true);
          this.$input[0].removeEventListener('focus', this._handleInputFocusBound);
          this.$input[0].removeEventListener('blur', this._handleInputBlurBound);
          this.$input[0].removeEventListener('keydown', this._handleInputKeydownBound);
        }

        /**
         * Handle Chip Click
         * @param {Event} e
         */

      }, {
        key: "_handleChipClick",
        value: function _handleChipClick(e) {
          var $chip = $(e.target).closest('.chip');
          var clickedClose = $(e.target).is('.close');
          if ($chip.length) {
            var index = $chip.index();
            if (clickedClose) {
              // delete chip
              this.deleteChip(index);
              this.$input[0].focus();
            } else {
              // select chip
              this.selectChip(index);
            }

            // Default handle click to focus on input
          } else {
            this.$input[0].focus();
          }
        }

        /**
         * Handle Chips Keydown
         * @param {Event} e
         */

      }, {
        key: "_handleInputFocus",


        /**
         * Handle Input Focus
         */
        value: function _handleInputFocus() {
          this.$el.addClass('focus');
        }

        /**
         * Handle Input Blur
         */

      }, {
        key: "_handleInputBlur",
        value: function _handleInputBlur() {
          this.$el.removeClass('focus');
        }

        /**
         * Handle Input Keydown
         * @param {Event} e
         */

      }, {
        key: "_handleInputKeydown",
        value: function _handleInputKeydown(e) {
          Chips._keydown = true;

          // enter
          if (e.keyCode === 13) {
            // Override enter if autocompleting.
            if (this.hasAutocomplete && this.autocomplete && this.autocomplete.isOpen) {
              return;
            }

            e.preventDefault();
            this.addChip({
              tag: this.$input[0].value
            });
            this.$input[0].value = '';

            // delete or left
          } else if ((e.keyCode === 8 || e.keyCode === 37) && this.$input[0].value === '' && this.chipsData.length) {
            e.preventDefault();
            this.selectChip(this.chipsData.length - 1);
          }
        }

        /**
         * Render Chip
         * @param {chip} chip
         * @return {Element}
         */

      }, {
        key: "_renderChip",
        value: function _renderChip(chip) {
          if (!chip.tag) {
            return;
          }

          var renderedChip = document.createElement('div');
          var closeIcon = document.createElement('i');
          renderedChip.classList.add('chip');
          renderedChip.textContent = chip.tag;
          renderedChip.setAttribute('tabindex', 0);
          $(closeIcon).addClass('material-icons close');
          closeIcon.textContent = 'close';

          // attach image if needed
          if (chip.image) {
            var img = document.createElement('img');
            img.setAttribute('src', chip.image);
            renderedChip.insertBefore(img, renderedChip.firstChild);
          }

          renderedChip.appendChild(closeIcon);
          return renderedChip;
        }

        /**
         * Render Chips
         */

      }, {
        key: "_renderChips",
        value: function _renderChips() {
          this.$chips.remove();
          for (var i = 0; i < this.chipsData.length; i++) {
            var chipEl = this._renderChip(this.chipsData[i]);
            this.$el.append(chipEl);
            this.$chips.add(chipEl);
          }

          // move input to end
          this.$el.append(this.$input[0]);
        }

        /**
         * Setup Autocomplete
         */

      }, {
        key: "_setupAutocomplete",
        value: function _setupAutocomplete() {
          var _this46 = this;

          this.options.autocompleteOptions.onAutocomplete = function (val) {
            _this46.addChip({
              tag: val
            });
            _this46.$input[0].value = '';
            _this46.$input[0].focus();
          };

          this.autocomplete = M.Autocomplete.init(this.$input[0], this.options.autocompleteOptions);
        }

        /**
         * Setup Input
         */

      }, {
        key: "_setupInput",
        value: function _setupInput() {
          this.$input = this.$el.find('input');
          if (!this.$input.length) {
            this.$input = $('<input></input>');
            this.$el.append(this.$input);
          }

          this.$input.addClass('input');
        }

        /**
         * Setup Label
         */

      }, {
        key: "_setupLabel",
        value: function _setupLabel() {
          this.$label = this.$el.find('label');
          if (this.$label.length) {
            this.$label.setAttribute('for', this.$input.attr('id'));
          }
        }

        /**
         * Set placeholder
         */

      }, {
        key: "_setPlaceholder",
        value: function _setPlaceholder() {
          if (this.chipsData !== undefined && !this.chipsData.length && this.options.placeholder) {
            $(this.$input).prop('placeholder', this.options.placeholder);
          } else if ((this.chipsData === undefined || !!this.chipsData.length) && this.options.secondaryPlaceholder) {
            $(this.$input).prop('placeholder', this.options.secondaryPlaceholder);
          }
        }

        /**
         * Check if chip is valid
         * @param {chip} chip
         */

      }, {
        key: "_isValid",
        value: function _isValid(chip) {
          if (chip.hasOwnProperty('tag') && chip.tag !== '') {
            var exists = false;
            for (var i = 0; i < this.chipsData.length; i++) {
              if (this.chipsData[i].tag === chip.tag) {
                exists = true;
                break;
              }
            }
            return !exists;
          }

          return false;
        }

        /**
         * Add chip
         * @param {chip} chip
         */

      }, {
        key: "addChip",
        value: function addChip(chip) {
          if (!this._isValid(chip) || this.chipsData.length >= this.options.limit) {
            return;
          }

          var renderedChip = this._renderChip(chip);
          this.$chips.add(renderedChip);
          this.chipsData.push(chip);
          $(this.$input).before(renderedChip);
          this._setPlaceholder();

          // fire chipAdd callback
          if (typeof this.options.onChipAdd === 'function') {
            this.options.onChipAdd.call(this, this.$el, renderedChip);
          }
        }

        /**
         * Delete chip
         * @param {Number} chip
         */

      }, {
        key: "deleteChip",
        value: function deleteChip(chipIndex) {
          var $chip = this.$chips.eq(chipIndex);
          this.$chips.eq(chipIndex).remove();
          this.$chips = this.$chips.filter(function (el) {
            return $(el).index() >= 0;
          });
          this.chipsData.splice(chipIndex, 1);
          this._setPlaceholder();

          // fire chipDelete callback
          if (typeof this.options.onChipDelete === 'function') {
            this.options.onChipDelete.call(this, this.$el, $chip[0]);
          }
        }

        /**
         * Select chip
         * @param {Number} chip
         */

      }, {
        key: "selectChip",
        value: function selectChip(chipIndex) {
          var $chip = this.$chips.eq(chipIndex);
          this._selectedChip = $chip;
          $chip[0].focus();

          // fire chipSelect callback
          if (typeof this.options.onChipSelect === 'function') {
            this.options.onChipSelect.call(this, this.$el, $chip[0]);
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Chips.__proto__ || Object.getPrototypeOf(Chips), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Chips;
        }
      }, {
        key: "_handleChipsKeydown",
        value: function _handleChipsKeydown(e) {
          Chips._keydown = true;

          var $chips = $(e.target).closest('.chips');
          var chipsKeydown = e.target && $chips.length;

          // Don't handle keydown inputs on input and textarea
          if ($(e.target).is('input, textarea') || !chipsKeydown) {
            return;
          }

          var currChips = $chips[0].M_Chips;

          // backspace and delete
          if (e.keyCode === 8 || e.keyCode === 46) {
            e.preventDefault();

            var selectIndex = currChips.chipsData.length;
            if (currChips._selectedChip) {
              var index = currChips._selectedChip.index();
              currChips.deleteChip(index);
              currChips._selectedChip = null;

              // Make sure selectIndex doesn't go negative
              selectIndex = Math.max(index - 1, 0);
            }

            if (currChips.chipsData.length) {
              currChips.selectChip(selectIndex);
            }

            // left arrow key
          } else if (e.keyCode === 37) {
            if (currChips._selectedChip) {
              var _selectIndex = currChips._selectedChip.index() - 1;
              if (_selectIndex < 0) {
                return;
              }
              currChips.selectChip(_selectIndex);
            }

            // right arrow key
          } else if (e.keyCode === 39) {
            if (currChips._selectedChip) {
              var _selectIndex2 = currChips._selectedChip.index() + 1;

              if (_selectIndex2 >= currChips.chipsData.length) {
                currChips.$input[0].focus();
              } else {
                currChips.selectChip(_selectIndex2);
              }
            }
          }
        }

        /**
         * Handle Chips Keyup
         * @param {Event} e
         */

      }, {
        key: "_handleChipsKeyup",
        value: function _handleChipsKeyup(e) {
          Chips._keydown = false;
        }

        /**
         * Handle Chips Blur
         * @param {Event} e
         */

      }, {
        key: "_handleChipsBlur",
        value: function _handleChipsBlur(e) {
          if (!Chips._keydown) {
            var $chips = $(e.target).closest('.chips');
            var currChips = $chips[0].M_Chips;

            currChips._selectedChip = null;
          }
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Chips;
    }(Component);

    /**
     * @static
     * @memberof Chips
     */


    Chips._keydown = false;

    M.Chips = Chips;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Chips, 'chips', 'M_Chips');
    }

    $(document).ready(function () {
      // Handle removal of static chips.
      $(document.body).on('click', '.chip .close', function () {
        var $chips = $(this).closest('.chips');
        if ($chips.length && $chips[0].M_Chips) {
          return;
        }
        $(this).closest('.chip').remove();
      });
    });
  })(cash);
  (function ($) {

    var _defaults = {
      top: 0,
      bottom: Infinity,
      offset: 0,
      onPositionChange: null
    };

    /**
     * @class
     *
     */

    var Pushpin = function (_Component13) {
      _inherits(Pushpin, _Component13);

      /**
       * Construct Pushpin instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Pushpin(el, options) {
        _classCallCheck(this, Pushpin);

        var _this47 = _possibleConstructorReturn(this, (Pushpin.__proto__ || Object.getPrototypeOf(Pushpin)).call(this, Pushpin, el, options));

        _this47.el.M_Pushpin = _this47;

        /**
         * Options for the modal
         * @member Pushpin#options
         */
        _this47.options = $.extend({}, Pushpin.defaults, options);

        _this47.originalOffset = _this47.el.offsetTop;
        Pushpin._pushpins.push(_this47);
        _this47._setupEventHandlers();
        _this47._updatePosition();
        return _this47;
      }

      _createClass(Pushpin, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this.el.style.top = null;
          this._removePinClasses();
          this._removeEventHandlers();

          // Remove pushpin Inst
          var index = Pushpin._pushpins.indexOf(this);
          Pushpin._pushpins.splice(index, 1);
        }
      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          document.addEventListener('scroll', Pushpin._updateElements);
        }
      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          document.removeEventListener('scroll', Pushpin._updateElements);
        }
      }, {
        key: "_updatePosition",
        value: function _updatePosition() {
          var scrolled = M.getDocumentScrollTop() + this.options.offset;

          if (this.options.top <= scrolled && this.options.bottom >= scrolled && !this.el.classList.contains('pinned')) {
            this._removePinClasses();
            this.el.style.top = this.options.offset + "px";
            this.el.classList.add('pinned');

            // onPositionChange callback
            if (typeof this.options.onPositionChange === 'function') {
              this.options.onPositionChange.call(this, 'pinned');
            }
          }

          // Add pin-top (when scrolled position is above top)
          if (scrolled < this.options.top && !this.el.classList.contains('pin-top')) {
            this._removePinClasses();
            this.el.style.top = 0;
            this.el.classList.add('pin-top');

            // onPositionChange callback
            if (typeof this.options.onPositionChange === 'function') {
              this.options.onPositionChange.call(this, 'pin-top');
            }
          }

          // Add pin-bottom (when scrolled position is below bottom)
          if (scrolled > this.options.bottom && !this.el.classList.contains('pin-bottom')) {
            this._removePinClasses();
            this.el.classList.add('pin-bottom');
            this.el.style.top = this.options.bottom - this.originalOffset + "px";

            // onPositionChange callback
            if (typeof this.options.onPositionChange === 'function') {
              this.options.onPositionChange.call(this, 'pin-bottom');
            }
          }
        }
      }, {
        key: "_removePinClasses",
        value: function _removePinClasses() {
          // IE 11 bug (can't remove multiple classes in one line)
          this.el.classList.remove('pin-top');
          this.el.classList.remove('pinned');
          this.el.classList.remove('pin-bottom');
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Pushpin.__proto__ || Object.getPrototypeOf(Pushpin), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Pushpin;
        }
      }, {
        key: "_updateElements",
        value: function _updateElements() {
          for (var elIndex in Pushpin._pushpins) {
            var pInstance = Pushpin._pushpins[elIndex];
            pInstance._updatePosition();
          }
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Pushpin;
    }(Component);

    /**
     * @static
     * @memberof Pushpin
     */


    Pushpin._pushpins = [];

    M.Pushpin = Pushpin;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Pushpin, 'pushpin', 'M_Pushpin');
    }
  })(cash);
  (function ($, anim) {

    var _defaults = {
      direction: 'top',
      hoverEnabled: true,
      toolbarEnabled: false
    };

    $.fn.reverse = [].reverse;

    /**
     * @class
     *
     */

    var FloatingActionButton = function (_Component14) {
      _inherits(FloatingActionButton, _Component14);

      /**
       * Construct FloatingActionButton instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function FloatingActionButton(el, options) {
        _classCallCheck(this, FloatingActionButton);

        var _this48 = _possibleConstructorReturn(this, (FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton)).call(this, FloatingActionButton, el, options));

        _this48.el.M_FloatingActionButton = _this48;

        /**
         * Options for the fab
         * @member FloatingActionButton#options
         * @prop {Boolean} [direction] - Direction fab menu opens
         * @prop {Boolean} [hoverEnabled=true] - Enable hover vs click
         * @prop {Boolean} [toolbarEnabled=false] - Enable toolbar transition
         */
        _this48.options = $.extend({}, FloatingActionButton.defaults, options);

        _this48.isOpen = false;
        _this48.$anchor = _this48.$el.children('a').first();
        _this48.$menu = _this48.$el.children('ul').first();
        _this48.$floatingBtns = _this48.$el.find('ul .btn-floating');
        _this48.$floatingBtnsReverse = _this48.$el.find('ul .btn-floating').reverse();
        _this48.offsetY = 0;
        _this48.offsetX = 0;

        _this48.$el.addClass("direction-" + _this48.options.direction);
        if (_this48.options.direction === 'top') {
          _this48.offsetY = 40;
        } else if (_this48.options.direction === 'right') {
          _this48.offsetX = -40;
        } else if (_this48.options.direction === 'bottom') {
          _this48.offsetY = -40;
        } else {
          _this48.offsetX = 40;
        }
        _this48._setupEventHandlers();
        return _this48;
      }

      _createClass(FloatingActionButton, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.el.M_FloatingActionButton = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleFABClickBound = this._handleFABClick.bind(this);
          this._handleOpenBound = this.open.bind(this);
          this._handleCloseBound = this.close.bind(this);

          if (this.options.hoverEnabled && !this.options.toolbarEnabled) {
            this.el.addEventListener('mouseenter', this._handleOpenBound);
            this.el.addEventListener('mouseleave', this._handleCloseBound);
          } else {
            this.el.addEventListener('click', this._handleFABClickBound);
          }
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          if (this.options.hoverEnabled && !this.options.toolbarEnabled) {
            this.el.removeEventListener('mouseenter', this._handleOpenBound);
            this.el.removeEventListener('mouseleave', this._handleCloseBound);
          } else {
            this.el.removeEventListener('click', this._handleFABClickBound);
          }
        }

        /**
         * Handle FAB Click
         */

      }, {
        key: "_handleFABClick",
        value: function _handleFABClick() {
          if (this.isOpen) {
            this.close();
          } else {
            this.open();
          }
        }

        /**
         * Handle Document Click
         * @param {Event} e
         */

      }, {
        key: "_handleDocumentClick",
        value: function _handleDocumentClick(e) {
          if (!$(e.target).closest(this.$menu).length) {
            this.close();
          }
        }

        /**
         * Open FAB
         */

      }, {
        key: "open",
        value: function open() {
          if (this.isOpen) {
            return;
          }

          if (this.options.toolbarEnabled) {
            this._animateInToolbar();
          } else {
            this._animateInFAB();
          }
          this.isOpen = true;
        }

        /**
         * Close FAB
         */

      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen) {
            return;
          }

          if (this.options.toolbarEnabled) {
            window.removeEventListener('scroll', this._handleCloseBound, true);
            document.body.removeEventListener('click', this._handleDocumentClickBound, true);
            this._animateOutToolbar();
          } else {
            this._animateOutFAB();
          }
          this.isOpen = false;
        }

        /**
         * Classic FAB Menu open
         */

      }, {
        key: "_animateInFAB",
        value: function _animateInFAB() {
          var _this49 = this;

          this.$el.addClass('active');

          var time = 0;
          this.$floatingBtnsReverse.each(function (el) {
            anim({
              targets: el,
              opacity: 1,
              scale: [0.4, 1],
              translateY: [_this49.offsetY, 0],
              translateX: [_this49.offsetX, 0],
              duration: 275,
              delay: time,
              easing: 'easeInOutQuad'
            });
            time += 40;
          });
        }

        /**
         * Classic FAB Menu close
         */

      }, {
        key: "_animateOutFAB",
        value: function _animateOutFAB() {
          var _this50 = this;

          this.$floatingBtnsReverse.each(function (el) {
            anim.remove(el);
            anim({
              targets: el,
              opacity: 0,
              scale: 0.4,
              translateY: _this50.offsetY,
              translateX: _this50.offsetX,
              duration: 175,
              easing: 'easeOutQuad',
              complete: function () {
                _this50.$el.removeClass('active');
              }
            });
          });
        }

        /**
         * Toolbar transition Menu open
         */

      }, {
        key: "_animateInToolbar",
        value: function _animateInToolbar() {
          var _this51 = this;

          var scaleFactor = void 0;
          var windowWidth = window.innerWidth;
          var windowHeight = window.innerHeight;
          var btnRect = this.el.getBoundingClientRect();
          var backdrop = $('<div class="fab-backdrop"></div>');
          var fabColor = this.$anchor.css('background-color');
          this.$anchor.append(backdrop);

          this.offsetX = btnRect.left - windowWidth / 2 + btnRect.width / 2;
          this.offsetY = windowHeight - btnRect.bottom;
          scaleFactor = windowWidth / backdrop[0].clientWidth;
          this.btnBottom = btnRect.bottom;
          this.btnLeft = btnRect.left;
          this.btnWidth = btnRect.width;

          // Set initial state
          this.$el.addClass('active');
          this.$el.css({
            'text-align': 'center',
            width: '100%',
            bottom: 0,
            left: 0,
            transform: 'translateX(' + this.offsetX + 'px)',
            transition: 'none'
          });
          this.$anchor.css({
            transform: 'translateY(' + -this.offsetY + 'px)',
            transition: 'none'
          });
          backdrop.css({
            'background-color': fabColor
          });

          setTimeout(function () {
            _this51.$el.css({
              transform: '',
              transition: 'transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s'
            });
            _this51.$anchor.css({
              overflow: 'visible',
              transform: '',
              transition: 'transform .2s'
            });

            setTimeout(function () {
              _this51.$el.css({
                overflow: 'hidden',
                'background-color': fabColor
              });
              backdrop.css({
                transform: 'scale(' + scaleFactor + ')',
                transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
              });
              _this51.$menu.children('li').children('a').css({
                opacity: 1
              });

              // Scroll to close.
              _this51._handleDocumentClickBound = _this51._handleDocumentClick.bind(_this51);
              window.addEventListener('scroll', _this51._handleCloseBound, true);
              document.body.addEventListener('click', _this51._handleDocumentClickBound, true);
            }, 100);
          }, 0);
        }

        /**
         * Toolbar transition Menu close
         */

      }, {
        key: "_animateOutToolbar",
        value: function _animateOutToolbar() {
          var _this52 = this;

          var windowWidth = window.innerWidth;
          var windowHeight = window.innerHeight;
          var backdrop = this.$el.find('.fab-backdrop');
          var fabColor = this.$anchor.css('background-color');

          this.offsetX = this.btnLeft - windowWidth / 2 + this.btnWidth / 2;
          this.offsetY = windowHeight - this.btnBottom;

          // Hide backdrop
          this.$el.removeClass('active');
          this.$el.css({
            'background-color': 'transparent',
            transition: 'none'
          });
          this.$anchor.css({
            transition: 'none'
          });
          backdrop.css({
            transform: 'scale(0)',
            'background-color': fabColor
          });
          this.$menu.children('li').children('a').css({
            opacity: ''
          });

          setTimeout(function () {
            backdrop.remove();

            // Set initial state.
            _this52.$el.css({
              'text-align': '',
              width: '',
              bottom: '',
              left: '',
              overflow: '',
              'background-color': '',
              transform: 'translate3d(' + -_this52.offsetX + 'px,0,0)'
            });
            _this52.$anchor.css({
              overflow: '',
              transform: 'translate3d(0,' + _this52.offsetY + 'px,0)'
            });

            setTimeout(function () {
              _this52.$el.css({
                transform: 'translate3d(0,0,0)',
                transition: 'transform .2s'
              });
              _this52.$anchor.css({
                transform: 'translate3d(0,0,0)',
                transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'
              });
            }, 20);
          }, 200);
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(FloatingActionButton.__proto__ || Object.getPrototypeOf(FloatingActionButton), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_FloatingActionButton;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return FloatingActionButton;
    }(Component);

    M.FloatingActionButton = FloatingActionButton;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(FloatingActionButton, 'floatingActionButton', 'M_FloatingActionButton');
    }
  })(cash, M.anime);
  (function ($) {

    var _defaults = {
      // Close when date is selected
      autoClose: false,

      // the default output format for the input field value
      format: 'mmm dd, yyyy',

      // Used to create date object from current input string
      parse: null,

      // The initial date to view when first opened
      defaultDate: null,

      // Make the `defaultDate` the initial selected value
      setDefaultDate: false,

      disableWeekends: false,

      disableDayFn: null,

      // First day of week (0: Sunday, 1: Monday etc)
      firstDay: 0,

      // The earliest date that can be selected
      minDate: null,
      // Thelatest date that can be selected
      maxDate: null,

      // Number of years either side, or array of upper/lower range
      yearRange: 10,

      // used internally (don't config outside)
      minYear: 0,
      maxYear: 9999,
      minMonth: undefined,
      maxMonth: undefined,

      startRange: null,
      endRange: null,

      isRTL: false,

      // Render the month after year in the calendar title
      showMonthAfterYear: false,

      // Render days of the calendar grid that fall in the next or previous month
      showDaysInNextAndPreviousMonths: false,

      // Specify a DOM element to render the calendar in
      container: null,

      // Show clear button
      showClearBtn: false,

      // internationalization
      i18n: {
        cancel: 'Cancel',
        clear: 'Clear',
        done: 'Ok',
        previousMonth: '',
        nextMonth: '',
        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
        monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
        weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
        weekdaysAbbrev: ['S', 'M', 'T', 'W', 'T', 'F', 'S']
      },

      // events array
      events: [],

      // callback function
      onSelect: null,
      onOpen: null,
      onClose: null,
      onDraw: null
    };

    /**
     * @class
     *
     */

    var Datepicker = function (_Component15) {
      _inherits(Datepicker, _Component15);

      /**
       * Construct Datepicker instance and set up overlay
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Datepicker(el, options) {
        _classCallCheck(this, Datepicker);

        var _this53 = _possibleConstructorReturn(this, (Datepicker.__proto__ || Object.getPrototypeOf(Datepicker)).call(this, Datepicker, el, options));

        _this53.el.M_Datepicker = _this53;

        _this53.options = $.extend({}, Datepicker.defaults, options);

        // make sure i18n defaults are not lost when only few i18n option properties are passed
        if (!!options && options.hasOwnProperty('i18n') && typeof options.i18n === 'object') {
          _this53.options.i18n = $.extend({}, Datepicker.defaults.i18n, options.i18n);
        }

        // Remove time component from minDate and maxDate options
        if (_this53.options.minDate) _this53.options.minDate.setHours(0, 0, 0, 0);
        if (_this53.options.maxDate) _this53.options.maxDate.setHours(0, 0, 0, 0);

        _this53.id = M.guid();

        _this53._setupVariables();
        _this53._insertHTMLIntoDOM();
        _this53._setupModal();

        _this53._setupEventHandlers();

        if (!_this53.options.defaultDate) {
          _this53.options.defaultDate = new Date(Date.parse(_this53.el.value));
        }

        var defDate = _this53.options.defaultDate;
        if (Datepicker._isDate(defDate)) {
          if (_this53.options.setDefaultDate) {
            _this53.setDate(defDate, true);
            _this53.setInputValue();
          } else {
            _this53.gotoDate(defDate);
          }
        } else {
          _this53.gotoDate(new Date());
        }

        /**
         * Describes open/close state of datepicker
         * @type {Boolean}
         */
        _this53.isOpen = false;
        return _this53;
      }

      _createClass(Datepicker, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.modal.destroy();
          $(this.modalEl).remove();
          this.destroySelects();
          this.el.M_Datepicker = undefined;
        }
      }, {
        key: "destroySelects",
        value: function destroySelects() {
          var oldYearSelect = this.calendarEl.querySelector('.orig-select-year');
          if (oldYearSelect) {
            M.FormSelect.getInstance(oldYearSelect).destroy();
          }
          var oldMonthSelect = this.calendarEl.querySelector('.orig-select-month');
          if (oldMonthSelect) {
            M.FormSelect.getInstance(oldMonthSelect).destroy();
          }
        }
      }, {
        key: "_insertHTMLIntoDOM",
        value: function _insertHTMLIntoDOM() {
          if (this.options.showClearBtn) {
            $(this.clearBtn).css({ visibility: '' });
            this.clearBtn.innerHTML = this.options.i18n.clear;
          }

          this.doneBtn.innerHTML = this.options.i18n.done;
          this.cancelBtn.innerHTML = this.options.i18n.cancel;

          if (this.options.container) {
            this.$modalEl.appendTo(this.options.container);
          } else {
            this.$modalEl.insertBefore(this.el);
          }
        }
      }, {
        key: "_setupModal",
        value: function _setupModal() {
          var _this54 = this;

          this.modalEl.id = 'modal-' + this.id;
          this.modal = M.Modal.init(this.modalEl, {
            onCloseEnd: function () {
              _this54.isOpen = false;
            }
          });
        }
      }, {
        key: "toString",
        value: function toString(format) {
          var _this55 = this;

          format = format || this.options.format;
          if (!Datepicker._isDate(this.date)) {
            return '';
          }

          var formatArray = format.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
          var formattedDate = formatArray.map(function (label) {
            if (_this55.formats[label]) {
              return _this55.formats[label]();
            }

            return label;
          }).join('');
          return formattedDate;
        }
      }, {
        key: "setDate",
        value: function setDate(date, preventOnSelect) {
          if (!date) {
            this.date = null;
            this._renderDateDisplay();
            return this.draw();
          }
          if (typeof date === 'string') {
            date = new Date(Date.parse(date));
          }
          if (!Datepicker._isDate(date)) {
            return;
          }

          var min = this.options.minDate,
              max = this.options.maxDate;

          if (Datepicker._isDate(min) && date < min) {
            date = min;
          } else if (Datepicker._isDate(max) && date > max) {
            date = max;
          }

          this.date = new Date(date.getTime());

          this._renderDateDisplay();

          Datepicker._setToStartOfDay(this.date);
          this.gotoDate(this.date);

          if (!preventOnSelect && typeof this.options.onSelect === 'function') {
            this.options.onSelect.call(this, this.date);
          }
        }
      }, {
        key: "setInputValue",
        value: function setInputValue() {
          this.el.value = this.toString();
          this.$el.trigger('change', { firedBy: this });
        }
      }, {
        key: "_renderDateDisplay",
        value: function _renderDateDisplay() {
          var displayDate = Datepicker._isDate(this.date) ? this.date : new Date();
          var i18n = this.options.i18n;
          var day = i18n.weekdaysShort[displayDate.getDay()];
          var month = i18n.monthsShort[displayDate.getMonth()];
          var date = displayDate.getDate();
          this.yearTextEl.innerHTML = displayDate.getFullYear();
          this.dateTextEl.innerHTML = day + ", " + month + " " + date;
        }

        /**
         * change view to a specific date
         */

      }, {
        key: "gotoDate",
        value: function gotoDate(date) {
          var newCalendar = true;

          if (!Datepicker._isDate(date)) {
            return;
          }

          if (this.calendars) {
            var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year, this.calendars[this.calendars.length - 1].month, 1),
                visibleDate = date.getTime();
            // get the end of the month
            lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
            lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
            newCalendar = visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate;
          }

          if (newCalendar) {
            this.calendars = [{
              month: date.getMonth(),
              year: date.getFullYear()
            }];
          }

          this.adjustCalendars();
        }
      }, {
        key: "adjustCalendars",
        value: function adjustCalendars() {
          this.calendars[0] = this.adjustCalendar(this.calendars[0]);
          this.draw();
        }
      }, {
        key: "adjustCalendar",
        value: function adjustCalendar(calendar) {
          if (calendar.month < 0) {
            calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
            calendar.month += 12;
          }
          if (calendar.month > 11) {
            calendar.year += Math.floor(Math.abs(calendar.month) / 12);
            calendar.month -= 12;
          }
          return calendar;
        }
      }, {
        key: "nextMonth",
        value: function nextMonth() {
          this.calendars[0].month++;
          this.adjustCalendars();
        }
      }, {
        key: "prevMonth",
        value: function prevMonth() {
          this.calendars[0].month--;
          this.adjustCalendars();
        }
      }, {
        key: "render",
        value: function render(year, month, randId) {
          var opts = this.options,
              now = new Date(),
              days = Datepicker._getDaysInMonth(year, month),
              before = new Date(year, month, 1).getDay(),
              data = [],
              row = [];
          Datepicker._setToStartOfDay(now);
          if (opts.firstDay > 0) {
            before -= opts.firstDay;
            if (before < 0) {
              before += 7;
            }
          }
          var previousMonth = month === 0 ? 11 : month - 1,
              nextMonth = month === 11 ? 0 : month + 1,
              yearOfPreviousMonth = month === 0 ? year - 1 : year,
              yearOfNextMonth = month === 11 ? year + 1 : year,
              daysInPreviousMonth = Datepicker._getDaysInMonth(yearOfPreviousMonth, previousMonth);
          var cells = days + before,
              after = cells;
          while (after > 7) {
            after -= 7;
          }
          cells += 7 - after;
          var isWeekSelected = false;
          for (var i = 0, r = 0; i < cells; i++) {
            var day = new Date(year, month, 1 + (i - before)),
                isSelected = Datepicker._isDate(this.date) ? Datepicker._compareDates(day, this.date) : false,
                isToday = Datepicker._compareDates(day, now),
                hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                isEmpty = i < before || i >= days + before,
                dayNumber = 1 + (i - before),
                monthNumber = month,
                yearNumber = year,
                isStartRange = opts.startRange && Datepicker._compareDates(opts.startRange, day),
                isEndRange = opts.endRange && Datepicker._compareDates(opts.endRange, day),
                isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                isDisabled = opts.minDate && day < opts.minDate || opts.maxDate && day > opts.maxDate || opts.disableWeekends && Datepicker._isWeekend(day) || opts.disableDayFn && opts.disableDayFn(day);

            if (isEmpty) {
              if (i < before) {
                dayNumber = daysInPreviousMonth + dayNumber;
                monthNumber = previousMonth;
                yearNumber = yearOfPreviousMonth;
              } else {
                dayNumber = dayNumber - days;
                monthNumber = nextMonth;
                yearNumber = yearOfNextMonth;
              }
            }

            var dayConfig = {
              day: dayNumber,
              month: monthNumber,
              year: yearNumber,
              hasEvent: hasEvent,
              isSelected: isSelected,
              isToday: isToday,
              isDisabled: isDisabled,
              isEmpty: isEmpty,
              isStartRange: isStartRange,
              isEndRange: isEndRange,
              isInRange: isInRange,
              showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths
            };

            row.push(this.renderDay(dayConfig));

            if (++r === 7) {
              data.push(this.renderRow(row, opts.isRTL, isWeekSelected));
              row = [];
              r = 0;
              isWeekSelected = false;
            }
          }
          return this.renderTable(opts, data, randId);
        }
      }, {
        key: "renderDay",
        value: function renderDay(opts) {
          var arr = [];
          var ariaSelected = 'false';
          if (opts.isEmpty) {
            if (opts.showDaysInNextAndPreviousMonths) {
              arr.push('is-outside-current-month');
              arr.push('is-selection-disabled');
            } else {
              return '<td class="is-empty"></td>';
            }
          }
          if (opts.isDisabled) {
            arr.push('is-disabled');
          }

          if (opts.isToday) {
            arr.push('is-today');
          }
          if (opts.isSelected) {
            arr.push('is-selected');
            ariaSelected = 'true';
          }
          if (opts.hasEvent) {
            arr.push('has-event');
          }
          if (opts.isInRange) {
            arr.push('is-inrange');
          }
          if (opts.isStartRange) {
            arr.push('is-startrange');
          }
          if (opts.isEndRange) {
            arr.push('is-endrange');
          }
          return "<td data-day=\"" + opts.day + "\" class=\"" + arr.join(' ') + "\" aria-selected=\"" + ariaSelected + "\">" + ("<button class=\"datepicker-day-button\" type=\"button\" data-year=\"" + opts.year + "\" data-month=\"" + opts.month + "\" data-day=\"" + opts.day + "\">" + opts.day + "</button>") + '</td>';
        }
      }, {
        key: "renderRow",
        value: function renderRow(days, isRTL, isRowSelected) {
          return '<tr class="datepicker-row' + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
        }
      }, {
        key: "renderTable",
        value: function renderTable(opts, data, randId) {
          return '<div class="datepicker-table-wrapper"><table cellpadding="0" cellspacing="0" class="datepicker-table" role="grid" aria-labelledby="' + randId + '">' + this.renderHead(opts) + this.renderBody(data) + '</table></div>';
        }
      }, {
        key: "renderHead",
        value: function renderHead(opts) {
          var i = void 0,
              arr = [];
          for (i = 0; i < 7; i++) {
            arr.push("<th scope=\"col\"><abbr title=\"" + this.renderDayName(opts, i) + "\">" + this.renderDayName(opts, i, true) + "</abbr></th>");
          }
          return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
        }
      }, {
        key: "renderBody",
        value: function renderBody(rows) {
          return '<tbody>' + rows.join('') + '</tbody>';
        }
      }, {
        key: "renderTitle",
        value: function renderTitle(instance, c, year, month, refYear, randId) {
          var i = void 0,
              j = void 0,
              arr = void 0,
              opts = this.options,
              isMinYear = year === opts.minYear,
              isMaxYear = year === opts.maxYear,
              html = '<div id="' + randId + '" class="datepicker-controls" role="heading" aria-live="assertive">',
              monthHtml = void 0,
              yearHtml = void 0,
              prev = true,
              next = true;

          for (arr = [], i = 0; i < 12; i++) {
            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : '') + (isMinYear && i < opts.minMonth || isMaxYear && i > opts.maxMonth ? 'disabled="disabled"' : '') + '>' + opts.i18n.months[i] + '</option>');
          }

          monthHtml = '<select class="datepicker-select orig-select-month" tabindex="-1">' + arr.join('') + '</select>';

          if ($.isArray(opts.yearRange)) {
            i = opts.yearRange[0];
            j = opts.yearRange[1] + 1;
          } else {
            i = year - opts.yearRange;
            j = 1 + year + opts.yearRange;
          }

          for (arr = []; i < j && i <= opts.maxYear; i++) {
            if (i >= opts.minYear) {
              arr.push("<option value=\"" + i + "\" " + (i === year ? 'selected="selected"' : '') + ">" + i + "</option>");
            }
          }

          yearHtml = "<select class=\"datepicker-select orig-select-year\" tabindex=\"-1\">" + arr.join('') + "</select>";

          var leftArrow = '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"/><path d="M0-.5h24v24H0z" fill="none"/></svg>';
          html += "<button class=\"month-prev" + (prev ? '' : ' is-disabled') + "\" type=\"button\">" + leftArrow + "</button>";

          html += '<div class="selects-container">';
          if (opts.showMonthAfterYear) {
            html += yearHtml + monthHtml;
          } else {
            html += monthHtml + yearHtml;
          }
          html += '</div>';

          if (isMinYear && (month === 0 || opts.minMonth >= month)) {
            prev = false;
          }

          if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
            next = false;
          }

          var rightArrow = '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"/><path d="M0-.25h24v24H0z" fill="none"/></svg>';
          html += "<button class=\"month-next" + (next ? '' : ' is-disabled') + "\" type=\"button\">" + rightArrow + "</button>";

          return html += '</div>';
        }

        /**
         * refresh the HTML
         */

      }, {
        key: "draw",
        value: function draw(force) {
          if (!this.isOpen && !force) {
            return;
          }
          var opts = this.options,
              minYear = opts.minYear,
              maxYear = opts.maxYear,
              minMonth = opts.minMonth,
              maxMonth = opts.maxMonth,
              html = '',
              randId = void 0;

          if (this._y <= minYear) {
            this._y = minYear;
            if (!isNaN(minMonth) && this._m < minMonth) {
              this._m = minMonth;
            }
          }
          if (this._y >= maxYear) {
            this._y = maxYear;
            if (!isNaN(maxMonth) && this._m > maxMonth) {
              this._m = maxMonth;
            }
          }

          randId = 'datepicker-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

          for (var c = 0; c < 1; c++) {
            this._renderDateDisplay();
            html += this.renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId);
          }

          this.destroySelects();

          this.calendarEl.innerHTML = html;

          // Init Materialize Select
          var yearSelect = this.calendarEl.querySelector('.orig-select-year');
          var monthSelect = this.calendarEl.querySelector('.orig-select-month');
          M.FormSelect.init(yearSelect, {
            classes: 'select-year',
            dropdownOptions: { container: document.body, constrainWidth: false }
          });
          M.FormSelect.init(monthSelect, {
            classes: 'select-month',
            dropdownOptions: { container: document.body, constrainWidth: false }
          });

          // Add change handlers for select
          yearSelect.addEventListener('change', this._handleYearChange.bind(this));
          monthSelect.addEventListener('change', this._handleMonthChange.bind(this));

          if (typeof this.options.onDraw === 'function') {
            this.options.onDraw(this);
          }
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
          this._handleInputClickBound = this._handleInputClick.bind(this);
          this._handleInputChangeBound = this._handleInputChange.bind(this);
          this._handleCalendarClickBound = this._handleCalendarClick.bind(this);
          this._finishSelectionBound = this._finishSelection.bind(this);
          this._handleMonthChange = this._handleMonthChange.bind(this);
          this._closeBound = this.close.bind(this);

          this.el.addEventListener('click', this._handleInputClickBound);
          this.el.addEventListener('keydown', this._handleInputKeydownBound);
          this.el.addEventListener('change', this._handleInputChangeBound);
          this.calendarEl.addEventListener('click', this._handleCalendarClickBound);
          this.doneBtn.addEventListener('click', this._finishSelectionBound);
          this.cancelBtn.addEventListener('click', this._closeBound);

          if (this.options.showClearBtn) {
            this._handleClearClickBound = this._handleClearClick.bind(this);
            this.clearBtn.addEventListener('click', this._handleClearClickBound);
          }
        }
      }, {
        key: "_setupVariables",
        value: function _setupVariables() {
          var _this56 = this;

          this.$modalEl = $(Datepicker._template);
          this.modalEl = this.$modalEl[0];

          this.calendarEl = this.modalEl.querySelector('.datepicker-calendar');

          this.yearTextEl = this.modalEl.querySelector('.year-text');
          this.dateTextEl = this.modalEl.querySelector('.date-text');
          if (this.options.showClearBtn) {
            this.clearBtn = this.modalEl.querySelector('.datepicker-clear');
          }
          this.doneBtn = this.modalEl.querySelector('.datepicker-done');
          this.cancelBtn = this.modalEl.querySelector('.datepicker-cancel');

          this.formats = {
            d: function () {
              return _this56.date.getDate();
            },
            dd: function () {
              var d = _this56.date.getDate();
              return (d < 10 ? '0' : '') + d;
            },
            ddd: function () {
              return _this56.options.i18n.weekdaysShort[_this56.date.getDay()];
            },
            dddd: function () {
              return _this56.options.i18n.weekdays[_this56.date.getDay()];
            },
            m: function () {
              return _this56.date.getMonth() + 1;
            },
            mm: function () {
              var m = _this56.date.getMonth() + 1;
              return (m < 10 ? '0' : '') + m;
            },
            mmm: function () {
              return _this56.options.i18n.monthsShort[_this56.date.getMonth()];
            },
            mmmm: function () {
              return _this56.options.i18n.months[_this56.date.getMonth()];
            },
            yy: function () {
              return ('' + _this56.date.getFullYear()).slice(2);
            },
            yyyy: function () {
              return _this56.date.getFullYear();
            }
          };
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('click', this._handleInputClickBound);
          this.el.removeEventListener('keydown', this._handleInputKeydownBound);
          this.el.removeEventListener('change', this._handleInputChangeBound);
          this.calendarEl.removeEventListener('click', this._handleCalendarClickBound);
        }
      }, {
        key: "_handleInputClick",
        value: function _handleInputClick() {
          this.open();
        }
      }, {
        key: "_handleInputKeydown",
        value: function _handleInputKeydown(e) {
          if (e.which === M.keys.ENTER) {
            e.preventDefault();
            this.open();
          }
        }
      }, {
        key: "_handleCalendarClick",
        value: function _handleCalendarClick(e) {
          if (!this.isOpen) {
            return;
          }

          var $target = $(e.target);
          if (!$target.hasClass('is-disabled')) {
            if ($target.hasClass('datepicker-day-button') && !$target.hasClass('is-empty') && !$target.parent().hasClass('is-disabled')) {
              this.setDate(new Date(e.target.getAttribute('data-year'), e.target.getAttribute('data-month'), e.target.getAttribute('data-day')));
              if (this.options.autoClose) {
                this._finishSelection();
              }
            } else if ($target.closest('.month-prev').length) {
              this.prevMonth();
            } else if ($target.closest('.month-next').length) {
              this.nextMonth();
            }
          }
        }
      }, {
        key: "_handleClearClick",
        value: function _handleClearClick() {
          this.date = null;
          this.setInputValue();
          this.close();
        }
      }, {
        key: "_handleMonthChange",
        value: function _handleMonthChange(e) {
          this.gotoMonth(e.target.value);
        }
      }, {
        key: "_handleYearChange",
        value: function _handleYearChange(e) {
          this.gotoYear(e.target.value);
        }

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */

      }, {
        key: "gotoMonth",
        value: function gotoMonth(month) {
          if (!isNaN(month)) {
            this.calendars[0].month = parseInt(month, 10);
            this.adjustCalendars();
          }
        }

        /**
         * change view to a specific full year (e.g. "2012")
         */

      }, {
        key: "gotoYear",
        value: function gotoYear(year) {
          if (!isNaN(year)) {
            this.calendars[0].year = parseInt(year, 10);
            this.adjustCalendars();
          }
        }
      }, {
        key: "_handleInputChange",
        value: function _handleInputChange(e) {
          var date = void 0;

          // Prevent change event from being fired when triggered by the plugin
          if (e.firedBy === this) {
            return;
          }
          if (this.options.parse) {
            date = this.options.parse(this.el.value, this.options.format);
          } else {
            date = new Date(Date.parse(this.el.value));
          }

          if (Datepicker._isDate(date)) {
            this.setDate(date);
          }
        }
      }, {
        key: "renderDayName",
        value: function renderDayName(opts, day, abbr) {
          day += opts.firstDay;
          while (day >= 7) {
            day -= 7;
          }
          return abbr ? opts.i18n.weekdaysAbbrev[day] : opts.i18n.weekdays[day];
        }

        /**
         * Set input value to the selected date and close Datepicker
         */

      }, {
        key: "_finishSelection",
        value: function _finishSelection() {
          this.setInputValue();
          this.close();
        }

        /**
         * Open Datepicker
         */

      }, {
        key: "open",
        value: function open() {
          if (this.isOpen) {
            return;
          }

          this.isOpen = true;
          if (typeof this.options.onOpen === 'function') {
            this.options.onOpen.call(this);
          }
          this.draw();
          this.modal.open();
          return this;
        }

        /**
         * Close Datepicker
         */

      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen) {
            return;
          }

          this.isOpen = false;
          if (typeof this.options.onClose === 'function') {
            this.options.onClose.call(this);
          }
          this.modal.close();
          return this;
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Datepicker.__proto__ || Object.getPrototypeOf(Datepicker), "init", this).call(this, this, els, options);
        }
      }, {
        key: "_isDate",
        value: function _isDate(obj) {
          return (/Date/.test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime())
          );
        }
      }, {
        key: "_isWeekend",
        value: function _isWeekend(date) {
          var day = date.getDay();
          return day === 0 || day === 6;
        }
      }, {
        key: "_setToStartOfDay",
        value: function _setToStartOfDay(date) {
          if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);
        }
      }, {
        key: "_getDaysInMonth",
        value: function _getDaysInMonth(year, month) {
          return [31, Datepicker._isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
        }
      }, {
        key: "_isLeapYear",
        value: function _isLeapYear(year) {
          // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        }
      }, {
        key: "_compareDates",
        value: function _compareDates(a, b) {
          // weak date comparison (use setToStartOfDay(date) to ensure correct result)
          return a.getTime() === b.getTime();
        }
      }, {
        key: "_setToStartOfDay",
        value: function _setToStartOfDay(date) {
          if (Datepicker._isDate(date)) date.setHours(0, 0, 0, 0);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Datepicker;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Datepicker;
    }(Component);

    Datepicker._template = ['<div class= "modal datepicker-modal">', '<div class="modal-content datepicker-container">', '<div class="datepicker-date-display">', '<span class="year-text"></span>', '<span class="date-text"></span>', '</div>', '<div class="datepicker-calendar-container">', '<div class="datepicker-calendar"></div>', '<div class="datepicker-footer">', '<button class="btn-flat datepicker-clear waves-effect" style="visibility: hidden;" type="button"></button>', '<div class="confirmation-btns">', '<button class="btn-flat datepicker-cancel waves-effect" type="button"></button>', '<button class="btn-flat datepicker-done waves-effect" type="button"></button>', '</div>', '</div>', '</div>', '</div>', '</div>'].join('');

    M.Datepicker = Datepicker;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Datepicker, 'datepicker', 'M_Datepicker');
    }
  })(cash);
  (function ($) {

    var _defaults = {
      dialRadius: 135,
      outerRadius: 105,
      innerRadius: 70,
      tickRadius: 20,
      duration: 350,
      container: null,
      defaultTime: 'now', // default time, 'now' or '13:14' e.g.
      fromNow: 0, // Millisecond offset from the defaultTime
      showClearBtn: false,

      // internationalization
      i18n: {
        cancel: 'Cancel',
        clear: 'Clear',
        done: 'Ok'
      },

      autoClose: false, // auto close when minute is selected
      twelveHour: true, // change to 12 hour AM/PM clock from 24 hour
      vibrate: true, // vibrate the device when dragging clock hand

      // Callbacks
      onOpenStart: null,
      onOpenEnd: null,
      onCloseStart: null,
      onCloseEnd: null,
      onSelect: null
    };

    /**
     * @class
     *
     */

    var Timepicker = function (_Component16) {
      _inherits(Timepicker, _Component16);

      function Timepicker(el, options) {
        _classCallCheck(this, Timepicker);

        var _this57 = _possibleConstructorReturn(this, (Timepicker.__proto__ || Object.getPrototypeOf(Timepicker)).call(this, Timepicker, el, options));

        _this57.el.M_Timepicker = _this57;

        _this57.options = $.extend({}, Timepicker.defaults, options);

        _this57.id = M.guid();
        _this57._insertHTMLIntoDOM();
        _this57._setupModal();
        _this57._setupVariables();
        _this57._setupEventHandlers();

        _this57._clockSetup();
        _this57._pickerSetup();
        return _this57;
      }

      _createClass(Timepicker, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.modal.destroy();
          $(this.modalEl).remove();
          this.el.M_Timepicker = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleInputKeydownBound = this._handleInputKeydown.bind(this);
          this._handleInputClickBound = this._handleInputClick.bind(this);
          this._handleClockClickStartBound = this._handleClockClickStart.bind(this);
          this._handleDocumentClickMoveBound = this._handleDocumentClickMove.bind(this);
          this._handleDocumentClickEndBound = this._handleDocumentClickEnd.bind(this);

          this.el.addEventListener('click', this._handleInputClickBound);
          this.el.addEventListener('keydown', this._handleInputKeydownBound);
          this.plate.addEventListener('mousedown', this._handleClockClickStartBound);
          this.plate.addEventListener('touchstart', this._handleClockClickStartBound);

          $(this.spanHours).on('click', this.showView.bind(this, 'hours'));
          $(this.spanMinutes).on('click', this.showView.bind(this, 'minutes'));
        }
      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('click', this._handleInputClickBound);
          this.el.removeEventListener('keydown', this._handleInputKeydownBound);
        }
      }, {
        key: "_handleInputClick",
        value: function _handleInputClick() {
          this.open();
        }
      }, {
        key: "_handleInputKeydown",
        value: function _handleInputKeydown(e) {
          if (e.which === M.keys.ENTER) {
            e.preventDefault();
            this.open();
          }
        }
      }, {
        key: "_handleClockClickStart",
        value: function _handleClockClickStart(e) {
          e.preventDefault();
          var clockPlateBR = this.plate.getBoundingClientRect();
          var offset = { x: clockPlateBR.left, y: clockPlateBR.top };

          this.x0 = offset.x + this.options.dialRadius;
          this.y0 = offset.y + this.options.dialRadius;
          this.moved = false;
          var clickPos = Timepicker._Pos(e);
          this.dx = clickPos.x - this.x0;
          this.dy = clickPos.y - this.y0;

          // Set clock hands
          this.setHand(this.dx, this.dy, false);

          // Mousemove on document
          document.addEventListener('mousemove', this._handleDocumentClickMoveBound);
          document.addEventListener('touchmove', this._handleDocumentClickMoveBound);

          // Mouseup on document
          document.addEventListener('mouseup', this._handleDocumentClickEndBound);
          document.addEventListener('touchend', this._handleDocumentClickEndBound);
        }
      }, {
        key: "_handleDocumentClickMove",
        value: function _handleDocumentClickMove(e) {
          e.preventDefault();
          var clickPos = Timepicker._Pos(e);
          var x = clickPos.x - this.x0;
          var y = clickPos.y - this.y0;
          this.moved = true;
          this.setHand(x, y, false, true);
        }
      }, {
        key: "_handleDocumentClickEnd",
        value: function _handleDocumentClickEnd(e) {
          var _this58 = this;

          e.preventDefault();
          document.removeEventListener('mouseup', this._handleDocumentClickEndBound);
          document.removeEventListener('touchend', this._handleDocumentClickEndBound);
          var clickPos = Timepicker._Pos(e);
          var x = clickPos.x - this.x0;
          var y = clickPos.y - this.y0;
          if (this.moved && x === this.dx && y === this.dy) {
            this.setHand(x, y);
          }

          if (this.currentView === 'hours') {
            this.showView('minutes', this.options.duration / 2);
          } else if (this.options.autoClose) {
            $(this.minutesView).addClass('timepicker-dial-out');
            setTimeout(function () {
              _this58.done();
            }, this.options.duration / 2);
          }

          if (typeof this.options.onSelect === 'function') {
            this.options.onSelect.call(this, this.hours, this.minutes);
          }

          // Unbind mousemove event
          document.removeEventListener('mousemove', this._handleDocumentClickMoveBound);
          document.removeEventListener('touchmove', this._handleDocumentClickMoveBound);
        }
      }, {
        key: "_insertHTMLIntoDOM",
        value: function _insertHTMLIntoDOM() {
          this.$modalEl = $(Timepicker._template);
          this.modalEl = this.$modalEl[0];
          this.modalEl.id = 'modal-' + this.id;

          // Append popover to input by default
          var containerEl = document.querySelector(this.options.container);
          if (this.options.container && !!containerEl) {
            this.$modalEl.appendTo(containerEl);
          } else {
            this.$modalEl.insertBefore(this.el);
          }
        }
      }, {
        key: "_setupModal",
        value: function _setupModal() {
          var _this59 = this;

          this.modal = M.Modal.init(this.modalEl, {
            onOpenStart: this.options.onOpenStart,
            onOpenEnd: this.options.onOpenEnd,
            onCloseStart: this.options.onCloseStart,
            onCloseEnd: function () {
              if (typeof _this59.options.onCloseEnd === 'function') {
                _this59.options.onCloseEnd.call(_this59);
              }
              _this59.isOpen = false;
            }
          });
        }
      }, {
        key: "_setupVariables",
        value: function _setupVariables() {
          this.currentView = 'hours';
          this.vibrate = navigator.vibrate ? 'vibrate' : navigator.webkitVibrate ? 'webkitVibrate' : null;

          this._canvas = this.modalEl.querySelector('.timepicker-canvas');
          this.plate = this.modalEl.querySelector('.timepicker-plate');

          this.hoursView = this.modalEl.querySelector('.timepicker-hours');
          this.minutesView = this.modalEl.querySelector('.timepicker-minutes');
          this.spanHours = this.modalEl.querySelector('.timepicker-span-hours');
          this.spanMinutes = this.modalEl.querySelector('.timepicker-span-minutes');
          this.spanAmPm = this.modalEl.querySelector('.timepicker-span-am-pm');
          this.footer = this.modalEl.querySelector('.timepicker-footer');
          this.amOrPm = 'PM';
        }
      }, {
        key: "_pickerSetup",
        value: function _pickerSetup() {
          var $clearBtn = $("<button class=\"btn-flat timepicker-clear waves-effect\" style=\"visibility: hidden;\" type=\"button\" tabindex=\"" + (this.options.twelveHour ? '3' : '1') + "\">" + this.options.i18n.clear + "</button>").appendTo(this.footer).on('click', this.clear.bind(this));
          if (this.options.showClearBtn) {
            $clearBtn.css({ visibility: '' });
          }

          var confirmationBtnsContainer = $('<div class="confirmation-btns"></div>');
          $('<button class="btn-flat timepicker-close waves-effect" type="button" tabindex="' + (this.options.twelveHour ? '3' : '1') + '">' + this.options.i18n.cancel + '</button>').appendTo(confirmationBtnsContainer).on('click', this.close.bind(this));
          $('<button class="btn-flat timepicker-close waves-effect" type="button" tabindex="' + (this.options.twelveHour ? '3' : '1') + '">' + this.options.i18n.done + '</button>').appendTo(confirmationBtnsContainer).on('click', this.done.bind(this));
          confirmationBtnsContainer.appendTo(this.footer);
        }
      }, {
        key: "_clockSetup",
        value: function _clockSetup() {
          if (this.options.twelveHour) {
            this.$amBtn = $('<div class="am-btn">AM</div>');
            this.$pmBtn = $('<div class="pm-btn">PM</div>');
            this.$amBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);
            this.$pmBtn.on('click', this._handleAmPmClick.bind(this)).appendTo(this.spanAmPm);
          }

          this._buildHoursView();
          this._buildMinutesView();
          this._buildSVGClock();
        }
      }, {
        key: "_buildSVGClock",
        value: function _buildSVGClock() {
          // Draw clock hands and others
          var dialRadius = this.options.dialRadius;
          var tickRadius = this.options.tickRadius;
          var diameter = dialRadius * 2;

          var svg = Timepicker._createSVGEl('svg');
          svg.setAttribute('class', 'timepicker-svg');
          svg.setAttribute('width', diameter);
          svg.setAttribute('height', diameter);
          var g = Timepicker._createSVGEl('g');
          g.setAttribute('transform', 'translate(' + dialRadius + ',' + dialRadius + ')');
          var bearing = Timepicker._createSVGEl('circle');
          bearing.setAttribute('class', 'timepicker-canvas-bearing');
          bearing.setAttribute('cx', 0);
          bearing.setAttribute('cy', 0);
          bearing.setAttribute('r', 4);
          var hand = Timepicker._createSVGEl('line');
          hand.setAttribute('x1', 0);
          hand.setAttribute('y1', 0);
          var bg = Timepicker._createSVGEl('circle');
          bg.setAttribute('class', 'timepicker-canvas-bg');
          bg.setAttribute('r', tickRadius);
          g.appendChild(hand);
          g.appendChild(bg);
          g.appendChild(bearing);
          svg.appendChild(g);
          this._canvas.appendChild(svg);

          this.hand = hand;
          this.bg = bg;
          this.bearing = bearing;
          this.g = g;
        }
      }, {
        key: "_buildHoursView",
        value: function _buildHoursView() {
          var $tick = $('<div class="timepicker-tick"></div>');
          // Hours view
          if (this.options.twelveHour) {
            for (var i = 1; i < 13; i += 1) {
              var tick = $tick.clone();
              var radian = i / 6 * Math.PI;
              var radius = this.options.outerRadius;
              tick.css({
                left: this.options.dialRadius + Math.sin(radian) * radius - this.options.tickRadius + 'px',
                top: this.options.dialRadius - Math.cos(radian) * radius - this.options.tickRadius + 'px'
              });
              tick.html(i === 0 ? '00' : i);
              this.hoursView.appendChild(tick[0]);
              // tick.on(mousedownEvent, mousedown);
            }
          } else {
            for (var _i2 = 0; _i2 < 24; _i2 += 1) {
              var _tick = $tick.clone();
              var _radian = _i2 / 6 * Math.PI;
              var inner = _i2 > 0 && _i2 < 13;
              var _radius = inner ? this.options.innerRadius : this.options.outerRadius;
              _tick.css({
                left: this.options.dialRadius + Math.sin(_radian) * _radius - this.options.tickRadius + 'px',
                top: this.options.dialRadius - Math.cos(_radian) * _radius - this.options.tickRadius + 'px'
              });
              _tick.html(_i2 === 0 ? '00' : _i2);
              this.hoursView.appendChild(_tick[0]);
              // tick.on(mousedownEvent, mousedown);
            }
          }
        }
      }, {
        key: "_buildMinutesView",
        value: function _buildMinutesView() {
          var $tick = $('<div class="timepicker-tick"></div>');
          // Minutes view
          for (var i = 0; i < 60; i += 5) {
            var tick = $tick.clone();
            var radian = i / 30 * Math.PI;
            tick.css({
              left: this.options.dialRadius + Math.sin(radian) * this.options.outerRadius - this.options.tickRadius + 'px',
              top: this.options.dialRadius - Math.cos(radian) * this.options.outerRadius - this.options.tickRadius + 'px'
            });
            tick.html(Timepicker._addLeadingZero(i));
            this.minutesView.appendChild(tick[0]);
          }
        }
      }, {
        key: "_handleAmPmClick",
        value: function _handleAmPmClick(e) {
          var $btnClicked = $(e.target);
          this.amOrPm = $btnClicked.hasClass('am-btn') ? 'AM' : 'PM';
          this._updateAmPmView();
        }
      }, {
        key: "_updateAmPmView",
        value: function _updateAmPmView() {
          if (this.options.twelveHour) {
            this.$amBtn.toggleClass('text-primary', this.amOrPm === 'AM');
            this.$pmBtn.toggleClass('text-primary', this.amOrPm === 'PM');
          }
        }
      }, {
        key: "_updateTimeFromInput",
        value: function _updateTimeFromInput() {
          // Get the time
          var value = ((this.el.value || this.options.defaultTime || '') + '').split(':');
          if (this.options.twelveHour && !(typeof value[1] === 'undefined')) {
            if (value[1].toUpperCase().indexOf('AM') > 0) {
              this.amOrPm = 'AM';
            } else {
              this.amOrPm = 'PM';
            }
            value[1] = value[1].replace('AM', '').replace('PM', '');
          }
          if (value[0] === 'now') {
            var now = new Date(+new Date() + this.options.fromNow);
            value = [now.getHours(), now.getMinutes()];
            if (this.options.twelveHour) {
              this.amOrPm = value[0] >= 12 && value[0] < 24 ? 'PM' : 'AM';
            }
          }
          this.hours = +value[0] || 0;
          this.minutes = +value[1] || 0;
          this.spanHours.innerHTML = this.hours;
          this.spanMinutes.innerHTML = Timepicker._addLeadingZero(this.minutes);

          this._updateAmPmView();
        }
      }, {
        key: "showView",
        value: function showView(view, delay) {
          if (view === 'minutes' && $(this.hoursView).css('visibility') === 'visible') ;
          var isHours = view === 'hours',
              nextView = isHours ? this.hoursView : this.minutesView,
              hideView = isHours ? this.minutesView : this.hoursView;
          this.currentView = view;

          $(this.spanHours).toggleClass('text-primary', isHours);
          $(this.spanMinutes).toggleClass('text-primary', !isHours);

          // Transition view
          hideView.classList.add('timepicker-dial-out');
          $(nextView).css('visibility', 'visible').removeClass('timepicker-dial-out');

          // Reset clock hand
          this.resetClock(delay);

          // After transitions ended
          clearTimeout(this.toggleViewTimer);
          this.toggleViewTimer = setTimeout(function () {
            $(hideView).css('visibility', 'hidden');
          }, this.options.duration);
        }
      }, {
        key: "resetClock",
        value: function resetClock(delay) {
          var view = this.currentView,
              value = this[view],
              isHours = view === 'hours',
              unit = Math.PI / (isHours ? 6 : 30),
              radian = value * unit,
              radius = isHours && value > 0 && value < 13 ? this.options.innerRadius : this.options.outerRadius,
              x = Math.sin(radian) * radius,
              y = -Math.cos(radian) * radius,
              self = this;

          if (delay) {
            $(this.canvas).addClass('timepicker-canvas-out');
            setTimeout(function () {
              $(self.canvas).removeClass('timepicker-canvas-out');
              self.setHand(x, y);
            }, delay);
          } else {
            this.setHand(x, y);
          }
        }
      }, {
        key: "setHand",
        value: function setHand(x, y, roundBy5) {
          var _this60 = this;

          var radian = Math.atan2(x, -y),
              isHours = this.currentView === 'hours',
              unit = Math.PI / (isHours || roundBy5 ? 6 : 30),
              z = Math.sqrt(x * x + y * y),
              inner = isHours && z < (this.options.outerRadius + this.options.innerRadius) / 2,
              radius = inner ? this.options.innerRadius : this.options.outerRadius;

          if (this.options.twelveHour) {
            radius = this.options.outerRadius;
          }

          // Radian should in range [0, 2PI]
          if (radian < 0) {
            radian = Math.PI * 2 + radian;
          }

          // Get the round value
          var value = Math.round(radian / unit);

          // Get the round radian
          radian = value * unit;

          // Correct the hours or minutes
          if (this.options.twelveHour) {
            if (isHours) {
              if (value === 0) value = 12;
            } else {
              if (roundBy5) value *= 5;
              if (value === 60) value = 0;
            }
          } else {
            if (isHours) {
              if (value === 12) {
                value = 0;
              }
              value = inner ? value === 0 ? 12 : value : value === 0 ? 0 : value + 12;
            } else {
              if (roundBy5) {
                value *= 5;
              }
              if (value === 60) {
                value = 0;
              }
            }
          }

          // Once hours or minutes changed, vibrate the device
          if (this[this.currentView] !== value) {
            if (this.vibrate && this.options.vibrate) {
              // Do not vibrate too frequently
              if (!this.vibrateTimer) {
                navigator[this.vibrate](10);
                this.vibrateTimer = setTimeout(function () {
                  _this60.vibrateTimer = null;
                }, 100);
              }
            }
          }

          this[this.currentView] = value;
          if (isHours) {
            this['spanHours'].innerHTML = value;
          } else {
            this['spanMinutes'].innerHTML = Timepicker._addLeadingZero(value);
          }

          // Set clock hand and others' position
          var cx1 = Math.sin(radian) * (radius - this.options.tickRadius),
              cy1 = -Math.cos(radian) * (radius - this.options.tickRadius),
              cx2 = Math.sin(radian) * radius,
              cy2 = -Math.cos(radian) * radius;
          this.hand.setAttribute('x2', cx1);
          this.hand.setAttribute('y2', cy1);
          this.bg.setAttribute('cx', cx2);
          this.bg.setAttribute('cy', cy2);
        }
      }, {
        key: "open",
        value: function open() {
          if (this.isOpen) {
            return;
          }

          this.isOpen = true;
          this._updateTimeFromInput();
          this.showView('hours');

          this.modal.open();
        }
      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen) {
            return;
          }

          this.isOpen = false;
          this.modal.close();
        }

        /**
         * Finish timepicker selection.
         */

      }, {
        key: "done",
        value: function done(e, clearValue) {
          // Set input value
          var last = this.el.value;
          var value = clearValue ? '' : Timepicker._addLeadingZero(this.hours) + ':' + Timepicker._addLeadingZero(this.minutes);
          this.time = value;
          if (!clearValue && this.options.twelveHour) {
            value = value + " " + this.amOrPm;
          }
          this.el.value = value;

          // Trigger change event
          if (value !== last) {
            this.$el.trigger('change');
          }

          this.close();
          this.el.focus();
        }
      }, {
        key: "clear",
        value: function clear() {
          this.done(null, true);
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Timepicker.__proto__ || Object.getPrototypeOf(Timepicker), "init", this).call(this, this, els, options);
        }
      }, {
        key: "_addLeadingZero",
        value: function _addLeadingZero(num) {
          return (num < 10 ? '0' : '') + num;
        }
      }, {
        key: "_createSVGEl",
        value: function _createSVGEl(name) {
          var svgNS = 'http://www.w3.org/2000/svg';
          return document.createElementNS(svgNS, name);
        }

        /**
         * @typedef {Object} Point
         * @property {number} x The X Coordinate
         * @property {number} y The Y Coordinate
         */

        /**
         * Get x position of mouse or touch event
         * @param {Event} e
         * @return {Point} x and y location
         */

      }, {
        key: "_Pos",
        value: function _Pos(e) {
          if (e.targetTouches && e.targetTouches.length >= 1) {
            return { x: e.targetTouches[0].clientX, y: e.targetTouches[0].clientY };
          }
          // mouse event
          return { x: e.clientX, y: e.clientY };
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Timepicker;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Timepicker;
    }(Component);

    Timepicker._template = ['<div class= "modal timepicker-modal">', '<div class="modal-content timepicker-container">', '<div class="timepicker-digital-display">', '<div class="timepicker-text-container">', '<div class="timepicker-display-column">', '<span class="timepicker-span-hours text-primary"></span>', ':', '<span class="timepicker-span-minutes"></span>', '</div>', '<div class="timepicker-display-column timepicker-display-am-pm">', '<div class="timepicker-span-am-pm"></div>', '</div>', '</div>', '</div>', '<div class="timepicker-analog-display">', '<div class="timepicker-plate">', '<div class="timepicker-canvas"></div>', '<div class="timepicker-dial timepicker-hours"></div>', '<div class="timepicker-dial timepicker-minutes timepicker-dial-out"></div>', '</div>', '<div class="timepicker-footer"></div>', '</div>', '</div>', '</div>'].join('');

    M.Timepicker = Timepicker;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Timepicker, 'timepicker', 'M_Timepicker');
    }
  })(cash);
  (function ($) {

    var _defaults = {};

    /**
     * @class
     *
     */

    var CharacterCounter = function (_Component17) {
      _inherits(CharacterCounter, _Component17);

      /**
       * Construct CharacterCounter instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function CharacterCounter(el, options) {
        _classCallCheck(this, CharacterCounter);

        var _this61 = _possibleConstructorReturn(this, (CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter)).call(this, CharacterCounter, el, options));

        _this61.el.M_CharacterCounter = _this61;

        /**
         * Options for the character counter
         */
        _this61.options = $.extend({}, CharacterCounter.defaults, options);

        _this61.isInvalid = false;
        _this61.isValidLength = false;
        _this61._setupCounter();
        _this61._setupEventHandlers();
        return _this61;
      }

      _createClass(CharacterCounter, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.el.CharacterCounter = undefined;
          this._removeCounter();
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleUpdateCounterBound = this.updateCounter.bind(this);

          this.el.addEventListener('focus', this._handleUpdateCounterBound, true);
          this.el.addEventListener('input', this._handleUpdateCounterBound, true);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('focus', this._handleUpdateCounterBound, true);
          this.el.removeEventListener('input', this._handleUpdateCounterBound, true);
        }

        /**
         * Setup counter element
         */

      }, {
        key: "_setupCounter",
        value: function _setupCounter() {
          this.counterEl = document.createElement('span');
          $(this.counterEl).addClass('character-counter').css({
            float: 'right',
            'font-size': '12px',
            height: 1
          });

          this.$el.parent().append(this.counterEl);
        }

        /**
         * Remove counter element
         */

      }, {
        key: "_removeCounter",
        value: function _removeCounter() {
          $(this.counterEl).remove();
        }

        /**
         * Update counter
         */

      }, {
        key: "updateCounter",
        value: function updateCounter() {
          var maxLength = +this.$el.attr('data-length'),
              actualLength = this.el.value.length;
          this.isValidLength = actualLength <= maxLength;
          var counterString = actualLength;

          if (maxLength) {
            counterString += '/' + maxLength;
            this._validateInput();
          }

          $(this.counterEl).html(counterString);
        }

        /**
         * Add validation classes
         */

      }, {
        key: "_validateInput",
        value: function _validateInput() {
          if (this.isValidLength && this.isInvalid) {
            this.isInvalid = false;
            this.$el.removeClass('invalid');
          } else if (!this.isValidLength && !this.isInvalid) {
            this.isInvalid = true;
            this.$el.removeClass('valid');
            this.$el.addClass('invalid');
          }
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(CharacterCounter.__proto__ || Object.getPrototypeOf(CharacterCounter), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_CharacterCounter;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return CharacterCounter;
    }(Component);

    M.CharacterCounter = CharacterCounter;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(CharacterCounter, 'characterCounter', 'M_CharacterCounter');
    }
  })(cash);
  (function ($) {

    var _defaults = {
      duration: 200, // ms
      dist: -100, // zoom scale TODO: make this more intuitive as an option
      shift: 0, // spacing for center image
      padding: 0, // Padding between non center items
      numVisible: 5, // Number of visible items in carousel
      fullWidth: false, // Change to full width styles
      indicators: false, // Toggle indicators
      noWrap: false, // Don't wrap around and cycle through items.
      onCycleTo: null // Callback for when a new slide is cycled to.
    };

    /**
     * @class
     *
     */

    var Carousel = function (_Component18) {
      _inherits(Carousel, _Component18);

      /**
       * Construct Carousel instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Carousel(el, options) {
        _classCallCheck(this, Carousel);

        var _this62 = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, Carousel, el, options));

        _this62.el.M_Carousel = _this62;

        /**
         * Options for the carousel
         * @member Carousel#options
         * @prop {Number} duration
         * @prop {Number} dist
         * @prop {Number} shift
         * @prop {Number} padding
         * @prop {Number} numVisible
         * @prop {Boolean} fullWidth
         * @prop {Boolean} indicators
         * @prop {Boolean} noWrap
         * @prop {Function} onCycleTo
         */
        _this62.options = $.extend({}, Carousel.defaults, options);

        // Setup
        _this62.hasMultipleSlides = _this62.$el.find('.carousel-item').length > 1;
        _this62.showIndicators = _this62.options.indicators && _this62.hasMultipleSlides;
        _this62.noWrap = _this62.options.noWrap || !_this62.hasMultipleSlides;
        _this62.pressed = false;
        _this62.dragged = false;
        _this62.offset = _this62.target = 0;
        _this62.images = [];
        _this62.itemWidth = _this62.$el.find('.carousel-item').first().innerWidth();
        _this62.itemHeight = _this62.$el.find('.carousel-item').first().innerHeight();
        _this62.dim = _this62.itemWidth * 2 + _this62.options.padding || 1; // Make sure dim is non zero for divisions.
        _this62._autoScrollBound = _this62._autoScroll.bind(_this62);
        _this62._trackBound = _this62._track.bind(_this62);

        // Full Width carousel setup
        if (_this62.options.fullWidth) {
          _this62.options.dist = 0;
          _this62._setCarouselHeight();

          // Offset fixed items when indicators.
          if (_this62.showIndicators) {
            _this62.$el.find('.carousel-fixed-item').addClass('with-indicators');
          }
        }

        // Iterate through slides
        _this62.$indicators = $('<ul class="indicators"></ul>');
        _this62.$el.find('.carousel-item').each(function (el, i) {
          _this62.images.push(el);
          if (_this62.showIndicators) {
            var $indicator = $('<li class="indicator-item"></li>');

            // Add active to first by default.
            if (i === 0) {
              $indicator[0].classList.add('active');
            }

            _this62.$indicators.append($indicator);
          }
        });
        if (_this62.showIndicators) {
          _this62.$el.append(_this62.$indicators);
        }
        _this62.count = _this62.images.length;

        // Cap numVisible at count
        _this62.options.numVisible = Math.min(_this62.count, _this62.options.numVisible);

        // Setup cross browser string
        _this62.xform = 'transform';
        ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {
          var e = prefix + 'Transform';
          if (typeof document.body.style[e] !== 'undefined') {
            _this62.xform = e;
            return false;
          }
          return true;
        });

        _this62._setupEventHandlers();
        _this62._scroll(_this62.offset);
        return _this62;
      }

      _createClass(Carousel, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.el.M_Carousel = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          var _this63 = this;

          this._handleCarouselTapBound = this._handleCarouselTap.bind(this);
          this._handleCarouselDragBound = this._handleCarouselDrag.bind(this);
          this._handleCarouselReleaseBound = this._handleCarouselRelease.bind(this);
          this._handleCarouselClickBound = this._handleCarouselClick.bind(this);

          if (typeof window.ontouchstart !== 'undefined') {
            this.el.addEventListener('touchstart', this._handleCarouselTapBound);
            this.el.addEventListener('touchmove', this._handleCarouselDragBound);
            this.el.addEventListener('touchend', this._handleCarouselReleaseBound);
          }

          this.el.addEventListener('mousedown', this._handleCarouselTapBound);
          this.el.addEventListener('mousemove', this._handleCarouselDragBound);
          this.el.addEventListener('mouseup', this._handleCarouselReleaseBound);
          this.el.addEventListener('mouseleave', this._handleCarouselReleaseBound);
          this.el.addEventListener('click', this._handleCarouselClickBound);

          if (this.showIndicators && this.$indicators) {
            this._handleIndicatorClickBound = this._handleIndicatorClick.bind(this);
            this.$indicators.find('.indicator-item').each(function (el, i) {
              el.addEventListener('click', _this63._handleIndicatorClickBound);
            });
          }

          // Resize
          var throttledResize = M.throttle(this._handleResize, 200);
          this._handleThrottledResizeBound = throttledResize.bind(this);

          window.addEventListener('resize', this._handleThrottledResizeBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          var _this64 = this;

          if (typeof window.ontouchstart !== 'undefined') {
            this.el.removeEventListener('touchstart', this._handleCarouselTapBound);
            this.el.removeEventListener('touchmove', this._handleCarouselDragBound);
            this.el.removeEventListener('touchend', this._handleCarouselReleaseBound);
          }
          this.el.removeEventListener('mousedown', this._handleCarouselTapBound);
          this.el.removeEventListener('mousemove', this._handleCarouselDragBound);
          this.el.removeEventListener('mouseup', this._handleCarouselReleaseBound);
          this.el.removeEventListener('mouseleave', this._handleCarouselReleaseBound);
          this.el.removeEventListener('click', this._handleCarouselClickBound);

          if (this.showIndicators && this.$indicators) {
            this.$indicators.find('.indicator-item').each(function (el, i) {
              el.removeEventListener('click', _this64._handleIndicatorClickBound);
            });
          }

          window.removeEventListener('resize', this._handleThrottledResizeBound);
        }

        /**
         * Handle Carousel Tap
         * @param {Event} e
         */

      }, {
        key: "_handleCarouselTap",
        value: function _handleCarouselTap(e) {
          // Fixes firefox draggable image bug
          if (e.type === 'mousedown' && $(e.target).is('img')) {
            e.preventDefault();
          }
          this.pressed = true;
          this.dragged = false;
          this.verticalDragged = false;
          this.reference = this._xpos(e);
          this.referenceY = this._ypos(e);

          this.velocity = this.amplitude = 0;
          this.frame = this.offset;
          this.timestamp = Date.now();
          clearInterval(this.ticker);
          this.ticker = setInterval(this._trackBound, 100);
        }

        /**
         * Handle Carousel Drag
         * @param {Event} e
         */

      }, {
        key: "_handleCarouselDrag",
        value: function _handleCarouselDrag(e) {
          var x = void 0,
              y = void 0,
              delta = void 0,
              deltaY = void 0;
          if (this.pressed) {
            x = this._xpos(e);
            y = this._ypos(e);
            delta = this.reference - x;
            deltaY = Math.abs(this.referenceY - y);
            if (deltaY < 30 && !this.verticalDragged) {
              // If vertical scrolling don't allow dragging.
              if (delta > 2 || delta < -2) {
                this.dragged = true;
                this.reference = x;
                this._scroll(this.offset + delta);
              }
            } else if (this.dragged) {
              // If dragging don't allow vertical scroll.
              e.preventDefault();
              e.stopPropagation();
              return false;
            } else {
              // Vertical scrolling.
              this.verticalDragged = true;
            }
          }

          if (this.dragged) {
            // If dragging don't allow vertical scroll.
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }

        /**
         * Handle Carousel Release
         * @param {Event} e
         */

      }, {
        key: "_handleCarouselRelease",
        value: function _handleCarouselRelease(e) {
          if (this.pressed) {
            this.pressed = false;
          } else {
            return;
          }

          clearInterval(this.ticker);
          this.target = this.offset;
          if (this.velocity > 10 || this.velocity < -10) {
            this.amplitude = 0.9 * this.velocity;
            this.target = this.offset + this.amplitude;
          }
          this.target = Math.round(this.target / this.dim) * this.dim;

          // No wrap of items.
          if (this.noWrap) {
            if (this.target >= this.dim * (this.count - 1)) {
              this.target = this.dim * (this.count - 1);
            } else if (this.target < 0) {
              this.target = 0;
            }
          }
          this.amplitude = this.target - this.offset;
          this.timestamp = Date.now();
          requestAnimationFrame(this._autoScrollBound);

          if (this.dragged) {
            e.preventDefault();
            e.stopPropagation();
          }
          return false;
        }

        /**
         * Handle Carousel CLick
         * @param {Event} e
         */

      }, {
        key: "_handleCarouselClick",
        value: function _handleCarouselClick(e) {
          // Disable clicks if carousel was dragged.
          if (this.dragged) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          } else if (!this.options.fullWidth) {
            var clickedIndex = $(e.target).closest('.carousel-item').index();
            var diff = this._wrap(this.center) - clickedIndex;

            // Disable clicks if carousel was shifted by click
            if (diff !== 0) {
              e.preventDefault();
              e.stopPropagation();
            }
            this._cycleTo(clickedIndex);
          }
        }

        /**
         * Handle Indicator CLick
         * @param {Event} e
         */

      }, {
        key: "_handleIndicatorClick",
        value: function _handleIndicatorClick(e) {
          e.stopPropagation();

          var indicator = $(e.target).closest('.indicator-item');
          if (indicator.length) {
            this._cycleTo(indicator.index());
          }
        }

        /**
         * Handle Throttle Resize
         * @param {Event} e
         */

      }, {
        key: "_handleResize",
        value: function _handleResize(e) {
          if (this.options.fullWidth) {
            this.itemWidth = this.$el.find('.carousel-item').first().innerWidth();
            this.imageHeight = this.$el.find('.carousel-item.active').height();
            this.dim = this.itemWidth * 2 + this.options.padding;
            this.offset = this.center * 2 * this.itemWidth;
            this.target = this.offset;
            this._setCarouselHeight(true);
          } else {
            this._scroll();
          }
        }

        /**
         * Set carousel height based on first slide
         * @param {Booleam} imageOnly - true for image slides
         */

      }, {
        key: "_setCarouselHeight",
        value: function _setCarouselHeight(imageOnly) {
          var _this65 = this;

          var firstSlide = this.$el.find('.carousel-item.active').length ? this.$el.find('.carousel-item.active').first() : this.$el.find('.carousel-item').first();
          var firstImage = firstSlide.find('img').first();
          if (firstImage.length) {
            if (firstImage[0].complete) {
              // If image won't trigger the load event
              var imageHeight = firstImage.height();
              if (imageHeight > 0) {
                this.$el.css('height', imageHeight + 'px');
              } else {
                // If image still has no height, use the natural dimensions to calculate
                var naturalWidth = firstImage[0].naturalWidth;
                var naturalHeight = firstImage[0].naturalHeight;
                var adjustedHeight = this.$el.width() / naturalWidth * naturalHeight;
                this.$el.css('height', adjustedHeight + 'px');
              }
            } else {
              // Get height when image is loaded normally
              firstImage.one('load', function (el, i) {
                _this65.$el.css('height', el.offsetHeight + 'px');
              });
            }
          } else if (!imageOnly) {
            var slideHeight = firstSlide.height();
            this.$el.css('height', slideHeight + 'px');
          }
        }

        /**
         * Get x position from event
         * @param {Event} e
         */

      }, {
        key: "_xpos",
        value: function _xpos(e) {
          // touch event
          if (e.targetTouches && e.targetTouches.length >= 1) {
            return e.targetTouches[0].clientX;
          }

          // mouse event
          return e.clientX;
        }

        /**
         * Get y position from event
         * @param {Event} e
         */

      }, {
        key: "_ypos",
        value: function _ypos(e) {
          // touch event
          if (e.targetTouches && e.targetTouches.length >= 1) {
            return e.targetTouches[0].clientY;
          }

          // mouse event
          return e.clientY;
        }

        /**
         * Wrap index
         * @param {Number} x
         */

      }, {
        key: "_wrap",
        value: function _wrap(x) {
          return x >= this.count ? x % this.count : x < 0 ? this._wrap(this.count + x % this.count) : x;
        }

        /**
         * Tracks scrolling information
         */

      }, {
        key: "_track",
        value: function _track() {
          var now = void 0,
              elapsed = void 0,
              delta = void 0,
              v = void 0;

          now = Date.now();
          elapsed = now - this.timestamp;
          this.timestamp = now;
          delta = this.offset - this.frame;
          this.frame = this.offset;

          v = 1000 * delta / (1 + elapsed);
          this.velocity = 0.8 * v + 0.2 * this.velocity;
        }

        /**
         * Auto scrolls to nearest carousel item.
         */

      }, {
        key: "_autoScroll",
        value: function _autoScroll() {
          var elapsed = void 0,
              delta = void 0;

          if (this.amplitude) {
            elapsed = Date.now() - this.timestamp;
            delta = this.amplitude * Math.exp(-elapsed / this.options.duration);
            if (delta > 2 || delta < -2) {
              this._scroll(this.target - delta);
              requestAnimationFrame(this._autoScrollBound);
            } else {
              this._scroll(this.target);
            }
          }
        }

        /**
         * Scroll to target
         * @param {Number} x
         */

      }, {
        key: "_scroll",
        value: function _scroll(x) {
          var _this66 = this;

          // Track scrolling state
          if (!this.$el.hasClass('scrolling')) {
            this.el.classList.add('scrolling');
          }
          if (this.scrollingTimeout != null) {
            window.clearTimeout(this.scrollingTimeout);
          }
          this.scrollingTimeout = window.setTimeout(function () {
            _this66.$el.removeClass('scrolling');
          }, this.options.duration);

          // Start actual scroll
          var i = void 0,
              half = void 0,
              delta = void 0,
              dir = void 0,
              tween = void 0,
              el = void 0,
              alignment = void 0,
              zTranslation = void 0,
              tweenedOpacity = void 0,
              centerTweenedOpacity = void 0;
          var lastCenter = this.center;
          var numVisibleOffset = 1 / this.options.numVisible;

          this.offset = typeof x === 'number' ? x : this.offset;
          this.center = Math.floor((this.offset + this.dim / 2) / this.dim);
          delta = this.offset - this.center * this.dim;
          dir = delta < 0 ? 1 : -1;
          tween = -dir * delta * 2 / this.dim;
          half = this.count >> 1;

          if (this.options.fullWidth) {
            alignment = 'translateX(0)';
            centerTweenedOpacity = 1;
          } else {
            alignment = 'translateX(' + (this.el.clientWidth - this.itemWidth) / 2 + 'px) ';
            alignment += 'translateY(' + (this.el.clientHeight - this.itemHeight) / 2 + 'px)';
            centerTweenedOpacity = 1 - numVisibleOffset * tween;
          }

          // Set indicator active
          if (this.showIndicators) {
            var diff = this.center % this.count;
            var activeIndicator = this.$indicators.find('.indicator-item.active');
            if (activeIndicator.index() !== diff) {
              activeIndicator.removeClass('active');
              this.$indicators.find('.indicator-item').eq(diff)[0].classList.add('active');
            }
          }

          // center
          // Don't show wrapped items.
          if (!this.noWrap || this.center >= 0 && this.center < this.count) {
            el = this.images[this._wrap(this.center)];

            // Add active class to center item.
            if (!$(el).hasClass('active')) {
              this.$el.find('.carousel-item').removeClass('active');
              el.classList.add('active');
            }
            var transformString = alignment + " translateX(" + -delta / 2 + "px) translateX(" + dir * this.options.shift * tween * i + "px) translateZ(" + this.options.dist * tween + "px)";
            this._updateItemStyle(el, centerTweenedOpacity, 0, transformString);
          }

          for (i = 1; i <= half; ++i) {
            // right side
            if (this.options.fullWidth) {
              zTranslation = this.options.dist;
              tweenedOpacity = i === half && delta < 0 ? 1 - tween : 1;
            } else {
              zTranslation = this.options.dist * (i * 2 + tween * dir);
              tweenedOpacity = 1 - numVisibleOffset * (i * 2 + tween * dir);
            }
            // Don't show wrapped items.
            if (!this.noWrap || this.center + i < this.count) {
              el = this.images[this._wrap(this.center + i)];
              var _transformString = alignment + " translateX(" + (this.options.shift + (this.dim * i - delta) / 2) + "px) translateZ(" + zTranslation + "px)";
              this._updateItemStyle(el, tweenedOpacity, -i, _transformString);
            }

            // left side
            if (this.options.fullWidth) {
              zTranslation = this.options.dist;
              tweenedOpacity = i === half && delta > 0 ? 1 - tween : 1;
            } else {
              zTranslation = this.options.dist * (i * 2 - tween * dir);
              tweenedOpacity = 1 - numVisibleOffset * (i * 2 - tween * dir);
            }
            // Don't show wrapped items.
            if (!this.noWrap || this.center - i >= 0) {
              el = this.images[this._wrap(this.center - i)];
              var _transformString2 = alignment + " translateX(" + (-this.options.shift + (-this.dim * i - delta) / 2) + "px) translateZ(" + zTranslation + "px)";
              this._updateItemStyle(el, tweenedOpacity, -i, _transformString2);
            }
          }

          // center
          // Don't show wrapped items.
          if (!this.noWrap || this.center >= 0 && this.center < this.count) {
            el = this.images[this._wrap(this.center)];
            var _transformString3 = alignment + " translateX(" + -delta / 2 + "px) translateX(" + dir * this.options.shift * tween + "px) translateZ(" + this.options.dist * tween + "px)";
            this._updateItemStyle(el, centerTweenedOpacity, 0, _transformString3);
          }

          // onCycleTo callback
          var $currItem = this.$el.find('.carousel-item').eq(this._wrap(this.center));
          if (lastCenter !== this.center && typeof this.options.onCycleTo === 'function') {
            this.options.onCycleTo.call(this, $currItem[0], this.dragged);
          }

          // One time callback
          if (typeof this.oneTimeCallback === 'function') {
            this.oneTimeCallback.call(this, $currItem[0], this.dragged);
            this.oneTimeCallback = null;
          }
        }

        /**
         * Cycle to target
         * @param {Element} el
         * @param {Number} opacity
         * @param {Number} zIndex
         * @param {String} transform
         */

      }, {
        key: "_updateItemStyle",
        value: function _updateItemStyle(el, opacity, zIndex, transform) {
          el.style[this.xform] = transform;
          el.style.zIndex = zIndex;
          el.style.opacity = opacity;
          el.style.visibility = 'visible';
        }

        /**
         * Cycle to target
         * @param {Number} n
         * @param {Function} callback
         */

      }, {
        key: "_cycleTo",
        value: function _cycleTo(n, callback) {
          var diff = this.center % this.count - n;

          // Account for wraparound.
          if (!this.noWrap) {
            if (diff < 0) {
              if (Math.abs(diff + this.count) < Math.abs(diff)) {
                diff += this.count;
              }
            } else if (diff > 0) {
              if (Math.abs(diff - this.count) < diff) {
                diff -= this.count;
              }
            }
          }

          this.target = this.dim * Math.round(this.offset / this.dim);
          // Next
          if (diff < 0) {
            this.target += this.dim * Math.abs(diff);

            // Prev
          } else if (diff > 0) {
            this.target -= this.dim * diff;
          }

          // Set one time callback
          if (typeof callback === 'function') {
            this.oneTimeCallback = callback;
          }

          // Scroll
          if (this.offset !== this.target) {
            this.amplitude = this.target - this.offset;
            this.timestamp = Date.now();
            requestAnimationFrame(this._autoScrollBound);
          }
        }

        /**
         * Cycle to next item
         * @param {Number} [n]
         */

      }, {
        key: "next",
        value: function next(n) {
          if (n === undefined || isNaN(n)) {
            n = 1;
          }

          var index = this.center + n;
          if (index >= this.count || index < 0) {
            if (this.noWrap) {
              return;
            }

            index = this._wrap(index);
          }
          this._cycleTo(index);
        }

        /**
         * Cycle to previous item
         * @param {Number} [n]
         */

      }, {
        key: "prev",
        value: function prev(n) {
          if (n === undefined || isNaN(n)) {
            n = 1;
          }

          var index = this.center - n;
          if (index >= this.count || index < 0) {
            if (this.noWrap) {
              return;
            }

            index = this._wrap(index);
          }

          this._cycleTo(index);
        }

        /**
         * Cycle to nth item
         * @param {Number} [n]
         * @param {Function} callback
         */

      }, {
        key: "set",
        value: function set(n, callback) {
          if (n === undefined || isNaN(n)) {
            n = 0;
          }

          if (n > this.count || n < 0) {
            if (this.noWrap) {
              return;
            }

            n = this._wrap(n);
          }

          this._cycleTo(n, callback);
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Carousel.__proto__ || Object.getPrototypeOf(Carousel), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Carousel;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Carousel;
    }(Component);

    M.Carousel = Carousel;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Carousel, 'carousel', 'M_Carousel');
    }
  })(cash);
  (function ($) {

    var _defaults = {
      onOpen: undefined,
      onClose: undefined
    };

    /**
     * @class
     *
     */

    var TapTarget = function (_Component19) {
      _inherits(TapTarget, _Component19);

      /**
       * Construct TapTarget instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function TapTarget(el, options) {
        _classCallCheck(this, TapTarget);

        var _this67 = _possibleConstructorReturn(this, (TapTarget.__proto__ || Object.getPrototypeOf(TapTarget)).call(this, TapTarget, el, options));

        _this67.el.M_TapTarget = _this67;

        /**
         * Options for the select
         * @member TapTarget#options
         * @prop {Function} onOpen - Callback function called when feature discovery is opened
         * @prop {Function} onClose - Callback function called when feature discovery is closed
         */
        _this67.options = $.extend({}, TapTarget.defaults, options);

        _this67.isOpen = false;

        // setup
        _this67.$origin = $('#' + _this67.$el.attr('data-target'));
        _this67._setup();

        _this67._calculatePositioning();
        _this67._setupEventHandlers();
        return _this67;
      }

      _createClass(TapTarget, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this.el.TapTarget = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleDocumentClickBound = this._handleDocumentClick.bind(this);
          this._handleTargetClickBound = this._handleTargetClick.bind(this);
          this._handleOriginClickBound = this._handleOriginClick.bind(this);

          this.el.addEventListener('click', this._handleTargetClickBound);
          this.originEl.addEventListener('click', this._handleOriginClickBound);

          // Resize
          var throttledResize = M.throttle(this._handleResize, 200);
          this._handleThrottledResizeBound = throttledResize.bind(this);

          window.addEventListener('resize', this._handleThrottledResizeBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('click', this._handleTargetClickBound);
          this.originEl.removeEventListener('click', this._handleOriginClickBound);
          window.removeEventListener('resize', this._handleThrottledResizeBound);
        }

        /**
         * Handle Target Click
         * @param {Event} e
         */

      }, {
        key: "_handleTargetClick",
        value: function _handleTargetClick(e) {
          this.open();
        }

        /**
         * Handle Origin Click
         * @param {Event} e
         */

      }, {
        key: "_handleOriginClick",
        value: function _handleOriginClick(e) {
          this.close();
        }

        /**
         * Handle Resize
         * @param {Event} e
         */

      }, {
        key: "_handleResize",
        value: function _handleResize(e) {
          this._calculatePositioning();
        }

        /**
         * Handle Resize
         * @param {Event} e
         */

      }, {
        key: "_handleDocumentClick",
        value: function _handleDocumentClick(e) {
          if (!$(e.target).closest('.tap-target-wrapper').length) {
            this.close();
            e.preventDefault();
            e.stopPropagation();
          }
        }

        /**
         * Setup Tap Target
         */

      }, {
        key: "_setup",
        value: function _setup() {
          // Creating tap target
          this.wrapper = this.$el.parent()[0];
          this.waveEl = $(this.wrapper).find('.tap-target-wave')[0];
          this.originEl = $(this.wrapper).find('.tap-target-origin')[0];
          this.contentEl = this.$el.find('.tap-target-content')[0];

          // Creating wrapper
          if (!$(this.wrapper).hasClass('.tap-target-wrapper')) {
            this.wrapper = document.createElement('div');
            this.wrapper.classList.add('tap-target-wrapper');
            this.$el.before($(this.wrapper));
            this.wrapper.append(this.el);
          }

          // Creating content
          if (!this.contentEl) {
            this.contentEl = document.createElement('div');
            this.contentEl.classList.add('tap-target-content');
            this.$el.append(this.contentEl);
          }

          // Creating foreground wave
          if (!this.waveEl) {
            this.waveEl = document.createElement('div');
            this.waveEl.classList.add('tap-target-wave');

            // Creating origin
            if (!this.originEl) {
              this.originEl = this.$origin.clone(true, true);
              this.originEl.addClass('tap-target-origin');
              this.originEl.removeAttr('id');
              this.originEl.removeAttr('style');
              this.originEl = this.originEl[0];
              this.waveEl.append(this.originEl);
            }

            this.wrapper.append(this.waveEl);
          }
        }

        /**
         * Calculate positioning
         */

      }, {
        key: "_calculatePositioning",
        value: function _calculatePositioning() {
          // Element or parent is fixed position?
          var isFixed = this.$origin.css('position') === 'fixed';
          if (!isFixed) {
            var parents = this.$origin.parents();
            for (var i = 0; i < parents.length; i++) {
              isFixed = $(parents[i]).css('position') == 'fixed';
              if (isFixed) {
                break;
              }
            }
          }

          // Calculating origin
          var originWidth = this.$origin.outerWidth();
          var originHeight = this.$origin.outerHeight();
          var originTop = isFixed ? this.$origin.offset().top - M.getDocumentScrollTop() : this.$origin.offset().top;
          var originLeft = isFixed ? this.$origin.offset().left - M.getDocumentScrollLeft() : this.$origin.offset().left;

          // Calculating screen
          var windowWidth = window.innerWidth;
          var windowHeight = window.innerHeight;
          var centerX = windowWidth / 2;
          var centerY = windowHeight / 2;
          var isLeft = originLeft <= centerX;
          var isRight = originLeft > centerX;
          var isTop = originTop <= centerY;
          var isBottom = originTop > centerY;
          var isCenterX = originLeft >= windowWidth * 0.25 && originLeft <= windowWidth * 0.75;

          // Calculating tap target
          var tapTargetWidth = this.$el.outerWidth();
          var tapTargetHeight = this.$el.outerHeight();
          var tapTargetTop = originTop + originHeight / 2 - tapTargetHeight / 2;
          var tapTargetLeft = originLeft + originWidth / 2 - tapTargetWidth / 2;
          var tapTargetPosition = isFixed ? 'fixed' : 'absolute';

          // Calculating content
          var tapTargetTextWidth = isCenterX ? tapTargetWidth : tapTargetWidth / 2 + originWidth;
          var tapTargetTextHeight = tapTargetHeight / 2;
          var tapTargetTextTop = isTop ? tapTargetHeight / 2 : 0;
          var tapTargetTextBottom = 0;
          var tapTargetTextLeft = isLeft && !isCenterX ? tapTargetWidth / 2 - originWidth : 0;
          var tapTargetTextRight = 0;
          var tapTargetTextPadding = originWidth;
          var tapTargetTextAlign = isBottom ? 'bottom' : 'top';

          // Calculating wave
          var tapTargetWaveWidth = originWidth > originHeight ? originWidth * 2 : originWidth * 2;
          var tapTargetWaveHeight = tapTargetWaveWidth;
          var tapTargetWaveTop = tapTargetHeight / 2 - tapTargetWaveHeight / 2;
          var tapTargetWaveLeft = tapTargetWidth / 2 - tapTargetWaveWidth / 2;

          // Setting tap target
          var tapTargetWrapperCssObj = {};
          tapTargetWrapperCssObj.top = isTop ? tapTargetTop + 'px' : '';
          tapTargetWrapperCssObj.right = isRight ? windowWidth - tapTargetLeft - tapTargetWidth + 'px' : '';
          tapTargetWrapperCssObj.bottom = isBottom ? windowHeight - tapTargetTop - tapTargetHeight + 'px' : '';
          tapTargetWrapperCssObj.left = isLeft ? tapTargetLeft + 'px' : '';
          tapTargetWrapperCssObj.position = tapTargetPosition;
          $(this.wrapper).css(tapTargetWrapperCssObj);

          // Setting content
          $(this.contentEl).css({
            width: tapTargetTextWidth + 'px',
            height: tapTargetTextHeight + 'px',
            top: tapTargetTextTop + 'px',
            right: tapTargetTextRight + 'px',
            bottom: tapTargetTextBottom + 'px',
            left: tapTargetTextLeft + 'px',
            padding: tapTargetTextPadding + 'px',
            verticalAlign: tapTargetTextAlign
          });

          // Setting wave
          $(this.waveEl).css({
            top: tapTargetWaveTop + 'px',
            left: tapTargetWaveLeft + 'px',
            width: tapTargetWaveWidth + 'px',
            height: tapTargetWaveHeight + 'px'
          });
        }

        /**
         * Open TapTarget
         */

      }, {
        key: "open",
        value: function open() {
          if (this.isOpen) {
            return;
          }

          // onOpen callback
          if (typeof this.options.onOpen === 'function') {
            this.options.onOpen.call(this, this.$origin[0]);
          }

          this.isOpen = true;
          this.wrapper.classList.add('open');

          document.body.addEventListener('click', this._handleDocumentClickBound, true);
          document.body.addEventListener('touchend', this._handleDocumentClickBound);
        }

        /**
         * Close Tap Target
         */

      }, {
        key: "close",
        value: function close() {
          if (!this.isOpen) {
            return;
          }

          // onClose callback
          if (typeof this.options.onClose === 'function') {
            this.options.onClose.call(this, this.$origin[0]);
          }

          this.isOpen = false;
          this.wrapper.classList.remove('open');

          document.body.removeEventListener('click', this._handleDocumentClickBound, true);
          document.body.removeEventListener('touchend', this._handleDocumentClickBound);
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(TapTarget.__proto__ || Object.getPrototypeOf(TapTarget), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_TapTarget;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return TapTarget;
    }(Component);

    M.TapTarget = TapTarget;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(TapTarget, 'tapTarget', 'M_TapTarget');
    }
  })(cash);
  (function ($) {

    var _defaults = {
      classes: '',
      dropdownOptions: {}
    };

    /**
     * @class
     *
     */

    var FormSelect = function (_Component20) {
      _inherits(FormSelect, _Component20);

      /**
       * Construct FormSelect instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function FormSelect(el, options) {
        _classCallCheck(this, FormSelect);

        // Don't init if browser default version
        var _this68 = _possibleConstructorReturn(this, (FormSelect.__proto__ || Object.getPrototypeOf(FormSelect)).call(this, FormSelect, el, options));

        if (_this68.$el.hasClass('browser-default')) {
          return _possibleConstructorReturn(_this68);
        }

        _this68.el.M_FormSelect = _this68;

        /**
         * Options for the select
         * @member FormSelect#options
         */
        _this68.options = $.extend({}, FormSelect.defaults, options);

        _this68.isMultiple = _this68.$el.prop('multiple');

        // Setup
        _this68.el.tabIndex = -1;
        _this68._keysSelected = {};
        _this68._valueDict = {}; // Maps key to original and generated option element.
        _this68._setupDropdown();

        _this68._setupEventHandlers();
        return _this68;
      }

      _createClass(FormSelect, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this._removeDropdown();
          this.el.M_FormSelect = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          var _this69 = this;

          this._handleSelectChangeBound = this._handleSelectChange.bind(this);
          this._handleOptionClickBound = this._handleOptionClick.bind(this);
          this._handleInputClickBound = this._handleInputClick.bind(this);

          $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {
            el.addEventListener('click', _this69._handleOptionClickBound);
          });
          this.el.addEventListener('change', this._handleSelectChangeBound);
          this.input.addEventListener('click', this._handleInputClickBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          var _this70 = this;

          $(this.dropdownOptions).find('li:not(.optgroup)').each(function (el) {
            el.removeEventListener('click', _this70._handleOptionClickBound);
          });
          this.el.removeEventListener('change', this._handleSelectChangeBound);
          this.input.removeEventListener('click', this._handleInputClickBound);
        }

        /**
         * Handle Select Change
         * @param {Event} e
         */

      }, {
        key: "_handleSelectChange",
        value: function _handleSelectChange(e) {
          this._setValueToInput();
        }

        /**
         * Handle Option Click
         * @param {Event} e
         */

      }, {
        key: "_handleOptionClick",
        value: function _handleOptionClick(e) {
          e.preventDefault();
          var option = $(e.target).closest('li')[0];
          var key = option.id;
          if (!$(option).hasClass('disabled') && !$(option).hasClass('optgroup') && key.length) {
            var selected = true;

            if (this.isMultiple) {
              // Deselect placeholder option if still selected.
              var placeholderOption = $(this.dropdownOptions).find('li.disabled.selected');
              if (placeholderOption.length) {
                placeholderOption.removeClass('selected');
                placeholderOption.find('input[type="checkbox"]').prop('checked', false);
                this._toggleEntryFromArray(placeholderOption[0].id);
              }
              selected = this._toggleEntryFromArray(key);
            } else {
              $(this.dropdownOptions).find('li').removeClass('selected');
              $(option).toggleClass('selected', selected);
            }

            // Set selected on original select option
            // Only trigger if selected state changed
            var prevSelected = $(this._valueDict[key].el).prop('selected');
            if (prevSelected !== selected) {
              $(this._valueDict[key].el).prop('selected', selected);
              this.$el.trigger('change');
            }
          }

          e.stopPropagation();
        }

        /**
         * Handle Input Click
         */

      }, {
        key: "_handleInputClick",
        value: function _handleInputClick() {
          if (this.dropdown && this.dropdown.isOpen) {
            this._setValueToInput();
            this._setSelectedStates();
          }
        }

        /**
         * Setup dropdown
         */

      }, {
        key: "_setupDropdown",
        value: function _setupDropdown() {
          var _this71 = this;

          this.wrapper = document.createElement('div');
          $(this.wrapper).addClass('select-wrapper ' + this.options.classes);
          this.$el.before($(this.wrapper));
          this.wrapper.appendChild(this.el);

          if (this.el.disabled) {
            this.wrapper.classList.add('disabled');
          }

          // Create dropdown
          this.$selectOptions = this.$el.children('option, optgroup');
          this.dropdownOptions = document.createElement('ul');
          this.dropdownOptions.id = "select-options-" + M.guid();
          $(this.dropdownOptions).addClass('dropdown-content select-dropdown ' + (this.isMultiple ? 'multiple-select-dropdown' : ''));

          // Create dropdown structure.
          if (this.$selectOptions.length) {
            this.$selectOptions.each(function (el) {
              if ($(el).is('option')) {
                // Direct descendant option.
                var optionEl = void 0;
                if (_this71.isMultiple) {
                  optionEl = _this71._appendOptionWithIcon(_this71.$el, el, 'multiple');
                } else {
                  optionEl = _this71._appendOptionWithIcon(_this71.$el, el);
                }

                _this71._addOptionToValueDict(el, optionEl);
              } else if ($(el).is('optgroup')) {
                // Optgroup.
                var selectOptions = $(el).children('option');
                $(_this71.dropdownOptions).append($('<li class="optgroup"><span>' + el.getAttribute('label') + '</span></li>')[0]);

                selectOptions.each(function (el) {
                  var optionEl = _this71._appendOptionWithIcon(_this71.$el, el, 'optgroup-option');
                  _this71._addOptionToValueDict(el, optionEl);
                });
              }
            });
          }

          this.$el.after(this.dropdownOptions);

          // Add input dropdown
          this.input = document.createElement('input');
          $(this.input).addClass('select-dropdown dropdown-trigger');
          this.input.setAttribute('type', 'text');
          this.input.setAttribute('readonly', 'true');
          this.input.setAttribute('data-target', this.dropdownOptions.id);
          if (this.el.disabled) {
            $(this.input).prop('disabled', 'true');
          }

          this.$el.before(this.input);
          this._setValueToInput();

          // Add caret
          var dropdownIcon = $('<svg class="caret" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
          this.$el.before(dropdownIcon[0]);

          // Initialize dropdown
          if (!this.el.disabled) {
            var dropdownOptions = $.extend({}, this.options.dropdownOptions);

            // Add callback for centering selected option when dropdown content is scrollable
            dropdownOptions.onOpenEnd = function (el) {
              var selectedOption = $(_this71.dropdownOptions).find('.selected').first();
              if (_this71.dropdown.isScrollable && selectedOption.length) {
                var scrollOffset = selectedOption[0].getBoundingClientRect().top - _this71.dropdownOptions.getBoundingClientRect().top; // scroll to selected option
                scrollOffset -= _this71.dropdownOptions.clientHeight / 2; // center in dropdown
                _this71.dropdownOptions.scrollTop = scrollOffset;
              }
            };

            if (this.isMultiple) {
              dropdownOptions.closeOnClick = false;
            }
            this.dropdown = M.Dropdown.init(this.input, dropdownOptions);
          }

          // Add initial selections
          this._setSelectedStates();
        }

        /**
         * Add option to value dict
         * @param {Element} el  original option element
         * @param {Element} optionEl  generated option element
         */

      }, {
        key: "_addOptionToValueDict",
        value: function _addOptionToValueDict(el, optionEl) {
          var index = Object.keys(this._valueDict).length;
          var key = this.dropdownOptions.id + index;
          var obj = {};
          optionEl.id = key;

          obj.el = el;
          obj.optionEl = optionEl;
          this._valueDict[key] = obj;
        }

        /**
         * Remove dropdown
         */

      }, {
        key: "_removeDropdown",
        value: function _removeDropdown() {
          $(this.wrapper).find('.caret').remove();
          $(this.input).remove();
          $(this.dropdownOptions).remove();
          $(this.wrapper).before(this.$el);
          $(this.wrapper).remove();
        }

        /**
         * Setup dropdown
         * @param {Element} select  select element
         * @param {Element} option  option element from select
         * @param {String} type
         * @return {Element}  option element added
         */

      }, {
        key: "_appendOptionWithIcon",
        value: function _appendOptionWithIcon(select, option, type) {
          // Add disabled attr if disabled
          var disabledClass = option.disabled ? 'disabled ' : '';
          var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : '';
          var multipleCheckbox = this.isMultiple ? "<label><input type=\"checkbox\"" + disabledClass + "\"/><span>" + option.innerHTML + "</span></label>" : option.innerHTML;
          var liEl = $('<li></li>');
          var spanEl = $('<span></span>');
          spanEl.html(multipleCheckbox);
          liEl.addClass(disabledClass + " " + optgroupClass);
          liEl.append(spanEl);

          // add icons
          var iconUrl = option.getAttribute('data-icon');
          if (!!iconUrl) {
            var imgEl = $("<img alt=\"\" src=\"" + iconUrl + "\">");
            liEl.prepend(imgEl);
          }

          // Check for multiple type.
          $(this.dropdownOptions).append(liEl[0]);
          return liEl[0];
        }

        /**
         * Toggle entry from option
         * @param {String} key  Option key
         * @return {Boolean}  if entry was added or removed
         */

      }, {
        key: "_toggleEntryFromArray",
        value: function _toggleEntryFromArray(key) {
          var notAdded = !this._keysSelected.hasOwnProperty(key);
          var $optionLi = $(this._valueDict[key].optionEl);

          if (notAdded) {
            this._keysSelected[key] = true;
          } else {
            delete this._keysSelected[key];
          }

          $optionLi.toggleClass('selected', notAdded);

          // Set checkbox checked value
          $optionLi.find('input[type="checkbox"]').prop('checked', notAdded);

          // use notAdded instead of true (to detect if the option is selected or not)
          $optionLi.prop('selected', notAdded);

          return notAdded;
        }

        /**
         * Set text value to input
         */

      }, {
        key: "_setValueToInput",
        value: function _setValueToInput() {
          var values = [];
          var options = this.$el.find('option');

          options.each(function (el) {
            if ($(el).prop('selected')) {
              var text = $(el).text();
              values.push(text);
            }
          });

          if (!values.length) {
            var firstDisabled = this.$el.find('option:disabled').eq(0);
            if (firstDisabled.length && firstDisabled[0].value === '') {
              values.push(firstDisabled.text());
            }
          }

          this.input.value = values.join(', ');
        }

        /**
         * Set selected state of dropdown to match actual select element
         */

      }, {
        key: "_setSelectedStates",
        value: function _setSelectedStates() {
          this._keysSelected = {};

          for (var key in this._valueDict) {
            var option = this._valueDict[key];
            var optionIsSelected = $(option.el).prop('selected');
            $(option.optionEl).find('input[type="checkbox"]').prop('checked', optionIsSelected);
            if (optionIsSelected) {
              this._activateOption($(this.dropdownOptions), $(option.optionEl));
              this._keysSelected[key] = true;
            } else {
              $(option.optionEl).removeClass('selected');
            }
          }
        }

        /**
         * Make option as selected and scroll to selected position
         * @param {jQuery} collection  Select options jQuery element
         * @param {Element} newOption  element of the new option
         */

      }, {
        key: "_activateOption",
        value: function _activateOption(collection, newOption) {
          if (newOption) {
            if (!this.isMultiple) {
              collection.find('li.selected').removeClass('selected');
            }
            var option = $(newOption);
            option.addClass('selected');
          }
        }

        /**
         * Get Selected Values
         * @return {Array}  Array of selected values
         */

      }, {
        key: "getSelectedValues",
        value: function getSelectedValues() {
          var selectedValues = [];
          for (var key in this._keysSelected) {
            selectedValues.push(this._valueDict[key].el.value);
          }
          return selectedValues;
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(FormSelect.__proto__ || Object.getPrototypeOf(FormSelect), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_FormSelect;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return FormSelect;
    }(Component);

    M.FormSelect = FormSelect;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(FormSelect, 'formSelect', 'M_FormSelect');
    }
  })(cash);
  (function ($, anim) {

    var _defaults = {};

    /**
     * @class
     *
     */

    var Range = function (_Component21) {
      _inherits(Range, _Component21);

      /**
       * Construct Range instance
       * @constructor
       * @param {Element} el
       * @param {Object} options
       */
      function Range(el, options) {
        _classCallCheck(this, Range);

        var _this72 = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, Range, el, options));

        _this72.el.M_Range = _this72;

        /**
         * Options for the range
         * @member Range#options
         */
        _this72.options = $.extend({}, Range.defaults, options);

        _this72._mousedown = false;

        // Setup
        _this72._setupThumb();

        _this72._setupEventHandlers();
        return _this72;
      }

      _createClass(Range, [{
        key: "destroy",


        /**
         * Teardown component
         */
        value: function destroy() {
          this._removeEventHandlers();
          this._removeThumb();
          this.el.M_Range = undefined;
        }

        /**
         * Setup Event Handlers
         */

      }, {
        key: "_setupEventHandlers",
        value: function _setupEventHandlers() {
          this._handleRangeChangeBound = this._handleRangeChange.bind(this);
          this._handleRangeMousedownTouchstartBound = this._handleRangeMousedownTouchstart.bind(this);
          this._handleRangeInputMousemoveTouchmoveBound = this._handleRangeInputMousemoveTouchmove.bind(this);
          this._handleRangeMouseupTouchendBound = this._handleRangeMouseupTouchend.bind(this);
          this._handleRangeBlurMouseoutTouchleaveBound = this._handleRangeBlurMouseoutTouchleave.bind(this);

          this.el.addEventListener('change', this._handleRangeChangeBound);

          this.el.addEventListener('mousedown', this._handleRangeMousedownTouchstartBound);
          this.el.addEventListener('touchstart', this._handleRangeMousedownTouchstartBound);

          this.el.addEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);
          this.el.addEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);
          this.el.addEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);

          this.el.addEventListener('mouseup', this._handleRangeMouseupTouchendBound);
          this.el.addEventListener('touchend', this._handleRangeMouseupTouchendBound);

          this.el.addEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);
          this.el.addEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);
          this.el.addEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);
        }

        /**
         * Remove Event Handlers
         */

      }, {
        key: "_removeEventHandlers",
        value: function _removeEventHandlers() {
          this.el.removeEventListener('change', this._handleRangeChangeBound);

          this.el.removeEventListener('mousedown', this._handleRangeMousedownTouchstartBound);
          this.el.removeEventListener('touchstart', this._handleRangeMousedownTouchstartBound);

          this.el.removeEventListener('input', this._handleRangeInputMousemoveTouchmoveBound);
          this.el.removeEventListener('mousemove', this._handleRangeInputMousemoveTouchmoveBound);
          this.el.removeEventListener('touchmove', this._handleRangeInputMousemoveTouchmoveBound);

          this.el.removeEventListener('mouseup', this._handleRangeMouseupTouchendBound);
          this.el.removeEventListener('touchend', this._handleRangeMouseupTouchendBound);

          this.el.removeEventListener('blur', this._handleRangeBlurMouseoutTouchleaveBound);
          this.el.removeEventListener('mouseout', this._handleRangeBlurMouseoutTouchleaveBound);
          this.el.removeEventListener('touchleave', this._handleRangeBlurMouseoutTouchleaveBound);
        }

        /**
         * Handle Range Change
         * @param {Event} e
         */

      }, {
        key: "_handleRangeChange",
        value: function _handleRangeChange() {
          $(this.value).html(this.$el.val());

          if (!$(this.thumb).hasClass('active')) {
            this._showRangeBubble();
          }

          var offsetLeft = this._calcRangeOffset();
          $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
        }

        /**
         * Handle Range Mousedown and Touchstart
         * @param {Event} e
         */

      }, {
        key: "_handleRangeMousedownTouchstart",
        value: function _handleRangeMousedownTouchstart(e) {
          // Set indicator value
          $(this.value).html(this.$el.val());

          this._mousedown = true;
          this.$el.addClass('active');

          if (!$(this.thumb).hasClass('active')) {
            this._showRangeBubble();
          }

          if (e.type !== 'input') {
            var offsetLeft = this._calcRangeOffset();
            $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
          }
        }

        /**
         * Handle Range Input, Mousemove and Touchmove
         */

      }, {
        key: "_handleRangeInputMousemoveTouchmove",
        value: function _handleRangeInputMousemoveTouchmove() {
          if (this._mousedown) {
            if (!$(this.thumb).hasClass('active')) {
              this._showRangeBubble();
            }

            var offsetLeft = this._calcRangeOffset();
            $(this.thumb).addClass('active').css('left', offsetLeft + 'px');
            $(this.value).html(this.$el.val());
          }
        }

        /**
         * Handle Range Mouseup and Touchend
         */

      }, {
        key: "_handleRangeMouseupTouchend",
        value: function _handleRangeMouseupTouchend() {
          this._mousedown = false;
          this.$el.removeClass('active');
        }

        /**
         * Handle Range Blur, Mouseout and Touchleave
         */

      }, {
        key: "_handleRangeBlurMouseoutTouchleave",
        value: function _handleRangeBlurMouseoutTouchleave() {
          if (!this._mousedown) {
            var paddingLeft = parseInt(this.$el.css('padding-left'));
            var marginLeft = 7 + paddingLeft + 'px';

            if ($(this.thumb).hasClass('active')) {
              anim.remove(this.thumb);
              anim({
                targets: this.thumb,
                height: 0,
                width: 0,
                top: 10,
                easing: 'easeOutQuad',
                marginLeft: marginLeft,
                duration: 100
              });
            }
            $(this.thumb).removeClass('active');
          }
        }

        /**
         * Setup dropdown
         */

      }, {
        key: "_setupThumb",
        value: function _setupThumb() {
          this.thumb = document.createElement('span');
          this.value = document.createElement('span');
          $(this.thumb).addClass('thumb');
          $(this.value).addClass('value');
          $(this.thumb).append(this.value);
          this.$el.after(this.thumb);
        }

        /**
         * Remove dropdown
         */

      }, {
        key: "_removeThumb",
        value: function _removeThumb() {
          $(this.thumb).remove();
        }

        /**
         * morph thumb into bubble
         */

      }, {
        key: "_showRangeBubble",
        value: function _showRangeBubble() {
          var paddingLeft = parseInt($(this.thumb).parent().css('padding-left'));
          var marginLeft = -7 + paddingLeft + 'px'; // TODO: fix magic number?
          anim.remove(this.thumb);
          anim({
            targets: this.thumb,
            height: 30,
            width: 30,
            top: -30,
            marginLeft: marginLeft,
            duration: 300,
            easing: 'easeOutQuint'
          });
        }

        /**
         * Calculate the offset of the thumb
         * @return {Number}  offset in pixels
         */

      }, {
        key: "_calcRangeOffset",
        value: function _calcRangeOffset() {
          var width = this.$el.width() - 15;
          var max = parseFloat(this.$el.attr('max')) || 100; // Range default max
          var min = parseFloat(this.$el.attr('min')) || 0; // Range default min
          var percent = (parseFloat(this.$el.val()) - min) / (max - min);
          return percent * width;
        }
      }], [{
        key: "init",
        value: function init(els, options) {
          return _get(Range.__proto__ || Object.getPrototypeOf(Range), "init", this).call(this, this, els, options);
        }

        /**
         * Get Instance
         */

      }, {
        key: "getInstance",
        value: function getInstance(el) {
          var domElem = !!el.jquery ? el[0] : el;
          return domElem.M_Range;
        }
      }, {
        key: "defaults",
        get: function () {
          return _defaults;
        }
      }]);

      return Range;
    }(Component);

    M.Range = Range;

    if (M.jQueryLoaded) {
      M.initializeJqueryWrapper(Range, 'range', 'M_Range');
    }

    Range.init($('input[type=range]'));
  })(cash, M.anime);
  });

  function noop() { }
  const identity = x => x;
  function assign(tar, src) {
      // @ts-ignore
      for (const k in src)
          tar[k] = src[k];
      return tar;
  }
  function add_location(element, file, line, column, char) {
      element.__svelte_meta = {
          loc: { file, line, column, char }
      };
  }
  function run(fn) {
      return fn();
  }
  function blank_object() {
      return Object.create(null);
  }
  function run_all(fns) {
      fns.forEach(run);
  }
  function is_function(thing) {
      return typeof thing === 'function';
  }
  function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
  }
  function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== 'function') {
          throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
  }
  function subscribe(store, ...callbacks) {
      if (store == null) {
          return noop;
      }
      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe(store, callback));
  }
  function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
          const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
          return definition[0](slot_ctx);
      }
  }
  function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn
          ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
          : $$scope.ctx;
  }
  function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
          const lets = definition[2](fn(dirty));
          if ($$scope.dirty === undefined) {
              return lets;
          }
          if (typeof lets === 'object') {
              const merged = [];
              const len = Math.max($$scope.dirty.length, lets.length);
              for (let i = 0; i < len; i += 1) {
                  merged[i] = $$scope.dirty[i] | lets[i];
              }
              return merged;
          }
          return $$scope.dirty | lets;
      }
      return $$scope.dirty;
  }
  function exclude_internal_props(props) {
      const result = {};
      for (const k in props)
          if (k[0] !== '$')
              result[k] = props[k];
      return result;
  }
  function null_to_empty(value) {
      return value == null ? '' : value;
  }
  function set_store_value(store, ret, value = ret) {
      store.set(value);
      return ret;
  }

  function append(target, node) {
      target.appendChild(node);
  }
  function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
  }
  function detach(node) {
      node.parentNode.removeChild(node);
  }
  function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
          if (iterations[i])
              iterations[i].d(detaching);
      }
  }
  function element(name) {
      return document.createElement(name);
  }
  function svg_element(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
  }
  function text(data) {
      return document.createTextNode(data);
  }
  function space() {
      return text(' ');
  }
  function empty() {
      return text('');
  }
  function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
  }
  function attr(node, attribute, value) {
      if (value == null)
          node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
          node.setAttribute(attribute, value);
  }
  function set_attributes(node, attributes) {
      // @ts-ignore
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
          if (attributes[key] == null) {
              node.removeAttribute(key);
          }
          else if (key === 'style') {
              node.style.cssText = attributes[key];
          }
          else if (key === '__value') {
              node.value = node[key] = attributes[key];
          }
          else if (descriptors[key] && descriptors[key].set) {
              node[key] = attributes[key];
          }
          else {
              attr(node, key, attributes[key]);
          }
      }
  }
  function children(element) {
      return Array.from(element.childNodes);
  }
  function set_input_value(input, value) {
      if (value != null || input.value) {
          input.value = value;
      }
  }
  function select_option(select, value) {
      for (let i = 0; i < select.options.length; i += 1) {
          const option = select.options[i];
          if (option.__value === value) {
              option.selected = true;
              return;
          }
      }
  }
  function select_value(select) {
      const selected_option = select.querySelector(':checked') || select.options[0];
      return selected_option && selected_option.__value;
  }
  function custom_event(type, detail) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, false, false, detail);
      return e;
  }

  let current_component;
  function set_current_component(component) {
      current_component = component;
  }
  function get_current_component() {
      if (!current_component)
          throw new Error(`Function called outside component initialization`);
      return current_component;
  }
  function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
  }
  function afterUpdate(fn) {
      get_current_component().$$.after_update.push(fn);
  }
  function onDestroy(fn) {
      get_current_component().$$.on_destroy.push(fn);
  }
  function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail) => {
          const callbacks = component.$$.callbacks[type];
          if (callbacks) {
              // TODO are there situations where events could be dispatched
              // in a server (non-DOM) environment?
              const event = custom_event(type, detail);
              callbacks.slice().forEach(fn => {
                  fn.call(component, event);
              });
          }
      };
  }
  function setContext(key, context) {
      get_current_component().$$.context.set(key, context);
  }
  function getContext(key) {
      return get_current_component().$$.context.get(key);
  }
  // TODO figure out if we still want to support
  // shorthand events, or if we want to implement
  // a real bubbling mechanism
  function bubble(component, event) {
      const callbacks = component.$$.callbacks[event.type];
      if (callbacks) {
          callbacks.slice().forEach(fn => fn(event));
      }
  }

  const dirty_components = [];
  const binding_callbacks = [];
  const render_callbacks = [];
  const flush_callbacks = [];
  const resolved_promise = Promise.resolve();
  let update_scheduled = false;
  function schedule_update() {
      if (!update_scheduled) {
          update_scheduled = true;
          resolved_promise.then(flush);
      }
  }
  function add_render_callback(fn) {
      render_callbacks.push(fn);
  }
  let flushing = false;
  const seen_callbacks = new Set();
  function flush() {
      if (flushing)
          return;
      flushing = true;
      do {
          // first, call beforeUpdate functions
          // and update components
          for (let i = 0; i < dirty_components.length; i += 1) {
              const component = dirty_components[i];
              set_current_component(component);
              update(component.$$);
          }
          dirty_components.length = 0;
          while (binding_callbacks.length)
              binding_callbacks.pop()();
          // then, once components are updated, call
          // afterUpdate functions. This may cause
          // subsequent updates...
          for (let i = 0; i < render_callbacks.length; i += 1) {
              const callback = render_callbacks[i];
              if (!seen_callbacks.has(callback)) {
                  // ...so guard against infinite loops
                  seen_callbacks.add(callback);
                  callback();
              }
          }
          render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
          flush_callbacks.pop()();
      }
      update_scheduled = false;
      flushing = false;
      seen_callbacks.clear();
  }
  function update($$) {
      if ($$.fragment !== null) {
          $$.update();
          run_all($$.before_update);
          const dirty = $$.dirty;
          $$.dirty = [-1];
          $$.fragment && $$.fragment.p($$.ctx, dirty);
          $$.after_update.forEach(add_render_callback);
      }
  }
  const outroing = new Set();
  let outros;
  function group_outros() {
      outros = {
          r: 0,
          c: [],
          p: outros // parent group
      };
  }
  function check_outros() {
      if (!outros.r) {
          run_all(outros.c);
      }
      outros = outros.p;
  }
  function transition_in(block, local) {
      if (block && block.i) {
          outroing.delete(block);
          block.i(local);
      }
  }
  function transition_out(block, local, detach, callback) {
      if (block && block.o) {
          if (outroing.has(block))
              return;
          outroing.add(block);
          outros.c.push(() => {
              outroing.delete(block);
              if (callback) {
                  if (detach)
                      block.d(1);
                  callback();
              }
          });
          block.o(local);
      }
  }

  const globals = (typeof window !== 'undefined'
      ? window
      : typeof globalThis !== 'undefined'
          ? globalThis
          : global);

  function get_spread_update(levels, updates) {
      const update = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i = levels.length;
      while (i--) {
          const o = levels[i];
          const n = updates[i];
          if (n) {
              for (const key in o) {
                  if (!(key in n))
                      to_null_out[key] = 1;
              }
              for (const key in n) {
                  if (!accounted_for[key]) {
                      update[key] = n[key];
                      accounted_for[key] = 1;
                  }
              }
              levels[i] = n;
          }
          else {
              for (const key in o) {
                  accounted_for[key] = 1;
              }
          }
      }
      for (const key in to_null_out) {
          if (!(key in update))
              update[key] = undefined;
      }
      return update;
  }
  function get_spread_object(spread_props) {
      return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
  }
  function create_component(block) {
      block && block.c();
  }
  function mount_component(component, target, anchor) {
      const { fragment, on_mount, on_destroy, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      // onMount happens before the initial afterUpdate
      add_render_callback(() => {
          const new_on_destroy = on_mount.map(run).filter(is_function);
          if (on_destroy) {
              on_destroy.push(...new_on_destroy);
          }
          else {
              // Edge case - component was destroyed immediately,
              // most likely as a result of a binding initialising
              run_all(new_on_destroy);
          }
          component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
          run_all($$.on_destroy);
          $$.fragment && $$.fragment.d(detaching);
          // TODO null out other refs, including component.$$ (but need to
          // preserve final state?)
          $$.on_destroy = $$.fragment = null;
          $$.ctx = [];
      }
  }
  function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
          dirty_components.push(component);
          schedule_update();
          component.$$.dirty.fill(0);
      }
      component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
  }
  function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const prop_values = options.props || {};
      const $$ = component.$$ = {
          fragment: null,
          ctx: null,
          // state
          props,
          update: noop,
          not_equal,
          bound: blank_object(),
          // lifecycle
          on_mount: [],
          on_destroy: [],
          before_update: [],
          after_update: [],
          context: new Map(parent_component ? parent_component.$$.context : []),
          // everything else
          callbacks: blank_object(),
          dirty
      };
      let ready = false;
      $$.ctx = instance
          ? instance(component, prop_values, (i, ret, ...rest) => {
              const value = rest.length ? rest[0] : ret;
              if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                  if ($$.bound[i])
                      $$.bound[i](value);
                  if (ready)
                      make_dirty(component, i);
              }
              return ret;
          })
          : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      // `false` as a special case of no DOM component
      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
      if (options.target) {
          if (options.hydrate) {
              const nodes = children(options.target);
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.l(nodes);
              nodes.forEach(detach);
          }
          else {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.c();
          }
          if (options.intro)
              transition_in(component.$$.fragment);
          mount_component(component, options.target, options.anchor);
          flush();
      }
      set_current_component(parent_component);
  }
  class SvelteComponent {
      $destroy() {
          destroy_component(this, 1);
          this.$destroy = noop;
      }
      $on(type, callback) {
          const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
          callbacks.push(callback);
          return () => {
              const index = callbacks.indexOf(callback);
              if (index !== -1)
                  callbacks.splice(index, 1);
          };
      }
      $set() {
          // overridden by instance, if it has props
      }
  }

  function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, Object.assign({ version: '3.22.3' }, detail)));
  }
  function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append(target, node);
  }
  function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert(target, node, anchor);
  }
  function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", { node });
      detach(node);
  }
  function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default)
          modifiers.push('preventDefault');
      if (has_stop_propagation)
          modifiers.push('stopPropagation');
      dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
      const dispose = listen(node, event, handler, options);
      return () => {
          dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
          dispose();
      };
  }
  function attr_dev(node, attribute, value) {
      attr(node, attribute, value);
      if (value == null)
          dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
      else
          dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
  }
  function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", { node, property, value });
  }
  function set_data_dev(text, data) {
      data = '' + data;
      if (text.data === data)
          return;
      dispatch_dev("SvelteDOMSetData", { node: text, data });
      text.data = data;
  }
  function validate_each_argument(arg) {
      if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
          let msg = '{#each} only iterates over array-like objects.';
          if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
              msg += ' You can use a spread to convert this iterable into an array.';
          }
          throw new Error(msg);
      }
  }
  function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
          if (!~keys.indexOf(slot_key)) {
              console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
          }
      }
  }
  class SvelteComponentDev extends SvelteComponent {
      constructor(options) {
          if (!options || (!options.target && !options.$$inline)) {
              throw new Error(`'target' is a required option`);
          }
          super();
      }
      $destroy() {
          super.$destroy();
          this.$destroy = () => {
              console.warn(`Component was already destroyed`); // eslint-disable-line no-console
          };
      }
      $capture_state() { }
      $inject_state() { }
  }

  /* src/game/Sprites.svelte generated by Svelte v3.22.3 */

  const file = "src/game/Sprites.svelte";

  function create_fragment(ctx) {
  	let div1;
  	let div0;
  	let div0_class_value;

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			div0 = element("div");
  			attr_dev(div0, "class", div0_class_value = "" + (null_to_empty(/*item*/ ctx[0]) + " svelte-1qscu32"));
  			add_location(div0, file, 27, 2, 486);
  			attr_dev(div1, "class", "container svelte-1qscu32");
  			add_location(div1, file, 26, 0, 460);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			append_dev(div1, div0);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*item*/ 1 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*item*/ ctx[0]) + " svelte-1qscu32"))) {
  				attr_dev(div0, "class", div0_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance($$self, $$props, $$invalidate) {
  	let { item = "weapon" } = $$props;
  	const writable_props = ["item"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Sprites> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Sprites", $$slots, []);

  	$$self.$set = $$props => {
  		if ("item" in $$props) $$invalidate(0, item = $$props.item);
  	};

  	$$self.$capture_state = () => ({ item });

  	$$self.$inject_state = $$props => {
  		if ("item" in $$props) $$invalidate(0, item = $$props.item);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [item];
  }

  class Sprites extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance, create_fragment, safe_not_equal, { item: 0 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Sprites",
  			options,
  			id: create_fragment.name
  		});
  	}

  	get item() {
  		throw new Error("<Sprites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set item(value) {
  		throw new Error("<Sprites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/Credits.svelte generated by Svelte v3.22.3 */

  const file$1 = "src/Credits.svelte";

  function create_fragment$1(ctx) {
  	let h4;
  	let t1;
  	let ul;
  	let li;
  	let a;
  	let t3;

  	const block = {
  		c: function create() {
  			h4 = element("h4");
  			h4.textContent = "Credits";
  			t1 = space();
  			ul = element("ul");
  			li = element("li");
  			a = element("a");
  			a.textContent = "https://opengameart.org/content/32x32-fantasy-portrait-set";
  			t3 = text("\n    by CobraLad");
  			add_location(h4, file$1, 12, 0, 85);
  			attr_dev(a, "href", "https://opengameart.org/content/32x32-fantasy-portrait-set");
  			add_location(a, file$1, 15, 4, 164);
  			attr_dev(li, "class", "collection-item bg svelte-1ap35t3");
  			add_location(li, file$1, 14, 2, 128);
  			attr_dev(ul, "class", "collection");
  			add_location(ul, file$1, 13, 0, 102);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, h4, anchor);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, ul, anchor);
  			append_dev(ul, li);
  			append_dev(li, a);
  			append_dev(li, t3);
  		},
  		p: noop,
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(h4);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(ul);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$1.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$1($$self, $$props) {
  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Credits> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Credits", $$slots, []);
  	return [];
  }

  class Credits extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Credits",
  			options,
  			id: create_fragment$1.name
  		});
  	}
  }

  const subscriber_queue = [];
  /**
   * Creates a `Readable` store that allows reading by subscription.
   * @param value initial value
   * @param {StartStopNotifier}start start and stop notifications for subscriptions
   */
  function readable(value, start) {
      return {
          subscribe: writable(value, start).subscribe,
      };
  }
  /**
   * Create a `Writable` store that allows both updating and reading by subscription.
   * @param {*=}value initial value
   * @param {StartStopNotifier=}start start and stop notifications for subscriptions
   */
  function writable(value, start = noop) {
      let stop;
      const subscribers = [];
      function set(new_value) {
          if (safe_not_equal(value, new_value)) {
              value = new_value;
              if (stop) { // store is ready
                  const run_queue = !subscriber_queue.length;
                  for (let i = 0; i < subscribers.length; i += 1) {
                      const s = subscribers[i];
                      s[1]();
                      subscriber_queue.push(s, value);
                  }
                  if (run_queue) {
                      for (let i = 0; i < subscriber_queue.length; i += 2) {
                          subscriber_queue[i][0](subscriber_queue[i + 1]);
                      }
                      subscriber_queue.length = 0;
                  }
              }
          }
      }
      function update(fn) {
          set(fn(value));
      }
      function subscribe(run, invalidate = noop) {
          const subscriber = [run, invalidate];
          subscribers.push(subscriber);
          if (subscribers.length === 1) {
              stop = start(set) || noop;
          }
          run(value);
          return () => {
              const index = subscribers.indexOf(subscriber);
              if (index !== -1) {
                  subscribers.splice(index, 1);
              }
              if (subscribers.length === 0) {
                  stop();
                  stop = null;
              }
          };
      }
      return { set, update, subscribe };
  }
  function derived(stores, fn, initial_value) {
      const single = !Array.isArray(stores);
      const stores_array = single
          ? [stores]
          : stores;
      const auto = fn.length < 2;
      return readable(initial_value, (set) => {
          let inited = false;
          const values = [];
          let pending = 0;
          let cleanup = noop;
          const sync = () => {
              if (pending) {
                  return;
              }
              cleanup();
              const result = fn(single ? values[0] : values, set);
              if (auto) {
                  set(result);
              }
              else {
                  cleanup = is_function(result) ? result : noop;
              }
          };
          const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
              values[i] = value;
              pending &= ~(1 << i);
              if (inited) {
                  sync();
              }
          }, () => {
              pending |= (1 << i);
          }));
          inited = true;
          sync();
          return function stop() {
              run_all(unsubscribers);
              cleanup();
          };
      });
  }

  const LOCATION = {};
  const ROUTER = {};

  /**
   * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
   *
   * https://github.com/reach/router/blob/master/LICENSE
   * */

  function getLocation(source) {
    return {
      ...source.location,
      state: source.history.state,
      key: (source.history.state && source.history.state.key) || "initial"
    };
  }

  function createHistory(source, options) {
    const listeners = [];
    let location = getLocation(source);

    return {
      get location() {
        return location;
      },

      listen(listener) {
        listeners.push(listener);

        const popstateListener = () => {
          location = getLocation(source);
          listener({ location, action: "POP" });
        };

        source.addEventListener("popstate", popstateListener);

        return () => {
          source.removeEventListener("popstate", popstateListener);

          const index = listeners.indexOf(listener);
          listeners.splice(index, 1);
        };
      },

      navigate(to, { state, replace = false } = {}) {
        state = { ...state, key: Date.now() + "" };
        // try...catch iOS Safari limits to 100 pushState calls
        try {
          if (replace) {
            source.history.replaceState(state, null, to);
          } else {
            source.history.pushState(state, null, to);
          }
        } catch (e) {
          source.location[replace ? "replace" : "assign"](to);
        }

        location = getLocation(source);
        listeners.forEach(listener => listener({ location, action: "PUSH" }));
      }
    };
  }

  // Stores history entries in memory for testing or other platforms like Native
  function createMemorySource(initialPathname = "/") {
    let index = 0;
    const stack = [{ pathname: initialPathname, search: "" }];
    const states = [];

    return {
      get location() {
        return stack[index];
      },
      addEventListener(name, fn) {},
      removeEventListener(name, fn) {},
      history: {
        get entries() {
          return stack;
        },
        get index() {
          return index;
        },
        get state() {
          return states[index];
        },
        pushState(state, _, uri) {
          const [pathname, search = ""] = uri.split("?");
          index++;
          stack.push({ pathname, search });
          states.push(state);
        },
        replaceState(state, _, uri) {
          const [pathname, search = ""] = uri.split("?");
          stack[index] = { pathname, search };
          states[index] = state;
        }
      }
    };
  }

  // Global history uses window.history as the source if available,
  // otherwise a memory history
  const canUseDOM = Boolean(
    typeof window !== "undefined" &&
      window.document &&
      window.document.createElement
  );
  const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
  const { navigate } = globalHistory;

  /**
   * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
   *
   * https://github.com/reach/router/blob/master/LICENSE
   * */

  const paramRe = /^:(.+)/;

  const SEGMENT_POINTS = 4;
  const STATIC_POINTS = 3;
  const DYNAMIC_POINTS = 2;
  const SPLAT_PENALTY = 1;
  const ROOT_POINTS = 1;

  /**
   * Check if `string` starts with `search`
   * @param {string} string
   * @param {string} search
   * @return {boolean}
   */
  function startsWith(string, search) {
    return string.substr(0, search.length) === search;
  }

  /**
   * Check if `segment` is a root segment
   * @param {string} segment
   * @return {boolean}
   */
  function isRootSegment(segment) {
    return segment === "";
  }

  /**
   * Check if `segment` is a dynamic segment
   * @param {string} segment
   * @return {boolean}
   */
  function isDynamic(segment) {
    return paramRe.test(segment);
  }

  /**
   * Check if `segment` is a splat
   * @param {string} segment
   * @return {boolean}
   */
  function isSplat(segment) {
    return segment[0] === "*";
  }

  /**
   * Split up the URI into segments delimited by `/`
   * @param {string} uri
   * @return {string[]}
   */
  function segmentize(uri) {
    return (
      uri
        // Strip starting/ending `/`
        .replace(/(^\/+|\/+$)/g, "")
        .split("/")
    );
  }

  /**
   * Strip `str` of potential start and end `/`
   * @param {string} str
   * @return {string}
   */
  function stripSlashes(str) {
    return str.replace(/(^\/+|\/+$)/g, "");
  }

  /**
   * Score a route depending on how its individual segments look
   * @param {object} route
   * @param {number} index
   * @return {object}
   */
  function rankRoute(route, index) {
    const score = route.default
      ? 0
      : segmentize(route.path).reduce((score, segment) => {
          score += SEGMENT_POINTS;

          if (isRootSegment(segment)) {
            score += ROOT_POINTS;
          } else if (isDynamic(segment)) {
            score += DYNAMIC_POINTS;
          } else if (isSplat(segment)) {
            score -= SEGMENT_POINTS + SPLAT_PENALTY;
          } else {
            score += STATIC_POINTS;
          }

          return score;
        }, 0);

    return { route, score, index };
  }

  /**
   * Give a score to all routes and sort them on that
   * @param {object[]} routes
   * @return {object[]}
   */
  function rankRoutes(routes) {
    return (
      routes
        .map(rankRoute)
        // If two routes have the exact same score, we go by index instead
        .sort((a, b) =>
          a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
        )
    );
  }

  /**
   * Ranks and picks the best route to match. Each segment gets the highest
   * amount of points, then the type of segment gets an additional amount of
   * points where
   *
   *  static > dynamic > splat > root
   *
   * This way we don't have to worry about the order of our routes, let the
   * computers do it.
   *
   * A route looks like this
   *
   *  { path, default, value }
   *
   * And a returned match looks like:
   *
   *  { route, params, uri }
   *
   * @param {object[]} routes
   * @param {string} uri
   * @return {?object}
   */
  function pick(routes, uri) {
    let match;
    let default_;

    const [uriPathname] = uri.split("?");
    const uriSegments = segmentize(uriPathname);
    const isRootUri = uriSegments[0] === "";
    const ranked = rankRoutes(routes);

    for (let i = 0, l = ranked.length; i < l; i++) {
      const route = ranked[i].route;
      let missed = false;

      if (route.default) {
        default_ = {
          route,
          params: {},
          uri
        };
        continue;
      }

      const routeSegments = segmentize(route.path);
      const params = {};
      const max = Math.max(uriSegments.length, routeSegments.length);
      let index = 0;

      for (; index < max; index++) {
        const routeSegment = routeSegments[index];
        const uriSegment = uriSegments[index];

        if (routeSegment !== undefined && isSplat(routeSegment)) {
          // Hit a splat, just grab the rest, and return a match
          // uri:   /files/documents/work
          // route: /files/* or /files/*splatname
          const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

          params[splatName] = uriSegments
            .slice(index)
            .map(decodeURIComponent)
            .join("/");
          break;
        }

        if (uriSegment === undefined) {
          // URI is shorter than the route, no match
          // uri:   /users
          // route: /users/:userId
          missed = true;
          break;
        }

        let dynamicMatch = paramRe.exec(routeSegment);

        if (dynamicMatch && !isRootUri) {
          const value = decodeURIComponent(uriSegment);
          params[dynamicMatch[1]] = value;
        } else if (routeSegment !== uriSegment) {
          // Current segments don't match, not dynamic, not splat, so no match
          // uri:   /users/123/settings
          // route: /users/:id/profile
          missed = true;
          break;
        }
      }

      if (!missed) {
        match = {
          route,
          params,
          uri: "/" + uriSegments.slice(0, index).join("/")
        };
        break;
      }
    }

    return match || default_ || null;
  }

  /**
   * Check if the `path` matches the `uri`.
   * @param {string} path
   * @param {string} uri
   * @return {?object}
   */
  function match(route, uri) {
    return pick([route], uri);
  }

  /**
   * Add the query to the pathname if a query is given
   * @param {string} pathname
   * @param {string} [query]
   * @return {string}
   */
  function addQuery(pathname, query) {
    return pathname + (query ? `?${query}` : "");
  }

  /**
   * Resolve URIs as though every path is a directory, no files. Relative URIs
   * in the browser can feel awkward because not only can you be "in a directory",
   * you can be "at a file", too. For example:
   *
   *  browserSpecResolve('foo', '/bar/') => /bar/foo
   *  browserSpecResolve('foo', '/bar') => /foo
   *
   * But on the command line of a file system, it's not as complicated. You can't
   * `cd` from a file, only directories. This way, links have to know less about
   * their current path. To go deeper you can do this:
   *
   *  <Link to="deeper"/>
   *  // instead of
   *  <Link to=`{${props.uri}/deeper}`/>
   *
   * Just like `cd`, if you want to go deeper from the command line, you do this:
   *
   *  cd deeper
   *  # not
   *  cd $(pwd)/deeper
   *
   * By treating every path as a directory, linking to relative paths should
   * require less contextual information and (fingers crossed) be more intuitive.
   * @param {string} to
   * @param {string} base
   * @return {string}
   */
  function resolve(to, base) {
    // /foo/bar, /baz/qux => /foo/bar
    if (startsWith(to, "/")) {
      return to;
    }

    const [toPathname, toQuery] = to.split("?");
    const [basePathname] = base.split("?");
    const toSegments = segmentize(toPathname);
    const baseSegments = segmentize(basePathname);

    // ?a=b, /users?b=c => /users?a=b
    if (toSegments[0] === "") {
      return addQuery(basePathname, toQuery);
    }

    // profile, /users/789 => /users/789/profile
    if (!startsWith(toSegments[0], ".")) {
      const pathname = baseSegments.concat(toSegments).join("/");

      return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
    }

    // ./       , /users/123 => /users/123
    // ../      , /users/123 => /users
    // ../..    , /users/123 => /
    // ../../one, /a/b/c/d   => /a/b/one
    // .././one , /a/b/c/d   => /a/b/c/one
    const allSegments = baseSegments.concat(toSegments);
    const segments = [];

    allSegments.forEach(segment => {
      if (segment === "..") {
        segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });

    return addQuery("/" + segments.join("/"), toQuery);
  }

  /**
   * Combines the `basepath` and the `path` into one path.
   * @param {string} basepath
   * @param {string} path
   */
  function combinePaths(basepath, path) {
    return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
  }

  /**
   * Decides whether a given `event` should result in a navigation or not.
   * @param {object} event
   */
  function shouldNavigate(event) {
    return (
      !event.defaultPrevented &&
      event.button === 0 &&
      !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    );
  }

  /* node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.22.3 */

  function create_fragment$2(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[16].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32768) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$2.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$2($$self, $$props, $$invalidate) {
  	let $base;
  	let $location;
  	let $routes;
  	let { basepath = "/" } = $$props;
  	let { url = null } = $$props;
  	const locationContext = getContext(LOCATION);
  	const routerContext = getContext(ROUTER);
  	const routes = writable([]);
  	validate_store(routes, "routes");
  	component_subscribe($$self, routes, value => $$invalidate(8, $routes = value));
  	const activeRoute = writable(null);
  	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

  	// If locationContext is not set, this is the topmost Router in the tree.
  	// If the `url` prop is given we force the location to it.
  	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

  	validate_store(location, "location");
  	component_subscribe($$self, location, value => $$invalidate(7, $location = value));

  	// If routerContext is set, the routerBase of the parent Router
  	// will be the base for this Router's descendants.
  	// If routerContext is not set, the path and resolved uri will both
  	// have the value of the basepath prop.
  	const base = routerContext
  	? routerContext.routerBase
  	: writable({ path: basepath, uri: basepath });

  	validate_store(base, "base");
  	component_subscribe($$self, base, value => $$invalidate(6, $base = value));

  	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
  		// If there is no activeRoute, the routerBase will be identical to the base.
  		if (activeRoute === null) {
  			return base;
  		}

  		const { path: basepath } = base;
  		const { route, uri } = activeRoute;

  		// Remove the potential /* or /*splatname from
  		// the end of the child Routes relative paths.
  		const path = route.default
  		? basepath
  		: route.path.replace(/\*.*$/, "");

  		return { path, uri };
  	});

  	function registerRoute(route) {
  		const { path: basepath } = $base;
  		let { path } = route;

  		// We store the original path in the _path property so we can reuse
  		// it when the basepath changes. The only thing that matters is that
  		// the route reference is intact, so mutation is fine.
  		route._path = path;

  		route.path = combinePaths(basepath, path);

  		if (typeof window === "undefined") {
  			// In SSR we should set the activeRoute immediately if it is a match.
  			// If there are more Routes being registered after a match is found,
  			// we just skip them.
  			if (hasActiveRoute) {
  				return;
  			}

  			const matchingRoute = match(route, $location.pathname);

  			if (matchingRoute) {
  				activeRoute.set(matchingRoute);
  				hasActiveRoute = true;
  			}
  		} else {
  			routes.update(rs => {
  				rs.push(route);
  				return rs;
  			});
  		}
  	}

  	function unregisterRoute(route) {
  		routes.update(rs => {
  			const index = rs.indexOf(route);
  			rs.splice(index, 1);
  			return rs;
  		});
  	}

  	if (!locationContext) {
  		// The topmost Router in the tree is responsible for updating
  		// the location store and supplying it through context.
  		onMount(() => {
  			const unlisten = globalHistory.listen(history => {
  				location.set(history.location);
  			});

  			return unlisten;
  		});

  		setContext(LOCATION, location);
  	}

  	setContext(ROUTER, {
  		activeRoute,
  		base,
  		routerBase,
  		registerRoute,
  		unregisterRoute
  	});

  	const writable_props = ["basepath", "url"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Router", $$slots, ['default']);

  	$$self.$set = $$props => {
  		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
  		if ("url" in $$props) $$invalidate(4, url = $$props.url);
  		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		getContext,
  		setContext,
  		onMount,
  		writable,
  		derived,
  		LOCATION,
  		ROUTER,
  		globalHistory,
  		pick,
  		match,
  		stripSlashes,
  		combinePaths,
  		basepath,
  		url,
  		locationContext,
  		routerContext,
  		routes,
  		activeRoute,
  		hasActiveRoute,
  		location,
  		base,
  		routerBase,
  		registerRoute,
  		unregisterRoute,
  		$base,
  		$location,
  		$routes
  	});

  	$$self.$inject_state = $$props => {
  		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
  		if ("url" in $$props) $$invalidate(4, url = $$props.url);
  		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$base*/ 64) {
  			// This reactive statement will update all the Routes' path when
  			// the basepath changes.
  			 {
  				const { path: basepath } = $base;

  				routes.update(rs => {
  					rs.forEach(r => r.path = combinePaths(basepath, r._path));
  					return rs;
  				});
  			}
  		}

  		if ($$self.$$.dirty & /*$routes, $location*/ 384) {
  			// This reactive statement will be run when the Router is created
  			// when there are no Routes and then again the following tick, so it
  			// will not find an active Route in SSR and in the browser it will only
  			// pick an active Route after all Routes have been registered.
  			 {
  				const bestMatch = pick($routes, $location.pathname);
  				activeRoute.set(bestMatch);
  			}
  		}
  	};

  	return [
  		routes,
  		location,
  		base,
  		basepath,
  		url,
  		hasActiveRoute,
  		$base,
  		$location,
  		$routes,
  		locationContext,
  		routerContext,
  		activeRoute,
  		routerBase,
  		registerRoute,
  		unregisterRoute,
  		$$scope,
  		$$slots
  	];
  }

  class Router extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$2, create_fragment$2, safe_not_equal, { basepath: 3, url: 4 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Router",
  			options,
  			id: create_fragment$2.name
  		});
  	}

  	get basepath() {
  		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set basepath(value) {
  		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get url() {
  		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set url(value) {
  		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.22.3 */

  const get_default_slot_changes = dirty => ({
  	params: dirty & /*routeParams*/ 2,
  	location: dirty & /*$location*/ 16
  });

  const get_default_slot_context = ctx => ({
  	params: /*routeParams*/ ctx[1],
  	location: /*$location*/ ctx[4]
  });

  // (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
  function create_if_block(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block_1, create_else_block];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*component*/ ctx[0] !== null) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty();
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block.name,
  		type: "if",
  		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
  		ctx
  	});

  	return block;
  }

  // (43:2) {:else}
  function create_else_block(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[13].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 4114) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, get_default_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block.name,
  		type: "else",
  		source: "(43:2) {:else}",
  		ctx
  	});

  	return block;
  }

  // (41:2) {#if component !== null}
  function create_if_block_1(ctx) {
  	let switch_instance_anchor;
  	let current;

  	const switch_instance_spread_levels = [
  		{ location: /*$location*/ ctx[4] },
  		/*routeParams*/ ctx[1],
  		/*routeProps*/ ctx[2]
  	];

  	var switch_value = /*component*/ ctx[0];

  	function switch_props(ctx) {
  		let switch_instance_props = {};

  		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
  			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
  		}

  		return {
  			props: switch_instance_props,
  			$$inline: true
  		};
  	}

  	if (switch_value) {
  		var switch_instance = new switch_value(switch_props());
  	}

  	const block = {
  		c: function create() {
  			if (switch_instance) create_component(switch_instance.$$.fragment);
  			switch_instance_anchor = empty();
  		},
  		m: function mount(target, anchor) {
  			if (switch_instance) {
  				mount_component(switch_instance, target, anchor);
  			}

  			insert_dev(target, switch_instance_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 22)
  			? get_spread_update(switch_instance_spread_levels, [
  					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
  					dirty & /*routeParams*/ 2 && get_spread_object(/*routeParams*/ ctx[1]),
  					dirty & /*routeProps*/ 4 && get_spread_object(/*routeProps*/ ctx[2])
  				])
  			: {};

  			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
  				if (switch_instance) {
  					group_outros();
  					const old_component = switch_instance;

  					transition_out(old_component.$$.fragment, 1, 0, () => {
  						destroy_component(old_component, 1);
  					});

  					check_outros();
  				}

  				if (switch_value) {
  					switch_instance = new switch_value(switch_props());
  					create_component(switch_instance.$$.fragment);
  					transition_in(switch_instance.$$.fragment, 1);
  					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
  				} else {
  					switch_instance = null;
  				}
  			} else if (switch_value) {
  				switch_instance.$set(switch_instance_changes);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(switch_instance_anchor);
  			if (switch_instance) destroy_component(switch_instance, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1.name,
  		type: "if",
  		source: "(41:2) {#if component !== null}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$3(ctx) {
  	let if_block_anchor;
  	let current;
  	let if_block = /*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7] && create_if_block(ctx);

  	const block = {
  		c: function create() {
  			if (if_block) if_block.c();
  			if_block_anchor = empty();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (if_block) if_block.m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (/*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty & /*$activeRoute*/ 8) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(if_block_anchor.parentNode, if_block_anchor);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block) if_block.d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$3.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$3($$self, $$props, $$invalidate) {
  	let $activeRoute;
  	let $location;
  	let { path = "" } = $$props;
  	let { component = null } = $$props;
  	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
  	validate_store(activeRoute, "activeRoute");
  	component_subscribe($$self, activeRoute, value => $$invalidate(3, $activeRoute = value));
  	const location = getContext(LOCATION);
  	validate_store(location, "location");
  	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

  	const route = {
  		path,
  		// If no path prop is given, this Route will act as the default Route
  		// that is rendered if no other Route in the Router is a match.
  		default: path === ""
  	};

  	let routeParams = {};
  	let routeProps = {};
  	registerRoute(route);

  	// There is no need to unregister Routes in SSR since it will all be
  	// thrown away anyway.
  	if (typeof window !== "undefined") {
  		onDestroy(() => {
  			unregisterRoute(route);
  		});
  	}

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Route", $$slots, ['default']);

  	$$self.$set = $$new_props => {
  		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
  		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
  		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		getContext,
  		onDestroy,
  		ROUTER,
  		LOCATION,
  		path,
  		component,
  		registerRoute,
  		unregisterRoute,
  		activeRoute,
  		location,
  		route,
  		routeParams,
  		routeProps,
  		$activeRoute,
  		$location
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
  		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
  		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
  		if ("routeParams" in $$props) $$invalidate(1, routeParams = $$new_props.routeParams);
  		if ("routeProps" in $$props) $$invalidate(2, routeProps = $$new_props.routeProps);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$activeRoute*/ 8) {
  			 if ($activeRoute && $activeRoute.route === route) {
  				$$invalidate(1, routeParams = $activeRoute.params);
  			}
  		}

  		 {
  			const { path, component, ...rest } = $$props;
  			$$invalidate(2, routeProps = rest);
  		}
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		component,
  		routeParams,
  		routeProps,
  		$activeRoute,
  		$location,
  		activeRoute,
  		location,
  		route,
  		path,
  		registerRoute,
  		unregisterRoute,
  		$$props,
  		$$scope,
  		$$slots
  	];
  }

  class Route extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$3, create_fragment$3, safe_not_equal, { path: 8, component: 0 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Route",
  			options,
  			id: create_fragment$3.name
  		});
  	}

  	get path() {
  		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set path(value) {
  		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get component() {
  		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set component(value) {
  		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-routing/src/Link.svelte generated by Svelte v3.22.3 */
  const file$2 = "node_modules/svelte-routing/src/Link.svelte";

  function create_fragment$4(ctx) {
  	let a;
  	let current;
  	let dispose;
  	const default_slot_template = /*$$slots*/ ctx[16].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

  	let a_levels = [
  		{ href: /*href*/ ctx[0] },
  		{ "aria-current": /*ariaCurrent*/ ctx[2] },
  		/*props*/ ctx[1]
  	];

  	let a_data = {};

  	for (let i = 0; i < a_levels.length; i += 1) {
  		a_data = assign(a_data, a_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			a = element("a");
  			if (default_slot) default_slot.c();
  			set_attributes(a, a_data);
  			add_location(a, file$2, 40, 0, 1249);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);

  			if (default_slot) {
  				default_slot.m(a, null);
  			}

  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32768) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
  				}
  			}

  			set_attributes(a, get_spread_update(a_levels, [
  				dirty & /*href*/ 1 && { href: /*href*/ ctx[0] },
  				dirty & /*ariaCurrent*/ 4 && { "aria-current": /*ariaCurrent*/ ctx[2] },
  				dirty & /*props*/ 2 && /*props*/ ctx[1]
  			]));
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (default_slot) default_slot.d(detaching);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$4.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$4($$self, $$props, $$invalidate) {
  	let $base;
  	let $location;
  	let { to = "#" } = $$props;
  	let { replace = false } = $$props;
  	let { state = {} } = $$props;
  	let { getProps = () => ({}) } = $$props;
  	const { base } = getContext(ROUTER);
  	validate_store(base, "base");
  	component_subscribe($$self, base, value => $$invalidate(12, $base = value));
  	const location = getContext(LOCATION);
  	validate_store(location, "location");
  	component_subscribe($$self, location, value => $$invalidate(13, $location = value));
  	const dispatch = createEventDispatcher();
  	let href, isPartiallyCurrent, isCurrent, props;

  	function onClick(event) {
  		dispatch("click", event);

  		if (shouldNavigate(event)) {
  			event.preventDefault();

  			// Don't push another entry to the history stack when the user
  			// clicks on a Link to the page they are currently on.
  			const shouldReplace = $location.pathname === href || replace;

  			navigate(href, { state, replace: shouldReplace });
  		}
  	}

  	const writable_props = ["to", "replace", "state", "getProps"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Link> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Link", $$slots, ['default']);

  	$$self.$set = $$props => {
  		if ("to" in $$props) $$invalidate(6, to = $$props.to);
  		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
  		if ("state" in $$props) $$invalidate(8, state = $$props.state);
  		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
  		if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		getContext,
  		createEventDispatcher,
  		ROUTER,
  		LOCATION,
  		navigate,
  		startsWith,
  		resolve,
  		shouldNavigate,
  		to,
  		replace,
  		state,
  		getProps,
  		base,
  		location,
  		dispatch,
  		href,
  		isPartiallyCurrent,
  		isCurrent,
  		props,
  		onClick,
  		$base,
  		$location,
  		ariaCurrent
  	});

  	$$self.$inject_state = $$props => {
  		if ("to" in $$props) $$invalidate(6, to = $$props.to);
  		if ("replace" in $$props) $$invalidate(7, replace = $$props.replace);
  		if ("state" in $$props) $$invalidate(8, state = $$props.state);
  		if ("getProps" in $$props) $$invalidate(9, getProps = $$props.getProps);
  		if ("href" in $$props) $$invalidate(0, href = $$props.href);
  		if ("isPartiallyCurrent" in $$props) $$invalidate(10, isPartiallyCurrent = $$props.isPartiallyCurrent);
  		if ("isCurrent" in $$props) $$invalidate(11, isCurrent = $$props.isCurrent);
  		if ("props" in $$props) $$invalidate(1, props = $$props.props);
  		if ("ariaCurrent" in $$props) $$invalidate(2, ariaCurrent = $$props.ariaCurrent);
  	};

  	let ariaCurrent;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*to, $base*/ 4160) {
  			 $$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
  		}

  		if ($$self.$$.dirty & /*$location, href*/ 8193) {
  			 $$invalidate(10, isPartiallyCurrent = startsWith($location.pathname, href));
  		}

  		if ($$self.$$.dirty & /*href, $location*/ 8193) {
  			 $$invalidate(11, isCurrent = href === $location.pathname);
  		}

  		if ($$self.$$.dirty & /*isCurrent*/ 2048) {
  			 $$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
  		}

  		if ($$self.$$.dirty & /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 11777) {
  			 $$invalidate(1, props = getProps({
  				location: $location,
  				href,
  				isPartiallyCurrent,
  				isCurrent
  			}));
  		}
  	};

  	return [
  		href,
  		props,
  		ariaCurrent,
  		base,
  		location,
  		onClick,
  		to,
  		replace,
  		state,
  		getProps,
  		isPartiallyCurrent,
  		isCurrent,
  		$base,
  		$location,
  		dispatch,
  		$$scope,
  		$$slots
  	];
  }

  class Link extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$4, create_fragment$4, safe_not_equal, { to: 6, replace: 7, state: 8, getProps: 9 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Link",
  			options,
  			id: create_fragment$4.name
  		});
  	}

  	get to() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set to(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get replace() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set replace(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get state() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set state(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get getProps() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set getProps(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/MediaQuery.svelte generated by Svelte v3.22.3 */
  const get_default_slot_changes$1 = dirty => ({ matches: dirty & /*matches*/ 1 });
  const get_default_slot_context$1 = ctx => ({ matches: /*matches*/ ctx[0] });

  function create_fragment$5(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[8].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$1);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope, matches*/ 129) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$1), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$5.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$5($$self, $$props, $$invalidate) {
  	let { query } = $$props;
  	let mql;
  	let mqlListener;
  	let wasMounted = false;
  	let matches = false;

  	onMount(() => {
  		$$invalidate(4, wasMounted = true);

  		return () => {
  			removeActiveListener();
  		};
  	});

  	function addNewListener(query) {
  		mql = window.matchMedia(query);
  		mqlListener = v => $$invalidate(0, matches = v.matches);
  		mql.addListener(mqlListener);
  		$$invalidate(0, matches = mql.matches);
  	}

  	function removeActiveListener() {
  		if (mql && mqlListener) {
  			mql.removeListener(mqlListener);
  		}
  	}

  	const writable_props = ["query"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MediaQuery> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("MediaQuery", $$slots, ['default']);

  	$$self.$set = $$props => {
  		if ("query" in $$props) $$invalidate(1, query = $$props.query);
  		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		query,
  		mql,
  		mqlListener,
  		wasMounted,
  		matches,
  		addNewListener,
  		removeActiveListener
  	});

  	$$self.$inject_state = $$props => {
  		if ("query" in $$props) $$invalidate(1, query = $$props.query);
  		if ("mql" in $$props) mql = $$props.mql;
  		if ("mqlListener" in $$props) mqlListener = $$props.mqlListener;
  		if ("wasMounted" in $$props) $$invalidate(4, wasMounted = $$props.wasMounted);
  		if ("matches" in $$props) $$invalidate(0, matches = $$props.matches);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*wasMounted, query*/ 18) {
  			 {
  				if (wasMounted) {
  					removeActiveListener();
  					addNewListener(query);
  				}
  			}
  		}
  	};

  	return [
  		matches,
  		query,
  		mql,
  		mqlListener,
  		wasMounted,
  		addNewListener,
  		removeActiveListener,
  		$$scope,
  		$$slots
  	];
  }

  class MediaQuery extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$5, create_fragment$5, safe_not_equal, { query: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "MediaQuery",
  			options,
  			id: create_fragment$5.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*query*/ ctx[1] === undefined && !("query" in props)) {
  			console.warn("<MediaQuery> was created without expected prop 'query'");
  		}
  	}

  	get query() {
  		throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set query(value) {
  		throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-media-query/src/MediaQuery.svelte generated by Svelte v3.22.3 */
  const get_default_slot_changes$2 = dirty => ({ matches: dirty & /*matches*/ 1 });
  const get_default_slot_context$2 = ctx => ({ matches: /*matches*/ ctx[0] });

  function create_fragment$6(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[8].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$2);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope, matches*/ 129) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$2), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$6.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$6($$self, $$props, $$invalidate) {
  	let { query } = $$props;
  	let mql;
  	let mqlListener;
  	let wasMounted = false;
  	let matches = false;

  	onMount(() => {
  		$$invalidate(4, wasMounted = true);

  		return () => {
  			removeActiveListener();
  		};
  	});

  	function addNewListener(query) {
  		mql = window.matchMedia(query);
  		mqlListener = v => $$invalidate(0, matches = v.matches);
  		mql.addListener(mqlListener);
  		$$invalidate(0, matches = mql.matches);
  	}

  	function removeActiveListener() {
  		if (mql && mqlListener) {
  			mql.removeListener(mqlListener);
  		}
  	}

  	const writable_props = ["query"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MediaQuery> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("MediaQuery", $$slots, ['default']);

  	$$self.$set = $$props => {
  		if ("query" in $$props) $$invalidate(1, query = $$props.query);
  		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		query,
  		mql,
  		mqlListener,
  		wasMounted,
  		matches,
  		addNewListener,
  		removeActiveListener
  	});

  	$$self.$inject_state = $$props => {
  		if ("query" in $$props) $$invalidate(1, query = $$props.query);
  		if ("mql" in $$props) mql = $$props.mql;
  		if ("mqlListener" in $$props) mqlListener = $$props.mqlListener;
  		if ("wasMounted" in $$props) $$invalidate(4, wasMounted = $$props.wasMounted);
  		if ("matches" in $$props) $$invalidate(0, matches = $$props.matches);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*wasMounted, query*/ 18) {
  			 {
  				if (wasMounted) {
  					removeActiveListener();
  					addNewListener(query);
  				}
  			}
  		}
  	};

  	return [
  		matches,
  		query,
  		mql,
  		mqlListener,
  		wasMounted,
  		addNewListener,
  		removeActiveListener,
  		$$scope,
  		$$slots
  	];
  }

  class MediaQuery$1 extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$6, create_fragment$6, safe_not_equal, { query: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "MediaQuery",
  			options,
  			id: create_fragment$6.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*query*/ ctx[1] === undefined && !("query" in props)) {
  			console.warn("<MediaQuery> was created without expected prop 'query'");
  		}
  	}

  	get query() {
  		throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set query(value) {
  		throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  function fade(node, { delay = 0, duration = 400, easing = identity }) {
      const o = +getComputedStyle(node).opacity;
      return {
          delay,
          duration,
          easing,
          css: t => `opacity: ${t * o}`
      };
  }

  var moment = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
       module.exports = factory() ;
  }(commonjsGlobal, (function () {
      var hookCallback;

      function hooks() {
          return hookCallback.apply(null, arguments);
      }

      // This is done to register the method called with moment()
      // without creating circular dependencies.
      function setHookCallback(callback) {
          hookCallback = callback;
      }

      function isArray(input) {
          return (
              input instanceof Array ||
              Object.prototype.toString.call(input) === '[object Array]'
          );
      }

      function isObject(input) {
          // IE8 will treat undefined and null as object if it wasn't for
          // input != null
          return (
              input != null &&
              Object.prototype.toString.call(input) === '[object Object]'
          );
      }

      function hasOwnProp(a, b) {
          return Object.prototype.hasOwnProperty.call(a, b);
      }

      function isObjectEmpty(obj) {
          if (Object.getOwnPropertyNames) {
              return Object.getOwnPropertyNames(obj).length === 0;
          } else {
              var k;
              for (k in obj) {
                  if (hasOwnProp(obj, k)) {
                      return false;
                  }
              }
              return true;
          }
      }

      function isUndefined(input) {
          return input === void 0;
      }

      function isNumber(input) {
          return (
              typeof input === 'number' ||
              Object.prototype.toString.call(input) === '[object Number]'
          );
      }

      function isDate(input) {
          return (
              input instanceof Date ||
              Object.prototype.toString.call(input) === '[object Date]'
          );
      }

      function map(arr, fn) {
          var res = [],
              i;
          for (i = 0; i < arr.length; ++i) {
              res.push(fn(arr[i], i));
          }
          return res;
      }

      function extend(a, b) {
          for (var i in b) {
              if (hasOwnProp(b, i)) {
                  a[i] = b[i];
              }
          }

          if (hasOwnProp(b, 'toString')) {
              a.toString = b.toString;
          }

          if (hasOwnProp(b, 'valueOf')) {
              a.valueOf = b.valueOf;
          }

          return a;
      }

      function createUTC(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, true).utc();
      }

      function defaultParsingFlags() {
          // We need to deep clone this object.
          return {
              empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidEra: null,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false,
              parsedDateParts: [],
              era: null,
              meridiem: null,
              rfc2822: false,
              weekdayMismatch: false,
          };
      }

      function getParsingFlags(m) {
          if (m._pf == null) {
              m._pf = defaultParsingFlags();
          }
          return m._pf;
      }

      var some;
      if (Array.prototype.some) {
          some = Array.prototype.some;
      } else {
          some = function (fun) {
              var t = Object(this),
                  len = t.length >>> 0,
                  i;

              for (i = 0; i < len; i++) {
                  if (i in t && fun.call(this, t[i], i, t)) {
                      return true;
                  }
              }

              return false;
          };
      }

      function isValid(m) {
          if (m._isValid == null) {
              var flags = getParsingFlags(m),
                  parsedParts = some.call(flags.parsedDateParts, function (i) {
                      return i != null;
                  }),
                  isNowValid =
                      !isNaN(m._d.getTime()) &&
                      flags.overflow < 0 &&
                      !flags.empty &&
                      !flags.invalidEra &&
                      !flags.invalidMonth &&
                      !flags.invalidWeekday &&
                      !flags.weekdayMismatch &&
                      !flags.nullInput &&
                      !flags.invalidFormat &&
                      !flags.userInvalidated &&
                      (!flags.meridiem || (flags.meridiem && parsedParts));

              if (m._strict) {
                  isNowValid =
                      isNowValid &&
                      flags.charsLeftOver === 0 &&
                      flags.unusedTokens.length === 0 &&
                      flags.bigHour === undefined;
              }

              if (Object.isFrozen == null || !Object.isFrozen(m)) {
                  m._isValid = isNowValid;
              } else {
                  return isNowValid;
              }
          }
          return m._isValid;
      }

      function createInvalid(flags) {
          var m = createUTC(NaN);
          if (flags != null) {
              extend(getParsingFlags(m), flags);
          } else {
              getParsingFlags(m).userInvalidated = true;
          }

          return m;
      }

      // Plugins that add properties should also add the key here (null value),
      // so we can properly clone ourselves.
      var momentProperties = (hooks.momentProperties = []),
          updateInProgress = false;

      function copyConfig(to, from) {
          var i, prop, val;

          if (!isUndefined(from._isAMomentObject)) {
              to._isAMomentObject = from._isAMomentObject;
          }
          if (!isUndefined(from._i)) {
              to._i = from._i;
          }
          if (!isUndefined(from._f)) {
              to._f = from._f;
          }
          if (!isUndefined(from._l)) {
              to._l = from._l;
          }
          if (!isUndefined(from._strict)) {
              to._strict = from._strict;
          }
          if (!isUndefined(from._tzm)) {
              to._tzm = from._tzm;
          }
          if (!isUndefined(from._isUTC)) {
              to._isUTC = from._isUTC;
          }
          if (!isUndefined(from._offset)) {
              to._offset = from._offset;
          }
          if (!isUndefined(from._pf)) {
              to._pf = getParsingFlags(from);
          }
          if (!isUndefined(from._locale)) {
              to._locale = from._locale;
          }

          if (momentProperties.length > 0) {
              for (i = 0; i < momentProperties.length; i++) {
                  prop = momentProperties[i];
                  val = from[prop];
                  if (!isUndefined(val)) {
                      to[prop] = val;
                  }
              }
          }

          return to;
      }

      // Moment prototype object
      function Moment(config) {
          copyConfig(this, config);
          this._d = new Date(config._d != null ? config._d.getTime() : NaN);
          if (!this.isValid()) {
              this._d = new Date(NaN);
          }
          // Prevent infinite loop in case updateOffset creates new moment
          // objects.
          if (updateInProgress === false) {
              updateInProgress = true;
              hooks.updateOffset(this);
              updateInProgress = false;
          }
      }

      function isMoment(obj) {
          return (
              obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
          );
      }

      function warn(msg) {
          if (
              hooks.suppressDeprecationWarnings === false &&
              typeof console !== 'undefined' &&
              console.warn
          ) {
              console.warn('Deprecation warning: ' + msg);
          }
      }

      function deprecate(msg, fn) {
          var firstTime = true;

          return extend(function () {
              if (hooks.deprecationHandler != null) {
                  hooks.deprecationHandler(null, msg);
              }
              if (firstTime) {
                  var args = [],
                      arg,
                      i,
                      key;
                  for (i = 0; i < arguments.length; i++) {
                      arg = '';
                      if (typeof arguments[i] === 'object') {
                          arg += '\n[' + i + '] ';
                          for (key in arguments[0]) {
                              if (hasOwnProp(arguments[0], key)) {
                                  arg += key + ': ' + arguments[0][key] + ', ';
                              }
                          }
                          arg = arg.slice(0, -2); // Remove trailing comma and space
                      } else {
                          arg = arguments[i];
                      }
                      args.push(arg);
                  }
                  warn(
                      msg +
                          '\nArguments: ' +
                          Array.prototype.slice.call(args).join('') +
                          '\n' +
                          new Error().stack
                  );
                  firstTime = false;
              }
              return fn.apply(this, arguments);
          }, fn);
      }

      var deprecations = {};

      function deprecateSimple(name, msg) {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(name, msg);
          }
          if (!deprecations[name]) {
              warn(msg);
              deprecations[name] = true;
          }
      }

      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;

      function isFunction(input) {
          return (
              (typeof Function !== 'undefined' && input instanceof Function) ||
              Object.prototype.toString.call(input) === '[object Function]'
          );
      }

      function set(config) {
          var prop, i;
          for (i in config) {
              if (hasOwnProp(config, i)) {
                  prop = config[i];
                  if (isFunction(prop)) {
                      this[i] = prop;
                  } else {
                      this['_' + i] = prop;
                  }
              }
          }
          this._config = config;
          // Lenient ordinal parsing accepts just a number in addition to
          // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
          // TODO: Remove "ordinalParse" fallback in next major release.
          this._dayOfMonthOrdinalParseLenient = new RegExp(
              (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                  '|' +
                  /\d{1,2}/.source
          );
      }

      function mergeConfigs(parentConfig, childConfig) {
          var res = extend({}, parentConfig),
              prop;
          for (prop in childConfig) {
              if (hasOwnProp(childConfig, prop)) {
                  if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                      res[prop] = {};
                      extend(res[prop], parentConfig[prop]);
                      extend(res[prop], childConfig[prop]);
                  } else if (childConfig[prop] != null) {
                      res[prop] = childConfig[prop];
                  } else {
                      delete res[prop];
                  }
              }
          }
          for (prop in parentConfig) {
              if (
                  hasOwnProp(parentConfig, prop) &&
                  !hasOwnProp(childConfig, prop) &&
                  isObject(parentConfig[prop])
              ) {
                  // make sure changes to properties don't modify parent config
                  res[prop] = extend({}, res[prop]);
              }
          }
          return res;
      }

      function Locale(config) {
          if (config != null) {
              this.set(config);
          }
      }

      var keys;

      if (Object.keys) {
          keys = Object.keys;
      } else {
          keys = function (obj) {
              var i,
                  res = [];
              for (i in obj) {
                  if (hasOwnProp(obj, i)) {
                      res.push(i);
                  }
              }
              return res;
          };
      }

      var defaultCalendar = {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L',
      };

      function calendar(key, mom, now) {
          var output = this._calendar[key] || this._calendar['sameElse'];
          return isFunction(output) ? output.call(mom, now) : output;
      }

      function zeroFill(number, targetLength, forceSign) {
          var absNumber = '' + Math.abs(number),
              zerosToFill = targetLength - absNumber.length,
              sign = number >= 0;
          return (
              (sign ? (forceSign ? '+' : '') : '-') +
              Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
              absNumber
          );
      }

      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
          localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
          formatFunctions = {},
          formatTokenFunctions = {};

      // token:    'M'
      // padded:   ['MM', 2]
      // ordinal:  'Mo'
      // callback: function () { this.month() + 1 }
      function addFormatToken(token, padded, ordinal, callback) {
          var func = callback;
          if (typeof callback === 'string') {
              func = function () {
                  return this[callback]();
              };
          }
          if (token) {
              formatTokenFunctions[token] = func;
          }
          if (padded) {
              formatTokenFunctions[padded[0]] = function () {
                  return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
              };
          }
          if (ordinal) {
              formatTokenFunctions[ordinal] = function () {
                  return this.localeData().ordinal(
                      func.apply(this, arguments),
                      token
                  );
              };
          }
      }

      function removeFormattingTokens(input) {
          if (input.match(/\[[\s\S]/)) {
              return input.replace(/^\[|\]$/g, '');
          }
          return input.replace(/\\/g, '');
      }

      function makeFormatFunction(format) {
          var array = format.match(formattingTokens),
              i,
              length;

          for (i = 0, length = array.length; i < length; i++) {
              if (formatTokenFunctions[array[i]]) {
                  array[i] = formatTokenFunctions[array[i]];
              } else {
                  array[i] = removeFormattingTokens(array[i]);
              }
          }

          return function (mom) {
              var output = '',
                  i;
              for (i = 0; i < length; i++) {
                  output += isFunction(array[i])
                      ? array[i].call(mom, format)
                      : array[i];
              }
              return output;
          };
      }

      // format date using native date object
      function formatMoment(m, format) {
          if (!m.isValid()) {
              return m.localeData().invalidDate();
          }

          format = expandFormat(format, m.localeData());
          formatFunctions[format] =
              formatFunctions[format] || makeFormatFunction(format);

          return formatFunctions[format](m);
      }

      function expandFormat(format, locale) {
          var i = 5;

          function replaceLongDateFormatTokens(input) {
              return locale.longDateFormat(input) || input;
          }

          localFormattingTokens.lastIndex = 0;
          while (i >= 0 && localFormattingTokens.test(format)) {
              format = format.replace(
                  localFormattingTokens,
                  replaceLongDateFormatTokens
              );
              localFormattingTokens.lastIndex = 0;
              i -= 1;
          }

          return format;
      }

      var defaultLongDateFormat = {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A',
      };

      function longDateFormat(key) {
          var format = this._longDateFormat[key],
              formatUpper = this._longDateFormat[key.toUpperCase()];

          if (format || !formatUpper) {
              return format;
          }

          this._longDateFormat[key] = formatUpper
              .match(formattingTokens)
              .map(function (tok) {
                  if (
                      tok === 'MMMM' ||
                      tok === 'MM' ||
                      tok === 'DD' ||
                      tok === 'dddd'
                  ) {
                      return tok.slice(1);
                  }
                  return tok;
              })
              .join('');

          return this._longDateFormat[key];
      }

      var defaultInvalidDate = 'Invalid date';

      function invalidDate() {
          return this._invalidDate;
      }

      var defaultOrdinal = '%d',
          defaultDayOfMonthOrdinalParse = /\d{1,2}/;

      function ordinal(number) {
          return this._ordinal.replace('%d', number);
      }

      var defaultRelativeTime = {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          w: 'a week',
          ww: '%d weeks',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years',
      };

      function relativeTime(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return isFunction(output)
              ? output(number, withoutSuffix, string, isFuture)
              : output.replace(/%d/i, number);
      }

      function pastFuture(diff, output) {
          var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
          return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }

      var aliases = {};

      function addUnitAlias(unit, shorthand) {
          var lowerCase = unit.toLowerCase();
          aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }

      function normalizeUnits(units) {
          return typeof units === 'string'
              ? aliases[units] || aliases[units.toLowerCase()]
              : undefined;
      }

      function normalizeObjectUnits(inputObject) {
          var normalizedInput = {},
              normalizedProp,
              prop;

          for (prop in inputObject) {
              if (hasOwnProp(inputObject, prop)) {
                  normalizedProp = normalizeUnits(prop);
                  if (normalizedProp) {
                      normalizedInput[normalizedProp] = inputObject[prop];
                  }
              }
          }

          return normalizedInput;
      }

      var priorities = {};

      function addUnitPriority(unit, priority) {
          priorities[unit] = priority;
      }

      function getPrioritizedUnits(unitsObj) {
          var units = [],
              u;
          for (u in unitsObj) {
              if (hasOwnProp(unitsObj, u)) {
                  units.push({ unit: u, priority: priorities[u] });
              }
          }
          units.sort(function (a, b) {
              return a.priority - b.priority;
          });
          return units;
      }

      function isLeapYear(year) {
          return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }

      function absFloor(number) {
          if (number < 0) {
              // -0 -> 0
              return Math.ceil(number) || 0;
          } else {
              return Math.floor(number);
          }
      }

      function toInt(argumentForCoercion) {
          var coercedNumber = +argumentForCoercion,
              value = 0;

          if (coercedNumber !== 0 && isFinite(coercedNumber)) {
              value = absFloor(coercedNumber);
          }

          return value;
      }

      function makeGetSet(unit, keepTime) {
          return function (value) {
              if (value != null) {
                  set$1(this, unit, value);
                  hooks.updateOffset(this, keepTime);
                  return this;
              } else {
                  return get(this, unit);
              }
          };
      }

      function get(mom, unit) {
          return mom.isValid()
              ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
              : NaN;
      }

      function set$1(mom, unit, value) {
          if (mom.isValid() && !isNaN(value)) {
              if (
                  unit === 'FullYear' &&
                  isLeapYear(mom.year()) &&
                  mom.month() === 1 &&
                  mom.date() === 29
              ) {
                  value = toInt(value);
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                      value,
                      mom.month(),
                      daysInMonth(value, mom.month())
                  );
              } else {
                  mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
              }
          }
      }

      // MOMENTS

      function stringGet(units) {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units]();
          }
          return this;
      }

      function stringSet(units, value) {
          if (typeof units === 'object') {
              units = normalizeObjectUnits(units);
              var prioritized = getPrioritizedUnits(units),
                  i;
              for (i = 0; i < prioritized.length; i++) {
                  this[prioritized[i].unit](units[prioritized[i].unit]);
              }
          } else {
              units = normalizeUnits(units);
              if (isFunction(this[units])) {
                  return this[units](value);
              }
          }
          return this;
      }

      var match1 = /\d/, //       0 - 9
          match2 = /\d\d/, //      00 - 99
          match3 = /\d{3}/, //     000 - 999
          match4 = /\d{4}/, //    0000 - 9999
          match6 = /[+-]?\d{6}/, // -999999 - 999999
          match1to2 = /\d\d?/, //       0 - 99
          match3to4 = /\d\d\d\d?/, //     999 - 9999
          match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
          match1to3 = /\d{1,3}/, //       0 - 999
          match1to4 = /\d{1,4}/, //       0 - 9999
          match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
          matchUnsigned = /\d+/, //       0 - inf
          matchSigned = /[+-]?\d+/, //    -inf - inf
          matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
          matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
          matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
          // any word (or two) characters or numbers including two/three word month in arabic.
          // includes scottish gaelic two word and hyphenated months
          matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
          regexes;

      regexes = {};

      function addRegexToken(token, regex, strictRegex) {
          regexes[token] = isFunction(regex)
              ? regex
              : function (isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex;
                };
      }

      function getParseRegexForToken(token, config) {
          if (!hasOwnProp(regexes, token)) {
              return new RegExp(unescapeFormat(token));
          }

          return regexes[token](config._strict, config._locale);
      }

      // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
      function unescapeFormat(s) {
          return regexEscape(
              s
                  .replace('\\', '')
                  .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                      matched,
                      p1,
                      p2,
                      p3,
                      p4
                  ) {
                      return p1 || p2 || p3 || p4;
                  })
          );
      }

      function regexEscape(s) {
          return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }

      var tokens = {};

      function addParseToken(token, callback) {
          var i,
              func = callback;
          if (typeof token === 'string') {
              token = [token];
          }
          if (isNumber(callback)) {
              func = function (input, array) {
                  array[callback] = toInt(input);
              };
          }
          for (i = 0; i < token.length; i++) {
              tokens[token[i]] = func;
          }
      }

      function addWeekParseToken(token, callback) {
          addParseToken(token, function (input, array, config, token) {
              config._w = config._w || {};
              callback(input, config._w, config, token);
          });
      }

      function addTimeToArrayFromToken(token, input, config) {
          if (input != null && hasOwnProp(tokens, token)) {
              tokens[token](input, config._a, config, token);
          }
      }

      var YEAR = 0,
          MONTH = 1,
          DATE = 2,
          HOUR = 3,
          MINUTE = 4,
          SECOND = 5,
          MILLISECOND = 6,
          WEEK = 7,
          WEEKDAY = 8;

      function mod(n, x) {
          return ((n % x) + x) % x;
      }

      var indexOf;

      if (Array.prototype.indexOf) {
          indexOf = Array.prototype.indexOf;
      } else {
          indexOf = function (o) {
              // I know
              var i;
              for (i = 0; i < this.length; ++i) {
                  if (this[i] === o) {
                      return i;
                  }
              }
              return -1;
          };
      }

      function daysInMonth(year, month) {
          if (isNaN(year) || isNaN(month)) {
              return NaN;
          }
          var modMonth = mod(month, 12);
          year += (month - modMonth) / 12;
          return modMonth === 1
              ? isLeapYear(year)
                  ? 29
                  : 28
              : 31 - ((modMonth % 7) % 2);
      }

      // FORMATTING

      addFormatToken('M', ['MM', 2], 'Mo', function () {
          return this.month() + 1;
      });

      addFormatToken('MMM', 0, 0, function (format) {
          return this.localeData().monthsShort(this, format);
      });

      addFormatToken('MMMM', 0, 0, function (format) {
          return this.localeData().months(this, format);
      });

      // ALIASES

      addUnitAlias('month', 'M');

      // PRIORITY

      addUnitPriority('month', 8);

      // PARSING

      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function (isStrict, locale) {
          return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function (isStrict, locale) {
          return locale.monthsRegex(isStrict);
      });

      addParseToken(['M', 'MM'], function (input, array) {
          array[MONTH] = toInt(input) - 1;
      });

      addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
          var month = config._locale.monthsParse(input, token, config._strict);
          // if we didn't find a month name, mark the date as invalid.
          if (month != null) {
              array[MONTH] = month;
          } else {
              getParsingFlags(config).invalidMonth = input;
          }
      });

      // LOCALES

      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
          ),
          defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
              '_'
          ),
          MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
          defaultMonthsShortRegex = matchWord,
          defaultMonthsRegex = matchWord;

      function localeMonths(m, format) {
          if (!m) {
              return isArray(this._months)
                  ? this._months
                  : this._months['standalone'];
          }
          return isArray(this._months)
              ? this._months[m.month()]
              : this._months[
                    (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                        ? 'format'
                        : 'standalone'
                ][m.month()];
      }

      function localeMonthsShort(m, format) {
          if (!m) {
              return isArray(this._monthsShort)
                  ? this._monthsShort
                  : this._monthsShort['standalone'];
          }
          return isArray(this._monthsShort)
              ? this._monthsShort[m.month()]
              : this._monthsShort[
                    MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                ][m.month()];
      }

      function handleStrictParse(monthName, format, strict) {
          var i,
              ii,
              mom,
              llc = monthName.toLocaleLowerCase();
          if (!this._monthsParse) {
              // this is not used
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
              for (i = 0; i < 12; ++i) {
                  mom = createUTC([2000, i]);
                  this._shortMonthsParse[i] = this.monthsShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'MMM') {
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._longMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._longMonthsParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortMonthsParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeMonthsParse(monthName, format, strict) {
          var i, mom, regex;

          if (this._monthsParseExact) {
              return handleStrictParse.call(this, monthName, format, strict);
          }

          if (!this._monthsParse) {
              this._monthsParse = [];
              this._longMonthsParse = [];
              this._shortMonthsParse = [];
          }

          // TODO: add sorting
          // Sorting makes sure if one month (or abbr) is a prefix of another
          // see sorting in computeMonthsParse
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              if (strict && !this._longMonthsParse[i]) {
                  this._longMonthsParse[i] = new RegExp(
                      '^' + this.months(mom, '').replace('.', '') + '$',
                      'i'
                  );
                  this._shortMonthsParse[i] = new RegExp(
                      '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                      'i'
                  );
              }
              if (!strict && !this._monthsParse[i]) {
                  regex =
                      '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                  this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'MMMM' &&
                  this._longMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'MMM' &&
                  this._shortMonthsParse[i].test(monthName)
              ) {
                  return i;
              } else if (!strict && this._monthsParse[i].test(monthName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function setMonth(mom, value) {
          var dayOfMonth;

          if (!mom.isValid()) {
              // No op
              return mom;
          }

          if (typeof value === 'string') {
              if (/^\d+$/.test(value)) {
                  value = toInt(value);
              } else {
                  value = mom.localeData().monthsParse(value);
                  // TODO: Another silent failure?
                  if (!isNumber(value)) {
                      return mom;
                  }
              }
          }

          dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
          return mom;
      }

      function getSetMonth(value) {
          if (value != null) {
              setMonth(this, value);
              hooks.updateOffset(this, true);
              return this;
          } else {
              return get(this, 'Month');
          }
      }

      function getDaysInMonth() {
          return daysInMonth(this.year(), this.month());
      }

      function monthsShortRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsShortStrictRegex;
              } else {
                  return this._monthsShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsShortRegex')) {
                  this._monthsShortRegex = defaultMonthsShortRegex;
              }
              return this._monthsShortStrictRegex && isStrict
                  ? this._monthsShortStrictRegex
                  : this._monthsShortRegex;
          }
      }

      function monthsRegex(isStrict) {
          if (this._monthsParseExact) {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  computeMonthsParse.call(this);
              }
              if (isStrict) {
                  return this._monthsStrictRegex;
              } else {
                  return this._monthsRegex;
              }
          } else {
              if (!hasOwnProp(this, '_monthsRegex')) {
                  this._monthsRegex = defaultMonthsRegex;
              }
              return this._monthsStrictRegex && isStrict
                  ? this._monthsStrictRegex
                  : this._monthsRegex;
          }
      }

      function computeMonthsParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom;
          for (i = 0; i < 12; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, i]);
              shortPieces.push(this.monthsShort(mom, ''));
              longPieces.push(this.months(mom, ''));
              mixedPieces.push(this.months(mom, ''));
              mixedPieces.push(this.monthsShort(mom, ''));
          }
          // Sorting makes sure if one month (or abbr) is a prefix of another it
          // will match the longer piece.
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);
          for (i = 0; i < 12; i++) {
              shortPieces[i] = regexEscape(shortPieces[i]);
              longPieces[i] = regexEscape(longPieces[i]);
          }
          for (i = 0; i < 24; i++) {
              mixedPieces[i] = regexEscape(mixedPieces[i]);
          }

          this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._monthsShortRegex = this._monthsRegex;
          this._monthsStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._monthsShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken('Y', 0, 0, function () {
          var y = this.year();
          return y <= 9999 ? zeroFill(y, 4) : '+' + y;
      });

      addFormatToken(0, ['YY', 2], 0, function () {
          return this.year() % 100;
      });

      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

      // ALIASES

      addUnitAlias('year', 'y');

      // PRIORITIES

      addUnitPriority('year', 1);

      // PARSING

      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);

      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function (input, array) {
          array[YEAR] =
              input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function (input, array) {
          array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function (input, array) {
          array[YEAR] = parseInt(input, 10);
      });

      // HELPERS

      function daysInYear(year) {
          return isLeapYear(year) ? 366 : 365;
      }

      // HOOKS

      hooks.parseTwoDigitYear = function (input) {
          return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };

      // MOMENTS

      var getSetYear = makeGetSet('FullYear', true);

      function getIsLeapYear() {
          return isLeapYear(this.year());
      }

      function createDate(y, m, d, h, M, s, ms) {
          // can't just apply() to create a date:
          // https://stackoverflow.com/q/181348
          var date;
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              date = new Date(y + 400, m, d, h, M, s, ms);
              if (isFinite(date.getFullYear())) {
                  date.setFullYear(y);
              }
          } else {
              date = new Date(y, m, d, h, M, s, ms);
          }

          return date;
      }

      function createUTCDate(y) {
          var date, args;
          // the Date.UTC function remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              args = Array.prototype.slice.call(arguments);
              // preserve leap years using a full 400 year cycle, then reset
              args[0] = y + 400;
              date = new Date(Date.UTC.apply(null, args));
              if (isFinite(date.getUTCFullYear())) {
                  date.setUTCFullYear(y);
              }
          } else {
              date = new Date(Date.UTC.apply(null, arguments));
          }

          return date;
      }

      // start-of-first-week - start-of-year
      function firstWeekOffset(year, dow, doy) {
          var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
              fwd = 7 + dow - doy,
              // first-week day local weekday -- which local weekday is fwd
              fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

          return -fwdlw + fwd - 1;
      }

      // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
          var localWeekday = (7 + weekday - dow) % 7,
              weekOffset = firstWeekOffset(year, dow, doy),
              dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
              resYear,
              resDayOfYear;

          if (dayOfYear <= 0) {
              resYear = year - 1;
              resDayOfYear = daysInYear(resYear) + dayOfYear;
          } else if (dayOfYear > daysInYear(year)) {
              resYear = year + 1;
              resDayOfYear = dayOfYear - daysInYear(year);
          } else {
              resYear = year;
              resDayOfYear = dayOfYear;
          }

          return {
              year: resYear,
              dayOfYear: resDayOfYear,
          };
      }

      function weekOfYear(mom, dow, doy) {
          var weekOffset = firstWeekOffset(mom.year(), dow, doy),
              week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
              resWeek,
              resYear;

          if (week < 1) {
              resYear = mom.year() - 1;
              resWeek = week + weeksInYear(resYear, dow, doy);
          } else if (week > weeksInYear(mom.year(), dow, doy)) {
              resWeek = week - weeksInYear(mom.year(), dow, doy);
              resYear = mom.year() + 1;
          } else {
              resYear = mom.year();
              resWeek = week;
          }

          return {
              week: resWeek,
              year: resYear,
          };
      }

      function weeksInYear(year, dow, doy) {
          var weekOffset = firstWeekOffset(year, dow, doy),
              weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
          return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }

      // FORMATTING

      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

      // ALIASES

      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');

      // PRIORITIES

      addUnitPriority('week', 5);
      addUnitPriority('isoWeek', 5);

      // PARSING

      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);

      addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
          input,
          week,
          config,
          token
      ) {
          week[token.substr(0, 1)] = toInt(input);
      });

      // HELPERS

      // LOCALES

      function localeWeek(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }

      var defaultLocaleWeek = {
          dow: 0, // Sunday is the first day of the week.
          doy: 6, // The week that contains Jan 6th is the first week of the year.
      };

      function localeFirstDayOfWeek() {
          return this._week.dow;
      }

      function localeFirstDayOfYear() {
          return this._week.doy;
      }

      // MOMENTS

      function getSetWeek(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      function getSetISOWeek(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, 'd');
      }

      // FORMATTING

      addFormatToken('d', 0, 'do', 'day');

      addFormatToken('dd', 0, 0, function (format) {
          return this.localeData().weekdaysMin(this, format);
      });

      addFormatToken('ddd', 0, 0, function (format) {
          return this.localeData().weekdaysShort(this, format);
      });

      addFormatToken('dddd', 0, 0, function (format) {
          return this.localeData().weekdays(this, format);
      });

      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');

      // ALIASES

      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');

      // PRIORITY
      addUnitPriority('day', 11);
      addUnitPriority('weekday', 11);
      addUnitPriority('isoWeekday', 11);

      // PARSING

      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function (isStrict, locale) {
          return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function (isStrict, locale) {
          return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function (isStrict, locale) {
          return locale.weekdaysRegex(isStrict);
      });

      addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
          var weekday = config._locale.weekdaysParse(input, token, config._strict);
          // if we didn't get a weekday name, mark the date as invalid
          if (weekday != null) {
              week.d = weekday;
          } else {
              getParsingFlags(config).invalidWeekday = input;
          }
      });

      addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
          week[token] = toInt(input);
      });

      // HELPERS

      function parseWeekday(input, locale) {
          if (typeof input !== 'string') {
              return input;
          }

          if (!isNaN(input)) {
              return parseInt(input, 10);
          }

          input = locale.weekdaysParse(input);
          if (typeof input === 'number') {
              return input;
          }

          return null;
      }

      function parseIsoWeekday(input, locale) {
          if (typeof input === 'string') {
              return locale.weekdaysParse(input) % 7 || 7;
          }
          return isNaN(input) ? null : input;
      }

      // LOCALES
      function shiftWeekdays(ws, n) {
          return ws.slice(n, 7).concat(ws.slice(0, n));
      }

      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
          ),
          defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
          defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
          defaultWeekdaysRegex = matchWord,
          defaultWeekdaysShortRegex = matchWord,
          defaultWeekdaysMinRegex = matchWord;

      function localeWeekdays(m, format) {
          var weekdays = isArray(this._weekdays)
              ? this._weekdays
              : this._weekdays[
                    m && m !== true && this._weekdays.isFormat.test(format)
                        ? 'format'
                        : 'standalone'
                ];
          return m === true
              ? shiftWeekdays(weekdays, this._week.dow)
              : m
              ? weekdays[m.day()]
              : weekdays;
      }

      function localeWeekdaysShort(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysShort, this._week.dow)
              : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
      }

      function localeWeekdaysMin(m) {
          return m === true
              ? shiftWeekdays(this._weekdaysMin, this._week.dow)
              : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
      }

      function handleStrictParse$1(weekdayName, format, strict) {
          var i,
              ii,
              mom,
              llc = weekdayName.toLocaleLowerCase();
          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._minWeekdaysParse = [];

              for (i = 0; i < 7; ++i) {
                  mom = createUTC([2000, 1]).day(i);
                  this._minWeekdaysParse[i] = this.weekdaysMin(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._shortWeekdaysParse[i] = this.weekdaysShort(
                      mom,
                      ''
                  ).toLocaleLowerCase();
                  this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
              }
          }

          if (strict) {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          } else {
              if (format === 'dddd') {
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else if (format === 'ddd') {
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              } else {
                  ii = indexOf.call(this._minWeekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._weekdaysParse, llc);
                  if (ii !== -1) {
                      return ii;
                  }
                  ii = indexOf.call(this._shortWeekdaysParse, llc);
                  return ii !== -1 ? ii : null;
              }
          }
      }

      function localeWeekdaysParse(weekdayName, format, strict) {
          var i, mom, regex;

          if (this._weekdaysParseExact) {
              return handleStrictParse$1.call(this, weekdayName, format, strict);
          }

          if (!this._weekdaysParse) {
              this._weekdaysParse = [];
              this._minWeekdaysParse = [];
              this._shortWeekdaysParse = [];
              this._fullWeekdaysParse = [];
          }

          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already

              mom = createUTC([2000, 1]).day(i);
              if (strict && !this._fullWeekdaysParse[i]) {
                  this._fullWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._shortWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
                  this._minWeekdaysParse[i] = new RegExp(
                      '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                      'i'
                  );
              }
              if (!this._weekdaysParse[i]) {
                  regex =
                      '^' +
                      this.weekdays(mom, '') +
                      '|^' +
                      this.weekdaysShort(mom, '') +
                      '|^' +
                      this.weekdaysMin(mom, '');
                  this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
              }
              // test the regex
              if (
                  strict &&
                  format === 'dddd' &&
                  this._fullWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'ddd' &&
                  this._shortWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (
                  strict &&
                  format === 'dd' &&
                  this._minWeekdaysParse[i].test(weekdayName)
              ) {
                  return i;
              } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                  return i;
              }
          }
      }

      // MOMENTS

      function getSetDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
              input = parseWeekday(input, this.localeData());
              return this.add(input - day, 'd');
          } else {
              return day;
          }
      }

      function getSetLocaleDayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, 'd');
      }

      function getSetISODayOfWeek(input) {
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }

          // behaves the same as moment#day except
          // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
          // as a setter, sunday should belong to the previous week.

          if (input != null) {
              var weekday = parseIsoWeekday(input, this.localeData());
              return this.day(this.day() % 7 ? weekday : weekday - 7);
          } else {
              return this.day() || 7;
          }
      }

      function weekdaysRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysStrictRegex;
              } else {
                  return this._weekdaysRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  this._weekdaysRegex = defaultWeekdaysRegex;
              }
              return this._weekdaysStrictRegex && isStrict
                  ? this._weekdaysStrictRegex
                  : this._weekdaysRegex;
          }
      }

      function weekdaysShortRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysShortStrictRegex;
              } else {
                  return this._weekdaysShortRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                  this._weekdaysShortRegex = defaultWeekdaysShortRegex;
              }
              return this._weekdaysShortStrictRegex && isStrict
                  ? this._weekdaysShortStrictRegex
                  : this._weekdaysShortRegex;
          }
      }

      function weekdaysMinRegex(isStrict) {
          if (this._weekdaysParseExact) {
              if (!hasOwnProp(this, '_weekdaysRegex')) {
                  computeWeekdaysParse.call(this);
              }
              if (isStrict) {
                  return this._weekdaysMinStrictRegex;
              } else {
                  return this._weekdaysMinRegex;
              }
          } else {
              if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                  this._weekdaysMinRegex = defaultWeekdaysMinRegex;
              }
              return this._weekdaysMinStrictRegex && isStrict
                  ? this._weekdaysMinStrictRegex
                  : this._weekdaysMinRegex;
          }
      }

      function computeWeekdaysParse() {
          function cmpLenRev(a, b) {
              return b.length - a.length;
          }

          var minPieces = [],
              shortPieces = [],
              longPieces = [],
              mixedPieces = [],
              i,
              mom,
              minp,
              shortp,
              longp;
          for (i = 0; i < 7; i++) {
              // make the regex if we don't have it already
              mom = createUTC([2000, 1]).day(i);
              minp = regexEscape(this.weekdaysMin(mom, ''));
              shortp = regexEscape(this.weekdaysShort(mom, ''));
              longp = regexEscape(this.weekdays(mom, ''));
              minPieces.push(minp);
              shortPieces.push(shortp);
              longPieces.push(longp);
              mixedPieces.push(minp);
              mixedPieces.push(shortp);
              mixedPieces.push(longp);
          }
          // Sorting makes sure if one weekday (or abbr) is a prefix of another it
          // will match the longer piece.
          minPieces.sort(cmpLenRev);
          shortPieces.sort(cmpLenRev);
          longPieces.sort(cmpLenRev);
          mixedPieces.sort(cmpLenRev);

          this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._weekdaysShortRegex = this._weekdaysRegex;
          this._weekdaysMinRegex = this._weekdaysRegex;

          this._weekdaysStrictRegex = new RegExp(
              '^(' + longPieces.join('|') + ')',
              'i'
          );
          this._weekdaysShortStrictRegex = new RegExp(
              '^(' + shortPieces.join('|') + ')',
              'i'
          );
          this._weekdaysMinStrictRegex = new RegExp(
              '^(' + minPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      function hFormat() {
          return this.hours() % 12 || 12;
      }

      function kFormat() {
          return this.hours() || 24;
      }

      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);

      addFormatToken('hmm', 0, 0, function () {
          return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });

      addFormatToken('hmmss', 0, 0, function () {
          return (
              '' +
              hFormat.apply(this) +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      addFormatToken('Hmm', 0, 0, function () {
          return '' + this.hours() + zeroFill(this.minutes(), 2);
      });

      addFormatToken('Hmmss', 0, 0, function () {
          return (
              '' +
              this.hours() +
              zeroFill(this.minutes(), 2) +
              zeroFill(this.seconds(), 2)
          );
      });

      function meridiem(token, lowercase) {
          addFormatToken(token, 0, 0, function () {
              return this.localeData().meridiem(
                  this.hours(),
                  this.minutes(),
                  lowercase
              );
          });
      }

      meridiem('a', true);
      meridiem('A', false);

      // ALIASES

      addUnitAlias('hour', 'h');

      // PRIORITY
      addUnitPriority('hour', 13);

      // PARSING

      function matchMeridiem(isStrict, locale) {
          return locale._meridiemParse;
      }

      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('k', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('kk', match1to2, match2);

      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);

      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['k', 'kk'], function (input, array, config) {
          var kInput = toInt(input);
          array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(['a', 'A'], function (input, array, config) {
          config._isPm = config._locale.isPM(input);
          config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function (input, array, config) {
          array[HOUR] = toInt(input);
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
          getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function (input, array, config) {
          var pos = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos));
          array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function (input, array, config) {
          var pos1 = input.length - 4,
              pos2 = input.length - 2;
          array[HOUR] = toInt(input.substr(0, pos1));
          array[MINUTE] = toInt(input.substr(pos1, 2));
          array[SECOND] = toInt(input.substr(pos2));
      });

      // LOCALES

      function localeIsPM(input) {
          // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
          // Using charAt should be more compatible.
          return (input + '').toLowerCase().charAt(0) === 'p';
      }

      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
          // Setting the hour should keep the time, because the user explicitly
          // specified which hour they want. So trying to maintain the same hour (in
          // a new timezone) makes sense. Adding/subtracting hours does not follow
          // this rule.
          getSetHour = makeGetSet('Hours', true);

      function localeMeridiem(hours, minutes, isLower) {
          if (hours > 11) {
              return isLower ? 'pm' : 'PM';
          } else {
              return isLower ? 'am' : 'AM';
          }
      }

      var baseConfig = {
          calendar: defaultCalendar,
          longDateFormat: defaultLongDateFormat,
          invalidDate: defaultInvalidDate,
          ordinal: defaultOrdinal,
          dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
          relativeTime: defaultRelativeTime,

          months: defaultLocaleMonths,
          monthsShort: defaultLocaleMonthsShort,

          week: defaultLocaleWeek,

          weekdays: defaultLocaleWeekdays,
          weekdaysMin: defaultLocaleWeekdaysMin,
          weekdaysShort: defaultLocaleWeekdaysShort,

          meridiemParse: defaultLocaleMeridiemParse,
      };

      // internal storage for locale config files
      var locales = {},
          localeFamilies = {},
          globalLocale;

      function commonPrefix(arr1, arr2) {
          var i,
              minl = Math.min(arr1.length, arr2.length);
          for (i = 0; i < minl; i += 1) {
              if (arr1[i] !== arr2[i]) {
                  return i;
              }
          }
          return minl;
      }

      function normalizeLocale(key) {
          return key ? key.toLowerCase().replace('_', '-') : key;
      }

      // pick the locale from the array
      // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
      // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
      function chooseLocale(names) {
          var i = 0,
              j,
              next,
              locale,
              split;

          while (i < names.length) {
              split = normalizeLocale(names[i]).split('-');
              j = split.length;
              next = normalizeLocale(names[i + 1]);
              next = next ? next.split('-') : null;
              while (j > 0) {
                  locale = loadLocale(split.slice(0, j).join('-'));
                  if (locale) {
                      return locale;
                  }
                  if (
                      next &&
                      next.length >= j &&
                      commonPrefix(split, next) >= j - 1
                  ) {
                      //the next array item is better than a shallower substring of this one
                      break;
                  }
                  j--;
              }
              i++;
          }
          return globalLocale;
      }

      function loadLocale(name) {
          var oldLocale = null,
              aliasedRequire;
          // TODO: Find a better way to register and load all the locales in Node
          if (
              locales[name] === undefined &&
              'object' !== 'undefined' &&
              module &&
              module.exports
          ) {
              try {
                  oldLocale = globalLocale._abbr;
                  aliasedRequire = commonjsRequire;
                  aliasedRequire('./locale/' + name);
                  getSetGlobalLocale(oldLocale);
              } catch (e) {
                  // mark as not found to avoid repeating expensive file require call causing high CPU
                  // when trying to find en-US, en_US, en-us for every format call
                  locales[name] = null; // null means not found
              }
          }
          return locales[name];
      }

      // This function will load locale and then set the global locale.  If
      // no arguments are passed in, it will simply return the current global
      // locale key.
      function getSetGlobalLocale(key, values) {
          var data;
          if (key) {
              if (isUndefined(values)) {
                  data = getLocale(key);
              } else {
                  data = defineLocale(key, values);
              }

              if (data) {
                  // moment.duration._locale = moment._locale = data;
                  globalLocale = data;
              } else {
                  if (typeof console !== 'undefined' && console.warn) {
                      //warn user if arguments are passed but the locale could not be set
                      console.warn(
                          'Locale ' + key + ' not found. Did you forget to load it?'
                      );
                  }
              }
          }

          return globalLocale._abbr;
      }

      function defineLocale(name, config) {
          if (config !== null) {
              var locale,
                  parentConfig = baseConfig;
              config.abbr = name;
              if (locales[name] != null) {
                  deprecateSimple(
                      'defineLocaleOverride',
                      'use moment.updateLocale(localeName, config) to change ' +
                          'an existing locale. moment.defineLocale(localeName, ' +
                          'config) should only be used for creating a new locale ' +
                          'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                  );
                  parentConfig = locales[name]._config;
              } else if (config.parentLocale != null) {
                  if (locales[config.parentLocale] != null) {
                      parentConfig = locales[config.parentLocale]._config;
                  } else {
                      locale = loadLocale(config.parentLocale);
                      if (locale != null) {
                          parentConfig = locale._config;
                      } else {
                          if (!localeFamilies[config.parentLocale]) {
                              localeFamilies[config.parentLocale] = [];
                          }
                          localeFamilies[config.parentLocale].push({
                              name: name,
                              config: config,
                          });
                          return null;
                      }
                  }
              }
              locales[name] = new Locale(mergeConfigs(parentConfig, config));

              if (localeFamilies[name]) {
                  localeFamilies[name].forEach(function (x) {
                      defineLocale(x.name, x.config);
                  });
              }

              // backwards compat for now: also set the locale
              // make sure we set the locale AFTER all child locales have been
              // created, so we won't end up with the child locale set.
              getSetGlobalLocale(name);

              return locales[name];
          } else {
              // useful for testing
              delete locales[name];
              return null;
          }
      }

      function updateLocale(name, config) {
          if (config != null) {
              var locale,
                  tmpLocale,
                  parentConfig = baseConfig;

              if (locales[name] != null && locales[name].parentLocale != null) {
                  // Update existing child locale in-place to avoid memory-leaks
                  locales[name].set(mergeConfigs(locales[name]._config, config));
              } else {
                  // MERGE
                  tmpLocale = loadLocale(name);
                  if (tmpLocale != null) {
                      parentConfig = tmpLocale._config;
                  }
                  config = mergeConfigs(parentConfig, config);
                  if (tmpLocale == null) {
                      // updateLocale is called for creating a new locale
                      // Set abbr so it will have a name (getters return
                      // undefined otherwise).
                      config.abbr = name;
                  }
                  locale = new Locale(config);
                  locale.parentLocale = locales[name];
                  locales[name] = locale;
              }

              // backwards compat for now: also set the locale
              getSetGlobalLocale(name);
          } else {
              // pass null for config to unupdate, useful for tests
              if (locales[name] != null) {
                  if (locales[name].parentLocale != null) {
                      locales[name] = locales[name].parentLocale;
                      if (name === getSetGlobalLocale()) {
                          getSetGlobalLocale(name);
                      }
                  } else if (locales[name] != null) {
                      delete locales[name];
                  }
              }
          }
          return locales[name];
      }

      // returns locale data
      function getLocale(key) {
          var locale;

          if (key && key._locale && key._locale._abbr) {
              key = key._locale._abbr;
          }

          if (!key) {
              return globalLocale;
          }

          if (!isArray(key)) {
              //short-circuit everything else
              locale = loadLocale(key);
              if (locale) {
                  return locale;
              }
              key = [key];
          }

          return chooseLocale(key);
      }

      function listLocales() {
          return keys(locales);
      }

      function checkOverflow(m) {
          var overflow,
              a = m._a;

          if (a && getParsingFlags(m).overflow === -2) {
              overflow =
                  a[MONTH] < 0 || a[MONTH] > 11
                      ? MONTH
                      : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                      ? DATE
                      : a[HOUR] < 0 ||
                        a[HOUR] > 24 ||
                        (a[HOUR] === 24 &&
                            (a[MINUTE] !== 0 ||
                                a[SECOND] !== 0 ||
                                a[MILLISECOND] !== 0))
                      ? HOUR
                      : a[MINUTE] < 0 || a[MINUTE] > 59
                      ? MINUTE
                      : a[SECOND] < 0 || a[SECOND] > 59
                      ? SECOND
                      : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                      ? MILLISECOND
                      : -1;

              if (
                  getParsingFlags(m)._overflowDayOfYear &&
                  (overflow < YEAR || overflow > DATE)
              ) {
                  overflow = DATE;
              }
              if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                  overflow = WEEK;
              }
              if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                  overflow = WEEKDAY;
              }

              getParsingFlags(m).overflow = overflow;
          }

          return m;
      }

      // iso 8601 regex
      // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
          tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
          isoDates = [
              ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
              ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
              ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
              ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
              ['YYYY-DDD', /\d{4}-\d{3}/],
              ['YYYY-MM', /\d{4}-\d\d/, false],
              ['YYYYYYMMDD', /[+-]\d{10}/],
              ['YYYYMMDD', /\d{8}/],
              ['GGGG[W]WWE', /\d{4}W\d{3}/],
              ['GGGG[W]WW', /\d{4}W\d{2}/, false],
              ['YYYYDDD', /\d{7}/],
              ['YYYYMM', /\d{6}/, false],
              ['YYYY', /\d{4}/, false],
          ],
          // iso time formats and regexes
          isoTimes = [
              ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
              ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
              ['HH:mm:ss', /\d\d:\d\d:\d\d/],
              ['HH:mm', /\d\d:\d\d/],
              ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
              ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
              ['HHmmss', /\d\d\d\d\d\d/],
              ['HHmm', /\d\d\d\d/],
              ['HH', /\d\d/],
          ],
          aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
          // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
          rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
          obsOffsets = {
              UT: 0,
              GMT: 0,
              EDT: -4 * 60,
              EST: -5 * 60,
              CDT: -5 * 60,
              CST: -6 * 60,
              MDT: -6 * 60,
              MST: -7 * 60,
              PDT: -7 * 60,
              PST: -8 * 60,
          };

      // date from iso format
      function configFromISO(config) {
          var i,
              l,
              string = config._i,
              match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
              allowTime,
              dateFormat,
              timeFormat,
              tzFormat;

          if (match) {
              getParsingFlags(config).iso = true;

              for (i = 0, l = isoDates.length; i < l; i++) {
                  if (isoDates[i][1].exec(match[1])) {
                      dateFormat = isoDates[i][0];
                      allowTime = isoDates[i][2] !== false;
                      break;
                  }
              }
              if (dateFormat == null) {
                  config._isValid = false;
                  return;
              }
              if (match[3]) {
                  for (i = 0, l = isoTimes.length; i < l; i++) {
                      if (isoTimes[i][1].exec(match[3])) {
                          // match[2] should be 'T' or space
                          timeFormat = (match[2] || ' ') + isoTimes[i][0];
                          break;
                      }
                  }
                  if (timeFormat == null) {
                      config._isValid = false;
                      return;
                  }
              }
              if (!allowTime && timeFormat != null) {
                  config._isValid = false;
                  return;
              }
              if (match[4]) {
                  if (tzRegex.exec(match[4])) {
                      tzFormat = 'Z';
                  } else {
                      config._isValid = false;
                      return;
                  }
              }
              config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
              configFromStringAndFormat(config);
          } else {
              config._isValid = false;
          }
      }

      function extractFromRFC2822Strings(
          yearStr,
          monthStr,
          dayStr,
          hourStr,
          minuteStr,
          secondStr
      ) {
          var result = [
              untruncateYear(yearStr),
              defaultLocaleMonthsShort.indexOf(monthStr),
              parseInt(dayStr, 10),
              parseInt(hourStr, 10),
              parseInt(minuteStr, 10),
          ];

          if (secondStr) {
              result.push(parseInt(secondStr, 10));
          }

          return result;
      }

      function untruncateYear(yearStr) {
          var year = parseInt(yearStr, 10);
          if (year <= 49) {
              return 2000 + year;
          } else if (year <= 999) {
              return 1900 + year;
          }
          return year;
      }

      function preprocessRFC2822(s) {
          // Remove comments and folding whitespace and replace multiple-spaces with a single space
          return s
              .replace(/\([^)]*\)|[\n\t]/g, ' ')
              .replace(/(\s\s+)/g, ' ')
              .replace(/^\s\s*/, '')
              .replace(/\s\s*$/, '');
      }

      function checkWeekday(weekdayStr, parsedInput, config) {
          if (weekdayStr) {
              // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
              var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                  weekdayActual = new Date(
                      parsedInput[0],
                      parsedInput[1],
                      parsedInput[2]
                  ).getDay();
              if (weekdayProvided !== weekdayActual) {
                  getParsingFlags(config).weekdayMismatch = true;
                  config._isValid = false;
                  return false;
              }
          }
          return true;
      }

      function calculateOffset(obsOffset, militaryOffset, numOffset) {
          if (obsOffset) {
              return obsOffsets[obsOffset];
          } else if (militaryOffset) {
              // the only allowed military tz is Z
              return 0;
          } else {
              var hm = parseInt(numOffset, 10),
                  m = hm % 100,
                  h = (hm - m) / 100;
              return h * 60 + m;
          }
      }

      // date and time from ref 2822 format
      function configFromRFC2822(config) {
          var match = rfc2822.exec(preprocessRFC2822(config._i)),
              parsedArray;
          if (match) {
              parsedArray = extractFromRFC2822Strings(
                  match[4],
                  match[3],
                  match[2],
                  match[5],
                  match[6],
                  match[7]
              );
              if (!checkWeekday(match[1], parsedArray, config)) {
                  return;
              }

              config._a = parsedArray;
              config._tzm = calculateOffset(match[8], match[9], match[10]);

              config._d = createUTCDate.apply(null, config._a);
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

              getParsingFlags(config).rfc2822 = true;
          } else {
              config._isValid = false;
          }
      }

      // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
      function configFromString(config) {
          var matched = aspNetJsonRegex.exec(config._i);
          if (matched !== null) {
              config._d = new Date(+matched[1]);
              return;
          }

          configFromISO(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          configFromRFC2822(config);
          if (config._isValid === false) {
              delete config._isValid;
          } else {
              return;
          }

          if (config._strict) {
              config._isValid = false;
          } else {
              // Final attempt, use Input Fallback
              hooks.createFromInputFallback(config);
          }
      }

      hooks.createFromInputFallback = deprecate(
          'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
              'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
              'discouraged and will be removed in an upcoming major release. Please refer to ' +
              'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
          function (config) {
              config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
          }
      );

      // Pick the first defined of two or three arguments.
      function defaults(a, b, c) {
          if (a != null) {
              return a;
          }
          if (b != null) {
              return b;
          }
          return c;
      }

      function currentDateArray(config) {
          // hooks is actually the exported moment object
          var nowValue = new Date(hooks.now());
          if (config._useUTC) {
              return [
                  nowValue.getUTCFullYear(),
                  nowValue.getUTCMonth(),
                  nowValue.getUTCDate(),
              ];
          }
          return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }

      // convert an array to a date.
      // the array should mirror the parameters below
      // note: all values past the year are optional and will default to the lowest possible value.
      // [year, month, day , hour, minute, second, millisecond]
      function configFromArray(config) {
          var i,
              date,
              input = [],
              currentDate,
              expectedWeekday,
              yearToUse;

          if (config._d) {
              return;
          }

          currentDate = currentDateArray(config);

          //compute day of the year from weeks and weekdays
          if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
              dayOfYearFromWeekInfo(config);
          }

          //if the day of the year is set, figure out what it is
          if (config._dayOfYear != null) {
              yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

              if (
                  config._dayOfYear > daysInYear(yearToUse) ||
                  config._dayOfYear === 0
              ) {
                  getParsingFlags(config)._overflowDayOfYear = true;
              }

              date = createUTCDate(yearToUse, 0, config._dayOfYear);
              config._a[MONTH] = date.getUTCMonth();
              config._a[DATE] = date.getUTCDate();
          }

          // Default to current date.
          // * if no year, month, day of month are given, default to today
          // * if day of month is given, default month and year
          // * if month is given, default only year
          // * if year is given, don't default anything
          for (i = 0; i < 3 && config._a[i] == null; ++i) {
              config._a[i] = input[i] = currentDate[i];
          }

          // Zero out whatever was not defaulted, including time
          for (; i < 7; i++) {
              config._a[i] = input[i] =
                  config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
          }

          // Check for 24:00:00.000
          if (
              config._a[HOUR] === 24 &&
              config._a[MINUTE] === 0 &&
              config._a[SECOND] === 0 &&
              config._a[MILLISECOND] === 0
          ) {
              config._nextDay = true;
              config._a[HOUR] = 0;
          }

          config._d = (config._useUTC ? createUTCDate : createDate).apply(
              null,
              input
          );
          expectedWeekday = config._useUTC
              ? config._d.getUTCDay()
              : config._d.getDay();

          // Apply timezone offset from input. The actual utcOffset can be changed
          // with parseZone.
          if (config._tzm != null) {
              config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          }

          if (config._nextDay) {
              config._a[HOUR] = 24;
          }

          // check for mismatching day of week
          if (
              config._w &&
              typeof config._w.d !== 'undefined' &&
              config._w.d !== expectedWeekday
          ) {
              getParsingFlags(config).weekdayMismatch = true;
          }
      }

      function dayOfYearFromWeekInfo(config) {
          var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

          w = config._w;
          if (w.GG != null || w.W != null || w.E != null) {
              dow = 1;
              doy = 4;

              // TODO: We need to take the current isoWeekYear, but that depends on
              // how we interpret now (local, utc, fixed offset). So create
              // a now version of current config (take local/utc/offset flags, and
              // create now).
              weekYear = defaults(
                  w.GG,
                  config._a[YEAR],
                  weekOfYear(createLocal(), 1, 4).year
              );
              week = defaults(w.W, 1);
              weekday = defaults(w.E, 1);
              if (weekday < 1 || weekday > 7) {
                  weekdayOverflow = true;
              }
          } else {
              dow = config._locale._week.dow;
              doy = config._locale._week.doy;

              curWeek = weekOfYear(createLocal(), dow, doy);

              weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

              // Default to current week.
              week = defaults(w.w, curWeek.week);

              if (w.d != null) {
                  // weekday -- low day numbers are considered next week
                  weekday = w.d;
                  if (weekday < 0 || weekday > 6) {
                      weekdayOverflow = true;
                  }
              } else if (w.e != null) {
                  // local weekday -- counting starts from beginning of week
                  weekday = w.e + dow;
                  if (w.e < 0 || w.e > 6) {
                      weekdayOverflow = true;
                  }
              } else {
                  // default to beginning of week
                  weekday = dow;
              }
          }
          if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
              getParsingFlags(config)._overflowWeeks = true;
          } else if (weekdayOverflow != null) {
              getParsingFlags(config)._overflowWeekday = true;
          } else {
              temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
              config._a[YEAR] = temp.year;
              config._dayOfYear = temp.dayOfYear;
          }
      }

      // constant that refers to the ISO standard
      hooks.ISO_8601 = function () {};

      // constant that refers to the RFC 2822 form
      hooks.RFC_2822 = function () {};

      // date from string and format string
      function configFromStringAndFormat(config) {
          // TODO: Move this to another part of the creation flow to prevent circular deps
          if (config._f === hooks.ISO_8601) {
              configFromISO(config);
              return;
          }
          if (config._f === hooks.RFC_2822) {
              configFromRFC2822(config);
              return;
          }
          config._a = [];
          getParsingFlags(config).empty = true;

          // This array is used to make a Date, either with `new Date` or `Date.UTC`
          var string = '' + config._i,
              i,
              parsedInput,
              tokens,
              token,
              skipped,
              stringLength = string.length,
              totalParsedInputLength = 0,
              era;

          tokens =
              expandFormat(config._f, config._locale).match(formattingTokens) || [];

          for (i = 0; i < tokens.length; i++) {
              token = tokens[i];
              parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                  [])[0];
              if (parsedInput) {
                  skipped = string.substr(0, string.indexOf(parsedInput));
                  if (skipped.length > 0) {
                      getParsingFlags(config).unusedInput.push(skipped);
                  }
                  string = string.slice(
                      string.indexOf(parsedInput) + parsedInput.length
                  );
                  totalParsedInputLength += parsedInput.length;
              }
              // don't parse if it's not a known token
              if (formatTokenFunctions[token]) {
                  if (parsedInput) {
                      getParsingFlags(config).empty = false;
                  } else {
                      getParsingFlags(config).unusedTokens.push(token);
                  }
                  addTimeToArrayFromToken(token, parsedInput, config);
              } else if (config._strict && !parsedInput) {
                  getParsingFlags(config).unusedTokens.push(token);
              }
          }

          // add remaining unparsed input length to the string
          getParsingFlags(config).charsLeftOver =
              stringLength - totalParsedInputLength;
          if (string.length > 0) {
              getParsingFlags(config).unusedInput.push(string);
          }

          // clear _12h flag if hour is <= 12
          if (
              config._a[HOUR] <= 12 &&
              getParsingFlags(config).bigHour === true &&
              config._a[HOUR] > 0
          ) {
              getParsingFlags(config).bigHour = undefined;
          }

          getParsingFlags(config).parsedDateParts = config._a.slice(0);
          getParsingFlags(config).meridiem = config._meridiem;
          // handle meridiem
          config._a[HOUR] = meridiemFixWrap(
              config._locale,
              config._a[HOUR],
              config._meridiem
          );

          // handle era
          era = getParsingFlags(config).era;
          if (era !== null) {
              config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
          }

          configFromArray(config);
          checkOverflow(config);
      }

      function meridiemFixWrap(locale, hour, meridiem) {
          var isPm;

          if (meridiem == null) {
              // nothing to do
              return hour;
          }
          if (locale.meridiemHour != null) {
              return locale.meridiemHour(hour, meridiem);
          } else if (locale.isPM != null) {
              // Fallback
              isPm = locale.isPM(meridiem);
              if (isPm && hour < 12) {
                  hour += 12;
              }
              if (!isPm && hour === 12) {
                  hour = 0;
              }
              return hour;
          } else {
              // this is not supposed to happen
              return hour;
          }
      }

      // date from string and array of format strings
      function configFromStringAndArray(config) {
          var tempConfig,
              bestMoment,
              scoreToBeat,
              i,
              currentScore,
              validFormatFound,
              bestFormatIsValid = false;

          if (config._f.length === 0) {
              getParsingFlags(config).invalidFormat = true;
              config._d = new Date(NaN);
              return;
          }

          for (i = 0; i < config._f.length; i++) {
              currentScore = 0;
              validFormatFound = false;
              tempConfig = copyConfig({}, config);
              if (config._useUTC != null) {
                  tempConfig._useUTC = config._useUTC;
              }
              tempConfig._f = config._f[i];
              configFromStringAndFormat(tempConfig);

              if (isValid(tempConfig)) {
                  validFormatFound = true;
              }

              // if there is any input that was not parsed add a penalty for that format
              currentScore += getParsingFlags(tempConfig).charsLeftOver;

              //or tokens
              currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

              getParsingFlags(tempConfig).score = currentScore;

              if (!bestFormatIsValid) {
                  if (
                      scoreToBeat == null ||
                      currentScore < scoreToBeat ||
                      validFormatFound
                  ) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                      if (validFormatFound) {
                          bestFormatIsValid = true;
                      }
                  }
              } else {
                  if (currentScore < scoreToBeat) {
                      scoreToBeat = currentScore;
                      bestMoment = tempConfig;
                  }
              }
          }

          extend(config, bestMoment || tempConfig);
      }

      function configFromObject(config) {
          if (config._d) {
              return;
          }

          var i = normalizeObjectUnits(config._i),
              dayOrDate = i.day === undefined ? i.date : i.day;
          config._a = map(
              [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
              function (obj) {
                  return obj && parseInt(obj, 10);
              }
          );

          configFromArray(config);
      }

      function createFromConfig(config) {
          var res = new Moment(checkOverflow(prepareConfig(config)));
          if (res._nextDay) {
              // Adding is smart enough around DST
              res.add(1, 'd');
              res._nextDay = undefined;
          }

          return res;
      }

      function prepareConfig(config) {
          var input = config._i,
              format = config._f;

          config._locale = config._locale || getLocale(config._l);

          if (input === null || (format === undefined && input === '')) {
              return createInvalid({ nullInput: true });
          }

          if (typeof input === 'string') {
              config._i = input = config._locale.preparse(input);
          }

          if (isMoment(input)) {
              return new Moment(checkOverflow(input));
          } else if (isDate(input)) {
              config._d = input;
          } else if (isArray(format)) {
              configFromStringAndArray(config);
          } else if (format) {
              configFromStringAndFormat(config);
          } else {
              configFromInput(config);
          }

          if (!isValid(config)) {
              config._d = null;
          }

          return config;
      }

      function configFromInput(config) {
          var input = config._i;
          if (isUndefined(input)) {
              config._d = new Date(hooks.now());
          } else if (isDate(input)) {
              config._d = new Date(input.valueOf());
          } else if (typeof input === 'string') {
              configFromString(config);
          } else if (isArray(input)) {
              config._a = map(input.slice(0), function (obj) {
                  return parseInt(obj, 10);
              });
              configFromArray(config);
          } else if (isObject(input)) {
              configFromObject(config);
          } else if (isNumber(input)) {
              // from milliseconds
              config._d = new Date(input);
          } else {
              hooks.createFromInputFallback(config);
          }
      }

      function createLocalOrUTC(input, format, locale, strict, isUTC) {
          var c = {};

          if (format === true || format === false) {
              strict = format;
              format = undefined;
          }

          if (locale === true || locale === false) {
              strict = locale;
              locale = undefined;
          }

          if (
              (isObject(input) && isObjectEmpty(input)) ||
              (isArray(input) && input.length === 0)
          ) {
              input = undefined;
          }
          // object construction must be done this way.
          // https://github.com/moment/moment/issues/1423
          c._isAMomentObject = true;
          c._useUTC = c._isUTC = isUTC;
          c._l = locale;
          c._i = input;
          c._f = format;
          c._strict = strict;

          return createFromConfig(c);
      }

      function createLocal(input, format, locale, strict) {
          return createLocalOrUTC(input, format, locale, strict, false);
      }

      var prototypeMin = deprecate(
              'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other < this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          ),
          prototypeMax = deprecate(
              'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
              function () {
                  var other = createLocal.apply(null, arguments);
                  if (this.isValid() && other.isValid()) {
                      return other > this ? this : other;
                  } else {
                      return createInvalid();
                  }
              }
          );

      // Pick a moment m from moments so that m[fn](other) is true for all
      // other. This relies on the function fn to be transitive.
      //
      // moments should either be an array of moment objects or an array, whose
      // first element is an array of moment objects.
      function pickBy(fn, moments) {
          var res, i;
          if (moments.length === 1 && isArray(moments[0])) {
              moments = moments[0];
          }
          if (!moments.length) {
              return createLocal();
          }
          res = moments[0];
          for (i = 1; i < moments.length; ++i) {
              if (!moments[i].isValid() || moments[i][fn](res)) {
                  res = moments[i];
              }
          }
          return res;
      }

      // TODO: Use [].sort instead?
      function min() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isBefore', args);
      }

      function max() {
          var args = [].slice.call(arguments, 0);

          return pickBy('isAfter', args);
      }

      var now = function () {
          return Date.now ? Date.now() : +new Date();
      };

      var ordering = [
          'year',
          'quarter',
          'month',
          'week',
          'day',
          'hour',
          'minute',
          'second',
          'millisecond',
      ];

      function isDurationValid(m) {
          var key,
              unitHasDecimal = false,
              i;
          for (key in m) {
              if (
                  hasOwnProp(m, key) &&
                  !(
                      indexOf.call(ordering, key) !== -1 &&
                      (m[key] == null || !isNaN(m[key]))
                  )
              ) {
                  return false;
              }
          }

          for (i = 0; i < ordering.length; ++i) {
              if (m[ordering[i]]) {
                  if (unitHasDecimal) {
                      return false; // only allow non-integers for smallest unit
                  }
                  if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                      unitHasDecimal = true;
                  }
              }
          }

          return true;
      }

      function isValid$1() {
          return this._isValid;
      }

      function createInvalid$1() {
          return createDuration(NaN);
      }

      function Duration(duration) {
          var normalizedInput = normalizeObjectUnits(duration),
              years = normalizedInput.year || 0,
              quarters = normalizedInput.quarter || 0,
              months = normalizedInput.month || 0,
              weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
              days = normalizedInput.day || 0,
              hours = normalizedInput.hour || 0,
              minutes = normalizedInput.minute || 0,
              seconds = normalizedInput.second || 0,
              milliseconds = normalizedInput.millisecond || 0;

          this._isValid = isDurationValid(normalizedInput);

          // representation for dateAddRemove
          this._milliseconds =
              +milliseconds +
              seconds * 1e3 + // 1000
              minutes * 6e4 + // 1000 * 60
              hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
          // Because of dateAddRemove treats 24 hours as different from a
          // day when working around DST, we need to store them separately
          this._days = +days + weeks * 7;
          // It is impossible to translate months into days without knowing
          // which months you are are talking about, so we have to store
          // it separately.
          this._months = +months + quarters * 3 + years * 12;

          this._data = {};

          this._locale = getLocale();

          this._bubble();
      }

      function isDuration(obj) {
          return obj instanceof Duration;
      }

      function absRound(number) {
          if (number < 0) {
              return Math.round(-1 * number) * -1;
          } else {
              return Math.round(number);
          }
      }

      // compare two arrays, return the number of differences
      function compareArrays(array1, array2, dontConvert) {
          var len = Math.min(array1.length, array2.length),
              lengthDiff = Math.abs(array1.length - array2.length),
              diffs = 0,
              i;
          for (i = 0; i < len; i++) {
              if (
                  (dontConvert && array1[i] !== array2[i]) ||
                  (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
              ) {
                  diffs++;
              }
          }
          return diffs + lengthDiff;
      }

      // FORMATTING

      function offset(token, separator) {
          addFormatToken(token, 0, 0, function () {
              var offset = this.utcOffset(),
                  sign = '+';
              if (offset < 0) {
                  offset = -offset;
                  sign = '-';
              }
              return (
                  sign +
                  zeroFill(~~(offset / 60), 2) +
                  separator +
                  zeroFill(~~offset % 60, 2)
              );
          });
      }

      offset('Z', ':');
      offset('ZZ', '');

      // PARSING

      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function (input, array, config) {
          config._useUTC = true;
          config._tzm = offsetFromString(matchShortOffset, input);
      });

      // HELPERS

      // timezone chunker
      // '+10:00' > ['10',  '00']
      // '-1530'  > ['-15', '30']
      var chunkOffset = /([\+\-]|\d\d)/gi;

      function offsetFromString(matcher, string) {
          var matches = (string || '').match(matcher),
              chunk,
              parts,
              minutes;

          if (matches === null) {
              return null;
          }

          chunk = matches[matches.length - 1] || [];
          parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
          minutes = +(parts[1] * 60) + toInt(parts[2]);

          return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
      }

      // Return a moment from input, that is local/utc/zone equivalent to model.
      function cloneWithOffset(input, model) {
          var res, diff;
          if (model._isUTC) {
              res = model.clone();
              diff =
                  (isMoment(input) || isDate(input)
                      ? input.valueOf()
                      : createLocal(input).valueOf()) - res.valueOf();
              // Use low-level api, because this fn is low-level api.
              res._d.setTime(res._d.valueOf() + diff);
              hooks.updateOffset(res, false);
              return res;
          } else {
              return createLocal(input).local();
          }
      }

      function getDateOffset(m) {
          // On Firefox.24 Date#getTimezoneOffset returns a floating point.
          // https://github.com/moment/moment/pull/1871
          return -Math.round(m._d.getTimezoneOffset());
      }

      // HOOKS

      // This function will be called whenever a moment is mutated.
      // It is intended to keep the offset in sync with the timezone.
      hooks.updateOffset = function () {};

      // MOMENTS

      // keepLocalTime = true means only change the timezone, without
      // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
      // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
      // +0200, so we adjust the time as needed, to be valid.
      //
      // Keeping the time actually adds/subtracts (one hour)
      // from the actual represented time. That is why we call updateOffset
      // a second time. In case it wants us to change the offset again
      // _changeInProgress == true case, then we have to adjust, because
      // there is no such time in the given timezone.
      function getSetOffset(input, keepLocalTime, keepMinutes) {
          var offset = this._offset || 0,
              localAdjust;
          if (!this.isValid()) {
              return input != null ? this : NaN;
          }
          if (input != null) {
              if (typeof input === 'string') {
                  input = offsetFromString(matchShortOffset, input);
                  if (input === null) {
                      return this;
                  }
              } else if (Math.abs(input) < 16 && !keepMinutes) {
                  input = input * 60;
              }
              if (!this._isUTC && keepLocalTime) {
                  localAdjust = getDateOffset(this);
              }
              this._offset = input;
              this._isUTC = true;
              if (localAdjust != null) {
                  this.add(localAdjust, 'm');
              }
              if (offset !== input) {
                  if (!keepLocalTime || this._changeInProgress) {
                      addSubtract(
                          this,
                          createDuration(input - offset, 'm'),
                          1,
                          false
                      );
                  } else if (!this._changeInProgress) {
                      this._changeInProgress = true;
                      hooks.updateOffset(this, true);
                      this._changeInProgress = null;
                  }
              }
              return this;
          } else {
              return this._isUTC ? offset : getDateOffset(this);
          }
      }

      function getSetZone(input, keepLocalTime) {
          if (input != null) {
              if (typeof input !== 'string') {
                  input = -input;
              }

              this.utcOffset(input, keepLocalTime);

              return this;
          } else {
              return -this.utcOffset();
          }
      }

      function setOffsetToUTC(keepLocalTime) {
          return this.utcOffset(0, keepLocalTime);
      }

      function setOffsetToLocal(keepLocalTime) {
          if (this._isUTC) {
              this.utcOffset(0, keepLocalTime);
              this._isUTC = false;

              if (keepLocalTime) {
                  this.subtract(getDateOffset(this), 'm');
              }
          }
          return this;
      }

      function setOffsetToParsedOffset() {
          if (this._tzm != null) {
              this.utcOffset(this._tzm, false, true);
          } else if (typeof this._i === 'string') {
              var tZone = offsetFromString(matchOffset, this._i);
              if (tZone != null) {
                  this.utcOffset(tZone);
              } else {
                  this.utcOffset(0, true);
              }
          }
          return this;
      }

      function hasAlignedHourOffset(input) {
          if (!this.isValid()) {
              return false;
          }
          input = input ? createLocal(input).utcOffset() : 0;

          return (this.utcOffset() - input) % 60 === 0;
      }

      function isDaylightSavingTime() {
          return (
              this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
          );
      }

      function isDaylightSavingTimeShifted() {
          if (!isUndefined(this._isDSTShifted)) {
              return this._isDSTShifted;
          }

          var c = {},
              other;

          copyConfig(c, this);
          c = prepareConfig(c);

          if (c._a) {
              other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
              this._isDSTShifted =
                  this.isValid() && compareArrays(c._a, other.toArray()) > 0;
          } else {
              this._isDSTShifted = false;
          }

          return this._isDSTShifted;
      }

      function isLocal() {
          return this.isValid() ? !this._isUTC : false;
      }

      function isUtcOffset() {
          return this.isValid() ? this._isUTC : false;
      }

      function isUtc() {
          return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }

      // ASP.NET json date format regex
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
          // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
          // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
          // and further modified to allow for strings containing both week and day
          isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

      function createDuration(input, key) {
          var duration = input,
              // matching against regexp is expensive, do it on demand
              match = null,
              sign,
              ret,
              diffRes;

          if (isDuration(input)) {
              duration = {
                  ms: input._milliseconds,
                  d: input._days,
                  M: input._months,
              };
          } else if (isNumber(input) || !isNaN(+input)) {
              duration = {};
              if (key) {
                  duration[key] = +input;
              } else {
                  duration.milliseconds = +input;
              }
          } else if ((match = aspNetRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: 0,
                  d: toInt(match[DATE]) * sign,
                  h: toInt(match[HOUR]) * sign,
                  m: toInt(match[MINUTE]) * sign,
                  s: toInt(match[SECOND]) * sign,
                  ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
              };
          } else if ((match = isoRegex.exec(input))) {
              sign = match[1] === '-' ? -1 : 1;
              duration = {
                  y: parseIso(match[2], sign),
                  M: parseIso(match[3], sign),
                  w: parseIso(match[4], sign),
                  d: parseIso(match[5], sign),
                  h: parseIso(match[6], sign),
                  m: parseIso(match[7], sign),
                  s: parseIso(match[8], sign),
              };
          } else if (duration == null) {
              // checks for null or undefined
              duration = {};
          } else if (
              typeof duration === 'object' &&
              ('from' in duration || 'to' in duration)
          ) {
              diffRes = momentsDifference(
                  createLocal(duration.from),
                  createLocal(duration.to)
              );

              duration = {};
              duration.ms = diffRes.milliseconds;
              duration.M = diffRes.months;
          }

          ret = new Duration(duration);

          if (isDuration(input) && hasOwnProp(input, '_locale')) {
              ret._locale = input._locale;
          }

          if (isDuration(input) && hasOwnProp(input, '_isValid')) {
              ret._isValid = input._isValid;
          }

          return ret;
      }

      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;

      function parseIso(inp, sign) {
          // We'd normally use ~~inp for this, but unfortunately it also
          // converts floats to ints.
          // inp may be undefined, so careful calling replace on it.
          var res = inp && parseFloat(inp.replace(',', '.'));
          // apply sign while we're at it
          return (isNaN(res) ? 0 : res) * sign;
      }

      function positiveMomentsDifference(base, other) {
          var res = {};

          res.months =
              other.month() - base.month() + (other.year() - base.year()) * 12;
          if (base.clone().add(res.months, 'M').isAfter(other)) {
              --res.months;
          }

          res.milliseconds = +other - +base.clone().add(res.months, 'M');

          return res;
      }

      function momentsDifference(base, other) {
          var res;
          if (!(base.isValid() && other.isValid())) {
              return { milliseconds: 0, months: 0 };
          }

          other = cloneWithOffset(other, base);
          if (base.isBefore(other)) {
              res = positiveMomentsDifference(base, other);
          } else {
              res = positiveMomentsDifference(other, base);
              res.milliseconds = -res.milliseconds;
              res.months = -res.months;
          }

          return res;
      }

      // TODO: remove 'name' arg after deprecation is removed
      function createAdder(direction, name) {
          return function (val, period) {
              var dur, tmp;
              //invert the arguments, but complain about it
              if (period !== null && !isNaN(+period)) {
                  deprecateSimple(
                      name,
                      'moment().' +
                          name +
                          '(period, number) is deprecated. Please use moment().' +
                          name +
                          '(number, period). ' +
                          'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                  );
                  tmp = val;
                  val = period;
                  period = tmp;
              }

              dur = createDuration(val, period);
              addSubtract(this, dur, direction);
              return this;
          };
      }

      function addSubtract(mom, duration, isAdding, updateOffset) {
          var milliseconds = duration._milliseconds,
              days = absRound(duration._days),
              months = absRound(duration._months);

          if (!mom.isValid()) {
              // No op
              return;
          }

          updateOffset = updateOffset == null ? true : updateOffset;

          if (months) {
              setMonth(mom, get(mom, 'Month') + months * isAdding);
          }
          if (days) {
              set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
          }
          if (milliseconds) {
              mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
          }
          if (updateOffset) {
              hooks.updateOffset(mom, days || months);
          }
      }

      var add = createAdder(1, 'add'),
          subtract = createAdder(-1, 'subtract');

      function isString(input) {
          return typeof input === 'string' || input instanceof String;
      }

      // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
      function isMomentInput(input) {
          return (
              isMoment(input) ||
              isDate(input) ||
              isString(input) ||
              isNumber(input) ||
              isNumberOrStringArray(input) ||
              isMomentInputObject(input) ||
              input === null ||
              input === undefined
          );
      }

      function isMomentInputObject(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'years',
                  'year',
                  'y',
                  'months',
                  'month',
                  'M',
                  'days',
                  'day',
                  'd',
                  'dates',
                  'date',
                  'D',
                  'hours',
                  'hour',
                  'h',
                  'minutes',
                  'minute',
                  'm',
                  'seconds',
                  'second',
                  's',
                  'milliseconds',
                  'millisecond',
                  'ms',
              ],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function isNumberOrStringArray(input) {
          var arrayTest = isArray(input),
              dataTypeTest = false;
          if (arrayTest) {
              dataTypeTest =
                  input.filter(function (item) {
                      return !isNumber(item) && isString(input);
                  }).length === 0;
          }
          return arrayTest && dataTypeTest;
      }

      function isCalendarSpec(input) {
          var objectTest = isObject(input) && !isObjectEmpty(input),
              propertyTest = false,
              properties = [
                  'sameDay',
                  'nextDay',
                  'lastDay',
                  'nextWeek',
                  'lastWeek',
                  'sameElse',
              ],
              i,
              property;

          for (i = 0; i < properties.length; i += 1) {
              property = properties[i];
              propertyTest = propertyTest || hasOwnProp(input, property);
          }

          return objectTest && propertyTest;
      }

      function getCalendarFormat(myMoment, now) {
          var diff = myMoment.diff(now, 'days', true);
          return diff < -6
              ? 'sameElse'
              : diff < -1
              ? 'lastWeek'
              : diff < 0
              ? 'lastDay'
              : diff < 1
              ? 'sameDay'
              : diff < 2
              ? 'nextDay'
              : diff < 7
              ? 'nextWeek'
              : 'sameElse';
      }

      function calendar$1(time, formats) {
          // Support for single parameter, formats only overload to the calendar function
          if (arguments.length === 1) {
              if (isMomentInput(arguments[0])) {
                  time = arguments[0];
                  formats = undefined;
              } else if (isCalendarSpec(arguments[0])) {
                  formats = arguments[0];
                  time = undefined;
              }
          }
          // We want to compare the start of today, vs this.
          // Getting start-of-today depends on whether we're local/utc/offset or not.
          var now = time || createLocal(),
              sod = cloneWithOffset(now, this).startOf('day'),
              format = hooks.calendarFormat(this, sod) || 'sameElse',
              output =
                  formats &&
                  (isFunction(formats[format])
                      ? formats[format].call(this, now)
                      : formats[format]);

          return this.format(
              output || this.localeData().calendar(format, this, createLocal(now))
          );
      }

      function clone() {
          return new Moment(this);
      }

      function isAfter(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() > localInput.valueOf();
          } else {
              return localInput.valueOf() < this.clone().startOf(units).valueOf();
          }
      }

      function isBefore(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input);
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() < localInput.valueOf();
          } else {
              return this.clone().endOf(units).valueOf() < localInput.valueOf();
          }
      }

      function isBetween(from, to, units, inclusivity) {
          var localFrom = isMoment(from) ? from : createLocal(from),
              localTo = isMoment(to) ? to : createLocal(to);
          if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
              return false;
          }
          inclusivity = inclusivity || '()';
          return (
              (inclusivity[0] === '('
                  ? this.isAfter(localFrom, units)
                  : !this.isBefore(localFrom, units)) &&
              (inclusivity[1] === ')'
                  ? this.isBefore(localTo, units)
                  : !this.isAfter(localTo, units))
          );
      }

      function isSame(input, units) {
          var localInput = isMoment(input) ? input : createLocal(input),
              inputMs;
          if (!(this.isValid() && localInput.isValid())) {
              return false;
          }
          units = normalizeUnits(units) || 'millisecond';
          if (units === 'millisecond') {
              return this.valueOf() === localInput.valueOf();
          } else {
              inputMs = localInput.valueOf();
              return (
                  this.clone().startOf(units).valueOf() <= inputMs &&
                  inputMs <= this.clone().endOf(units).valueOf()
              );
          }
      }

      function isSameOrAfter(input, units) {
          return this.isSame(input, units) || this.isAfter(input, units);
      }

      function isSameOrBefore(input, units) {
          return this.isSame(input, units) || this.isBefore(input, units);
      }

      function diff(input, units, asFloat) {
          var that, zoneDelta, output;

          if (!this.isValid()) {
              return NaN;
          }

          that = cloneWithOffset(input, this);

          if (!that.isValid()) {
              return NaN;
          }

          zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

          units = normalizeUnits(units);

          switch (units) {
              case 'year':
                  output = monthDiff(this, that) / 12;
                  break;
              case 'month':
                  output = monthDiff(this, that);
                  break;
              case 'quarter':
                  output = monthDiff(this, that) / 3;
                  break;
              case 'second':
                  output = (this - that) / 1e3;
                  break; // 1000
              case 'minute':
                  output = (this - that) / 6e4;
                  break; // 1000 * 60
              case 'hour':
                  output = (this - that) / 36e5;
                  break; // 1000 * 60 * 60
              case 'day':
                  output = (this - that - zoneDelta) / 864e5;
                  break; // 1000 * 60 * 60 * 24, negate dst
              case 'week':
                  output = (this - that - zoneDelta) / 6048e5;
                  break; // 1000 * 60 * 60 * 24 * 7, negate dst
              default:
                  output = this - that;
          }

          return asFloat ? output : absFloor(output);
      }

      function monthDiff(a, b) {
          if (a.date() < b.date()) {
              // end-of-month calculations work correct when the start month has more
              // days than the end month.
              return -monthDiff(b, a);
          }
          // difference in months
          var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
              // b is in (anchor - 1 month, anchor + 1 month)
              anchor = a.clone().add(wholeMonthDiff, 'months'),
              anchor2,
              adjust;

          if (b - anchor < 0) {
              anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor - anchor2);
          } else {
              anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
              // linear across the month
              adjust = (b - anchor) / (anchor2 - anchor);
          }

          //check for negative zero, return zero if negative zero
          return -(wholeMonthDiff + adjust) || 0;
      }

      hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

      function toString() {
          return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }

      function toISOString(keepOffset) {
          if (!this.isValid()) {
              return null;
          }
          var utc = keepOffset !== true,
              m = utc ? this.clone().utc() : this;
          if (m.year() < 0 || m.year() > 9999) {
              return formatMoment(
                  m,
                  utc
                      ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                      : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
              );
          }
          if (isFunction(Date.prototype.toISOString)) {
              // native implementation is ~50x faster, use it when we can
              if (utc) {
                  return this.toDate().toISOString();
              } else {
                  return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                      .toISOString()
                      .replace('Z', formatMoment(m, 'Z'));
              }
          }
          return formatMoment(
              m,
              utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
          );
      }

      /**
       * Return a human readable representation of a moment that can
       * also be evaluated to get a new moment which is the same
       *
       * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
       */
      function inspect() {
          if (!this.isValid()) {
              return 'moment.invalid(/* ' + this._i + ' */)';
          }
          var func = 'moment',
              zone = '',
              prefix,
              year,
              datetime,
              suffix;
          if (!this.isLocal()) {
              func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
              zone = 'Z';
          }
          prefix = '[' + func + '("]';
          year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
          datetime = '-MM-DD[T]HH:mm:ss.SSS';
          suffix = zone + '[")]';

          return this.format(prefix + year + datetime + suffix);
      }

      function format(inputString) {
          if (!inputString) {
              inputString = this.isUtc()
                  ? hooks.defaultFormatUtc
                  : hooks.defaultFormat;
          }
          var output = formatMoment(this, inputString);
          return this.localeData().postformat(output);
      }

      function from(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ to: this, from: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function fromNow(withoutSuffix) {
          return this.from(createLocal(), withoutSuffix);
      }

      function to(time, withoutSuffix) {
          if (
              this.isValid() &&
              ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
          ) {
              return createDuration({ from: this, to: time })
                  .locale(this.locale())
                  .humanize(!withoutSuffix);
          } else {
              return this.localeData().invalidDate();
          }
      }

      function toNow(withoutSuffix) {
          return this.to(createLocal(), withoutSuffix);
      }

      // If passed a locale key, it will set the locale for this
      // instance.  Otherwise, it will return the locale configuration
      // variables for this instance.
      function locale(key) {
          var newLocaleData;

          if (key === undefined) {
              return this._locale._abbr;
          } else {
              newLocaleData = getLocale(key);
              if (newLocaleData != null) {
                  this._locale = newLocaleData;
              }
              return this;
          }
      }

      var lang = deprecate(
          'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
          function (key) {
              if (key === undefined) {
                  return this.localeData();
              } else {
                  return this.locale(key);
              }
          }
      );

      function localeData() {
          return this._locale;
      }

      var MS_PER_SECOND = 1000,
          MS_PER_MINUTE = 60 * MS_PER_SECOND,
          MS_PER_HOUR = 60 * MS_PER_MINUTE,
          MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

      // actual modulo - handles negative numbers (for dates before 1970):
      function mod$1(dividend, divisor) {
          return ((dividend % divisor) + divisor) % divisor;
      }

      function localStartOfDate(y, m, d) {
          // the date constructor remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return new Date(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return new Date(y, m, d).valueOf();
          }
      }

      function utcStartOfDate(y, m, d) {
          // Date.UTC remaps years 0-99 to 1900-1999
          if (y < 100 && y >= 0) {
              // preserve leap years using a full 400 year cycle, then reset
              return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
          } else {
              return Date.UTC(y, m, d);
          }
      }

      function startOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year(), 0, 1);
                  break;
              case 'quarter':
                  time = startOfDate(
                      this.year(),
                      this.month() - (this.month() % 3),
                      1
                  );
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month(), 1);
                  break;
              case 'week':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - this.weekday()
                  );
                  break;
              case 'isoWeek':
                  time = startOfDate(
                      this.year(),
                      this.month(),
                      this.date() - (this.isoWeekday() - 1)
                  );
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date());
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time -= mod$1(
                      time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                      MS_PER_HOUR
                  );
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_MINUTE);
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time -= mod$1(time, MS_PER_SECOND);
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function endOf(units) {
          var time, startOfDate;
          units = normalizeUnits(units);
          if (units === undefined || units === 'millisecond' || !this.isValid()) {
              return this;
          }

          startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

          switch (units) {
              case 'year':
                  time = startOfDate(this.year() + 1, 0, 1) - 1;
                  break;
              case 'quarter':
                  time =
                      startOfDate(
                          this.year(),
                          this.month() - (this.month() % 3) + 3,
                          1
                      ) - 1;
                  break;
              case 'month':
                  time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                  break;
              case 'week':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - this.weekday() + 7
                      ) - 1;
                  break;
              case 'isoWeek':
                  time =
                      startOfDate(
                          this.year(),
                          this.month(),
                          this.date() - (this.isoWeekday() - 1) + 7
                      ) - 1;
                  break;
              case 'day':
              case 'date':
                  time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                  break;
              case 'hour':
                  time = this._d.valueOf();
                  time +=
                      MS_PER_HOUR -
                      mod$1(
                          time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                          MS_PER_HOUR
                      ) -
                      1;
                  break;
              case 'minute':
                  time = this._d.valueOf();
                  time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                  break;
              case 'second':
                  time = this._d.valueOf();
                  time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                  break;
          }

          this._d.setTime(time);
          hooks.updateOffset(this, true);
          return this;
      }

      function valueOf() {
          return this._d.valueOf() - (this._offset || 0) * 60000;
      }

      function unix() {
          return Math.floor(this.valueOf() / 1000);
      }

      function toDate() {
          return new Date(this.valueOf());
      }

      function toArray() {
          var m = this;
          return [
              m.year(),
              m.month(),
              m.date(),
              m.hour(),
              m.minute(),
              m.second(),
              m.millisecond(),
          ];
      }

      function toObject() {
          var m = this;
          return {
              years: m.year(),
              months: m.month(),
              date: m.date(),
              hours: m.hours(),
              minutes: m.minutes(),
              seconds: m.seconds(),
              milliseconds: m.milliseconds(),
          };
      }

      function toJSON() {
          // new Date(NaN).toJSON() === null
          return this.isValid() ? this.toISOString() : null;
      }

      function isValid$2() {
          return isValid(this);
      }

      function parsingFlags() {
          return extend({}, getParsingFlags(this));
      }

      function invalidAt() {
          return getParsingFlags(this).overflow;
      }

      function creationData() {
          return {
              input: this._i,
              format: this._f,
              locale: this._locale,
              isUTC: this._isUTC,
              strict: this._strict,
          };
      }

      addFormatToken('N', 0, 0, 'eraAbbr');
      addFormatToken('NN', 0, 0, 'eraAbbr');
      addFormatToken('NNN', 0, 0, 'eraAbbr');
      addFormatToken('NNNN', 0, 0, 'eraName');
      addFormatToken('NNNNN', 0, 0, 'eraNarrow');

      addFormatToken('y', ['y', 1], 'yo', 'eraYear');
      addFormatToken('y', ['yy', 2], 0, 'eraYear');
      addFormatToken('y', ['yyy', 3], 0, 'eraYear');
      addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

      addRegexToken('N', matchEraAbbr);
      addRegexToken('NN', matchEraAbbr);
      addRegexToken('NNN', matchEraAbbr);
      addRegexToken('NNNN', matchEraName);
      addRegexToken('NNNNN', matchEraNarrow);

      addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
          input,
          array,
          config,
          token
      ) {
          var era = config._locale.erasParse(input, token, config._strict);
          if (era) {
              getParsingFlags(config).era = era;
          } else {
              getParsingFlags(config).invalidEra = input;
          }
      });

      addRegexToken('y', matchUnsigned);
      addRegexToken('yy', matchUnsigned);
      addRegexToken('yyy', matchUnsigned);
      addRegexToken('yyyy', matchUnsigned);
      addRegexToken('yo', matchEraYearOrdinal);

      addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
      addParseToken(['yo'], function (input, array, config, token) {
          var match;
          if (config._locale._eraYearOrdinalRegex) {
              match = input.match(config._locale._eraYearOrdinalRegex);
          }

          if (config._locale.eraYearOrdinalParse) {
              array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
          } else {
              array[YEAR] = parseInt(input, 10);
          }
      });

      function localeEras(m, format) {
          var i,
              l,
              date,
              eras = this._eras || getLocale('en')._eras;
          for (i = 0, l = eras.length; i < l; ++i) {
              switch (typeof eras[i].since) {
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].since).startOf('day');
                      eras[i].since = date.valueOf();
                      break;
              }

              switch (typeof eras[i].until) {
                  case 'undefined':
                      eras[i].until = +Infinity;
                      break;
                  case 'string':
                      // truncate time
                      date = hooks(eras[i].until).startOf('day').valueOf();
                      eras[i].until = date.valueOf();
                      break;
              }
          }
          return eras;
      }

      function localeErasParse(eraName, format, strict) {
          var i,
              l,
              eras = this.eras(),
              name,
              abbr,
              narrow;
          eraName = eraName.toUpperCase();

          for (i = 0, l = eras.length; i < l; ++i) {
              name = eras[i].name.toUpperCase();
              abbr = eras[i].abbr.toUpperCase();
              narrow = eras[i].narrow.toUpperCase();

              if (strict) {
                  switch (format) {
                      case 'N':
                      case 'NN':
                      case 'NNN':
                          if (abbr === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNN':
                          if (name === eraName) {
                              return eras[i];
                          }
                          break;

                      case 'NNNNN':
                          if (narrow === eraName) {
                              return eras[i];
                          }
                          break;
                  }
              } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                  return eras[i];
              }
          }
      }

      function localeErasConvertYear(era, year) {
          var dir = era.since <= era.until ? +1 : -1;
          if (year === undefined) {
              return hooks(era.since).year();
          } else {
              return hooks(era.since).year() + (year - era.offset) * dir;
          }
      }

      function getEraName() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].name;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].name;
              }
          }

          return '';
      }

      function getEraNarrow() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].narrow;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].narrow;
              }
          }

          return '';
      }

      function getEraAbbr() {
          var i,
              l,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              // truncate time
              val = this.startOf('day').valueOf();

              if (eras[i].since <= val && val <= eras[i].until) {
                  return eras[i].abbr;
              }
              if (eras[i].until <= val && val <= eras[i].since) {
                  return eras[i].abbr;
              }
          }

          return '';
      }

      function getEraYear() {
          var i,
              l,
              dir,
              val,
              eras = this.localeData().eras();
          for (i = 0, l = eras.length; i < l; ++i) {
              dir = eras[i].since <= eras[i].until ? +1 : -1;

              // truncate time
              val = this.startOf('day').valueOf();

              if (
                  (eras[i].since <= val && val <= eras[i].until) ||
                  (eras[i].until <= val && val <= eras[i].since)
              ) {
                  return (
                      (this.year() - hooks(eras[i].since).year()) * dir +
                      eras[i].offset
                  );
              }
          }

          return this.year();
      }

      function erasNameRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNameRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNameRegex : this._erasRegex;
      }

      function erasAbbrRegex(isStrict) {
          if (!hasOwnProp(this, '_erasAbbrRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }

      function erasNarrowRegex(isStrict) {
          if (!hasOwnProp(this, '_erasNarrowRegex')) {
              computeErasParse.call(this);
          }
          return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }

      function matchEraAbbr(isStrict, locale) {
          return locale.erasAbbrRegex(isStrict);
      }

      function matchEraName(isStrict, locale) {
          return locale.erasNameRegex(isStrict);
      }

      function matchEraNarrow(isStrict, locale) {
          return locale.erasNarrowRegex(isStrict);
      }

      function matchEraYearOrdinal(isStrict, locale) {
          return locale._eraYearOrdinalRegex || matchUnsigned;
      }

      function computeErasParse() {
          var abbrPieces = [],
              namePieces = [],
              narrowPieces = [],
              mixedPieces = [],
              i,
              l,
              eras = this.eras();

          for (i = 0, l = eras.length; i < l; ++i) {
              namePieces.push(regexEscape(eras[i].name));
              abbrPieces.push(regexEscape(eras[i].abbr));
              narrowPieces.push(regexEscape(eras[i].narrow));

              mixedPieces.push(regexEscape(eras[i].name));
              mixedPieces.push(regexEscape(eras[i].abbr));
              mixedPieces.push(regexEscape(eras[i].narrow));
          }

          this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
          this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
          this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
          this._erasNarrowRegex = new RegExp(
              '^(' + narrowPieces.join('|') + ')',
              'i'
          );
      }

      // FORMATTING

      addFormatToken(0, ['gg', 2], 0, function () {
          return this.weekYear() % 100;
      });

      addFormatToken(0, ['GG', 2], 0, function () {
          return this.isoWeekYear() % 100;
      });

      function addWeekYearFormatToken(token, getter) {
          addFormatToken(0, [token, token.length], 0, getter);
      }

      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');

      // ALIASES

      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');

      // PRIORITY

      addUnitPriority('weekYear', 1);
      addUnitPriority('isoWeekYear', 1);

      // PARSING

      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);

      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
          input,
          week,
          config,
          token
      ) {
          week[token.substr(0, 2)] = toInt(input);
      });

      addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
          week[token] = hooks.parseTwoDigitYear(input);
      });

      // MOMENTS

      function getSetWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.week(),
              this.weekday(),
              this.localeData()._week.dow,
              this.localeData()._week.doy
          );
      }

      function getSetISOWeekYear(input) {
          return getSetWeekYearHelper.call(
              this,
              input,
              this.isoWeek(),
              this.isoWeekday(),
              1,
              4
          );
      }

      function getISOWeeksInYear() {
          return weeksInYear(this.year(), 1, 4);
      }

      function getISOWeeksInISOWeekYear() {
          return weeksInYear(this.isoWeekYear(), 1, 4);
      }

      function getWeeksInYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }

      function getWeeksInWeekYear() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }

      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
          var weeksTarget;
          if (input == null) {
              return weekOfYear(this, dow, doy).year;
          } else {
              weeksTarget = weeksInYear(input, dow, doy);
              if (week > weeksTarget) {
                  week = weeksTarget;
              }
              return setWeekAll.call(this, input, week, weekday, dow, doy);
          }
      }

      function setWeekAll(weekYear, week, weekday, dow, doy) {
          var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
              date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

          this.year(date.getUTCFullYear());
          this.month(date.getUTCMonth());
          this.date(date.getUTCDate());
          return this;
      }

      // FORMATTING

      addFormatToken('Q', 0, 'Qo', 'quarter');

      // ALIASES

      addUnitAlias('quarter', 'Q');

      // PRIORITY

      addUnitPriority('quarter', 7);

      // PARSING

      addRegexToken('Q', match1);
      addParseToken('Q', function (input, array) {
          array[MONTH] = (toInt(input) - 1) * 3;
      });

      // MOMENTS

      function getSetQuarter(input) {
          return input == null
              ? Math.ceil((this.month() + 1) / 3)
              : this.month((input - 1) * 3 + (this.month() % 3));
      }

      // FORMATTING

      addFormatToken('D', ['DD', 2], 'Do', 'date');

      // ALIASES

      addUnitAlias('date', 'D');

      // PRIORITY
      addUnitPriority('date', 9);

      // PARSING

      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function (isStrict, locale) {
          // TODO: Remove "ordinalParse" fallback in next major release.
          return isStrict
              ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
              : locale._dayOfMonthOrdinalParseLenient;
      });

      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function (input, array) {
          array[DATE] = toInt(input.match(match1to2)[0]);
      });

      // MOMENTS

      var getSetDayOfMonth = makeGetSet('Date', true);

      // FORMATTING

      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

      // ALIASES

      addUnitAlias('dayOfYear', 'DDD');

      // PRIORITY
      addUnitPriority('dayOfYear', 4);

      // PARSING

      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function (input, array, config) {
          config._dayOfYear = toInt(input);
      });

      // HELPERS

      // MOMENTS

      function getSetDayOfYear(input) {
          var dayOfYear =
              Math.round(
                  (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
              ) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
      }

      // FORMATTING

      addFormatToken('m', ['mm', 2], 0, 'minute');

      // ALIASES

      addUnitAlias('minute', 'm');

      // PRIORITY

      addUnitPriority('minute', 14);

      // PARSING

      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);

      // MOMENTS

      var getSetMinute = makeGetSet('Minutes', false);

      // FORMATTING

      addFormatToken('s', ['ss', 2], 0, 'second');

      // ALIASES

      addUnitAlias('second', 's');

      // PRIORITY

      addUnitPriority('second', 15);

      // PARSING

      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);

      // MOMENTS

      var getSetSecond = makeGetSet('Seconds', false);

      // FORMATTING

      addFormatToken('S', 0, 0, function () {
          return ~~(this.millisecond() / 100);
      });

      addFormatToken(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10);
      });

      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function () {
          return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function () {
          return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function () {
          return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function () {
          return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
          return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
          return this.millisecond() * 1000000;
      });

      // ALIASES

      addUnitAlias('millisecond', 'ms');

      // PRIORITY

      addUnitPriority('millisecond', 16);

      // PARSING

      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);

      var token, getSetMillisecond;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
          addRegexToken(token, matchUnsigned);
      }

      function parseMs(input, array) {
          array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }

      for (token = 'S'; token.length <= 9; token += 'S') {
          addParseToken(token, parseMs);
      }

      getSetMillisecond = makeGetSet('Milliseconds', false);

      // FORMATTING

      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');

      // MOMENTS

      function getZoneAbbr() {
          return this._isUTC ? 'UTC' : '';
      }

      function getZoneName() {
          return this._isUTC ? 'Coordinated Universal Time' : '';
      }

      var proto = Moment.prototype;

      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== 'undefined' && Symbol.for != null) {
          proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
              return 'Moment<' + this.format() + '>';
          };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
          'dates accessor is deprecated. Use date instead.',
          getSetDayOfMonth
      );
      proto.months = deprecate(
          'months accessor is deprecated. Use month instead',
          getSetMonth
      );
      proto.years = deprecate(
          'years accessor is deprecated. Use year instead',
          getSetYear
      );
      proto.zone = deprecate(
          'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
          getSetZone
      );
      proto.isDSTShifted = deprecate(
          'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
          isDaylightSavingTimeShifted
      );

      function createUnix(input) {
          return createLocal(input * 1000);
      }

      function createInZone() {
          return createLocal.apply(null, arguments).parseZone();
      }

      function preParsePostFormat(string) {
          return string;
      }

      var proto$1 = Locale.prototype;

      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;

      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;

      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;

      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;

      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;

      function get$1(format, index, field, setter) {
          var locale = getLocale(),
              utc = createUTC().set(setter, index);
          return locale[field](utc, format);
      }

      function listMonthsImpl(format, index, field) {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';

          if (index != null) {
              return get$1(format, index, field, 'month');
          }

          var i,
              out = [];
          for (i = 0; i < 12; i++) {
              out[i] = get$1(format, i, field, 'month');
          }
          return out;
      }

      // ()
      // (5)
      // (fmt, 5)
      // (fmt)
      // (true)
      // (true, 5)
      // (true, fmt, 5)
      // (true, fmt)
      function listWeekdaysImpl(localeSorted, format, index, field) {
          if (typeof localeSorted === 'boolean') {
              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          } else {
              format = localeSorted;
              index = format;
              localeSorted = false;

              if (isNumber(format)) {
                  index = format;
                  format = undefined;
              }

              format = format || '';
          }

          var locale = getLocale(),
              shift = localeSorted ? locale._week.dow : 0,
              i,
              out = [];

          if (index != null) {
              return get$1(format, (index + shift) % 7, field, 'day');
          }

          for (i = 0; i < 7; i++) {
              out[i] = get$1(format, (i + shift) % 7, field, 'day');
          }
          return out;
      }

      function listMonths(format, index) {
          return listMonthsImpl(format, index, 'months');
      }

      function listMonthsShort(format, index) {
          return listMonthsImpl(format, index, 'monthsShort');
      }

      function listWeekdays(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }

      function listWeekdaysShort(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }

      function listWeekdaysMin(localeSorted, format, index) {
          return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }

      getSetGlobalLocale('en', {
          eras: [
              {
                  since: '0001-01-01',
                  until: +Infinity,
                  offset: 1,
                  name: 'Anno Domini',
                  narrow: 'AD',
                  abbr: 'AD',
              },
              {
                  since: '0000-12-31',
                  until: -Infinity,
                  offset: 1,
                  name: 'Before Christ',
                  narrow: 'BC',
                  abbr: 'BC',
              },
          ],
          dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
          ordinal: function (number) {
              var b = number % 10,
                  output =
                      toInt((number % 100) / 10) === 1
                          ? 'th'
                          : b === 1
                          ? 'st'
                          : b === 2
                          ? 'nd'
                          : b === 3
                          ? 'rd'
                          : 'th';
              return number + output;
          },
      });

      // Side effect imports

      hooks.lang = deprecate(
          'moment.lang is deprecated. Use moment.locale instead.',
          getSetGlobalLocale
      );
      hooks.langData = deprecate(
          'moment.langData is deprecated. Use moment.localeData instead.',
          getLocale
      );

      var mathAbs = Math.abs;

      function abs() {
          var data = this._data;

          this._milliseconds = mathAbs(this._milliseconds);
          this._days = mathAbs(this._days);
          this._months = mathAbs(this._months);

          data.milliseconds = mathAbs(data.milliseconds);
          data.seconds = mathAbs(data.seconds);
          data.minutes = mathAbs(data.minutes);
          data.hours = mathAbs(data.hours);
          data.months = mathAbs(data.months);
          data.years = mathAbs(data.years);

          return this;
      }

      function addSubtract$1(duration, input, value, direction) {
          var other = createDuration(input, value);

          duration._milliseconds += direction * other._milliseconds;
          duration._days += direction * other._days;
          duration._months += direction * other._months;

          return duration._bubble();
      }

      // supports only 2.0-style add(1, 's') or add(duration)
      function add$1(input, value) {
          return addSubtract$1(this, input, value, 1);
      }

      // supports only 2.0-style subtract(1, 's') or subtract(duration)
      function subtract$1(input, value) {
          return addSubtract$1(this, input, value, -1);
      }

      function absCeil(number) {
          if (number < 0) {
              return Math.floor(number);
          } else {
              return Math.ceil(number);
          }
      }

      function bubble() {
          var milliseconds = this._milliseconds,
              days = this._days,
              months = this._months,
              data = this._data,
              seconds,
              minutes,
              hours,
              years,
              monthsFromDays;

          // if we have a mix of positive and negative values, bubble down first
          // check: https://github.com/moment/moment/issues/2166
          if (
              !(
                  (milliseconds >= 0 && days >= 0 && months >= 0) ||
                  (milliseconds <= 0 && days <= 0 && months <= 0)
              )
          ) {
              milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
              days = 0;
              months = 0;
          }

          // The following code bubbles up values, see the tests for
          // examples of what that means.
          data.milliseconds = milliseconds % 1000;

          seconds = absFloor(milliseconds / 1000);
          data.seconds = seconds % 60;

          minutes = absFloor(seconds / 60);
          data.minutes = minutes % 60;

          hours = absFloor(minutes / 60);
          data.hours = hours % 24;

          days += absFloor(hours / 24);

          // convert days to months
          monthsFromDays = absFloor(daysToMonths(days));
          months += monthsFromDays;
          days -= absCeil(monthsToDays(monthsFromDays));

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          data.days = days;
          data.months = months;
          data.years = years;

          return this;
      }

      function daysToMonths(days) {
          // 400 years have 146097 days (taking into account leap year rules)
          // 400 years have 12 months === 4800
          return (days * 4800) / 146097;
      }

      function monthsToDays(months) {
          // the reverse of daysToMonths
          return (months * 146097) / 4800;
      }

      function as(units) {
          if (!this.isValid()) {
              return NaN;
          }
          var days,
              months,
              milliseconds = this._milliseconds;

          units = normalizeUnits(units);

          if (units === 'month' || units === 'quarter' || units === 'year') {
              days = this._days + milliseconds / 864e5;
              months = this._months + daysToMonths(days);
              switch (units) {
                  case 'month':
                      return months;
                  case 'quarter':
                      return months / 3;
                  case 'year':
                      return months / 12;
              }
          } else {
              // handle milliseconds separately because of floating point math errors (issue #1867)
              days = this._days + Math.round(monthsToDays(this._months));
              switch (units) {
                  case 'week':
                      return days / 7 + milliseconds / 6048e5;
                  case 'day':
                      return days + milliseconds / 864e5;
                  case 'hour':
                      return days * 24 + milliseconds / 36e5;
                  case 'minute':
                      return days * 1440 + milliseconds / 6e4;
                  case 'second':
                      return days * 86400 + milliseconds / 1000;
                  // Math.floor prevents floating point math errors here
                  case 'millisecond':
                      return Math.floor(days * 864e5) + milliseconds;
                  default:
                      throw new Error('Unknown unit ' + units);
              }
          }
      }

      // TODO: Use this.as('ms')?
      function valueOf$1() {
          if (!this.isValid()) {
              return NaN;
          }
          return (
              this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6
          );
      }

      function makeAs(alias) {
          return function () {
              return this.as(alias);
          };
      }

      var asMilliseconds = makeAs('ms'),
          asSeconds = makeAs('s'),
          asMinutes = makeAs('m'),
          asHours = makeAs('h'),
          asDays = makeAs('d'),
          asWeeks = makeAs('w'),
          asMonths = makeAs('M'),
          asQuarters = makeAs('Q'),
          asYears = makeAs('y');

      function clone$1() {
          return createDuration(this);
      }

      function get$2(units) {
          units = normalizeUnits(units);
          return this.isValid() ? this[units + 's']() : NaN;
      }

      function makeGetter(name) {
          return function () {
              return this.isValid() ? this._data[name] : NaN;
          };
      }

      var milliseconds = makeGetter('milliseconds'),
          seconds = makeGetter('seconds'),
          minutes = makeGetter('minutes'),
          hours = makeGetter('hours'),
          days = makeGetter('days'),
          months = makeGetter('months'),
          years = makeGetter('years');

      function weeks() {
          return absFloor(this.days() / 7);
      }

      var round = Math.round,
          thresholds = {
              ss: 44, // a few seconds to seconds
              s: 45, // seconds to minute
              m: 45, // minutes to hour
              h: 22, // hours to day
              d: 26, // days to month/week
              w: null, // weeks to month
              M: 11, // months to year
          };

      // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
          return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }

      function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
          var duration = createDuration(posNegDuration).abs(),
              seconds = round(duration.as('s')),
              minutes = round(duration.as('m')),
              hours = round(duration.as('h')),
              days = round(duration.as('d')),
              months = round(duration.as('M')),
              weeks = round(duration.as('w')),
              years = round(duration.as('y')),
              a =
                  (seconds <= thresholds.ss && ['s', seconds]) ||
                  (seconds < thresholds.s && ['ss', seconds]) ||
                  (minutes <= 1 && ['m']) ||
                  (minutes < thresholds.m && ['mm', minutes]) ||
                  (hours <= 1 && ['h']) ||
                  (hours < thresholds.h && ['hh', hours]) ||
                  (days <= 1 && ['d']) ||
                  (days < thresholds.d && ['dd', days]);

          if (thresholds.w != null) {
              a =
                  a ||
                  (weeks <= 1 && ['w']) ||
                  (weeks < thresholds.w && ['ww', weeks]);
          }
          a = a ||
              (months <= 1 && ['M']) ||
              (months < thresholds.M && ['MM', months]) ||
              (years <= 1 && ['y']) || ['yy', years];

          a[2] = withoutSuffix;
          a[3] = +posNegDuration > 0;
          a[4] = locale;
          return substituteTimeAgo.apply(null, a);
      }

      // This function allows you to set the rounding function for relative time strings
      function getSetRelativeTimeRounding(roundingFunction) {
          if (roundingFunction === undefined) {
              return round;
          }
          if (typeof roundingFunction === 'function') {
              round = roundingFunction;
              return true;
          }
          return false;
      }

      // This function allows you to set a threshold for relative time strings
      function getSetRelativeTimeThreshold(threshold, limit) {
          if (thresholds[threshold] === undefined) {
              return false;
          }
          if (limit === undefined) {
              return thresholds[threshold];
          }
          thresholds[threshold] = limit;
          if (threshold === 's') {
              thresholds.ss = limit - 1;
          }
          return true;
      }

      function humanize(argWithSuffix, argThresholds) {
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var withSuffix = false,
              th = thresholds,
              locale,
              output;

          if (typeof argWithSuffix === 'object') {
              argThresholds = argWithSuffix;
              argWithSuffix = false;
          }
          if (typeof argWithSuffix === 'boolean') {
              withSuffix = argWithSuffix;
          }
          if (typeof argThresholds === 'object') {
              th = Object.assign({}, thresholds, argThresholds);
              if (argThresholds.s != null && argThresholds.ss == null) {
                  th.ss = argThresholds.s - 1;
              }
          }

          locale = this.localeData();
          output = relativeTime$1(this, !withSuffix, th, locale);

          if (withSuffix) {
              output = locale.pastFuture(+this, output);
          }

          return locale.postformat(output);
      }

      var abs$1 = Math.abs;

      function sign(x) {
          return (x > 0) - (x < 0) || +x;
      }

      function toISOString$1() {
          // for ISO strings we do not use the normal bubbling rules:
          //  * milliseconds bubble up until they become hours
          //  * days do not bubble at all
          //  * months bubble up until they become years
          // This is because there is no context-free conversion between hours and days
          // (think of clock changes)
          // and also not between days and months (28-31 days per month)
          if (!this.isValid()) {
              return this.localeData().invalidDate();
          }

          var seconds = abs$1(this._milliseconds) / 1000,
              days = abs$1(this._days),
              months = abs$1(this._months),
              minutes,
              hours,
              years,
              s,
              total = this.asSeconds(),
              totalSign,
              ymSign,
              daysSign,
              hmsSign;

          if (!total) {
              // this is the same as C#'s (Noda) and python (isodate)...
              // but not other JS (goog.date)
              return 'P0D';
          }

          // 3600 seconds -> 60 minutes -> 1 hour
          minutes = absFloor(seconds / 60);
          hours = absFloor(minutes / 60);
          seconds %= 60;
          minutes %= 60;

          // 12 months -> 1 year
          years = absFloor(months / 12);
          months %= 12;

          // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
          s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

          totalSign = total < 0 ? '-' : '';
          ymSign = sign(this._months) !== sign(total) ? '-' : '';
          daysSign = sign(this._days) !== sign(total) ? '-' : '';
          hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

          return (
              totalSign +
              'P' +
              (years ? ymSign + years + 'Y' : '') +
              (months ? ymSign + months + 'M' : '') +
              (days ? daysSign + days + 'D' : '') +
              (hours || minutes || seconds ? 'T' : '') +
              (hours ? hmsSign + hours + 'H' : '') +
              (minutes ? hmsSign + minutes + 'M' : '') +
              (seconds ? hmsSign + s + 'S' : '')
          );
      }

      var proto$2 = Duration.prototype;

      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;

      proto$2.toIsoString = deprecate(
          'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
          toISOString$1
      );
      proto$2.lang = lang;

      // FORMATTING

      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');

      // PARSING

      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function (input, array, config) {
          config._d = new Date(parseFloat(input) * 1000);
      });
      addParseToken('x', function (input, array, config) {
          config._d = new Date(toInt(input));
      });

      //! moment.js

      hooks.version = '2.26.0';

      setHookCallback(createLocal);

      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;

      // currently HTML5 input type only supports 24-hour formats
      hooks.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
          DATE: 'YYYY-MM-DD', // <input type="date" />
          TIME: 'HH:mm', // <input type="time" />
          TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
          TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
          WEEK: 'GGGG-[W]WW', // <input type="week" />
          MONTH: 'YYYY-MM', // <input type="month" />
      };

      return hooks;

  })));
  });

  /* src/characters/CharacterTemplate.svelte generated by Svelte v3.22.3 */
  const file$3 = "src/characters/CharacterTemplate.svelte";

  function get_each_context(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[11] = list[i];
  	return child_ctx;
  }

  // (50:4) {#if attributes}
  function create_if_block$1(ctx) {
  	let table;
  	let tbody;
  	let each_value = /*attributes*/ ctx[3];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			table = element("table");
  			tbody = element("tbody");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			add_location(tbody, file$3, 51, 8, 1041);
  			add_location(table, file$3, 50, 6, 1025);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, table, anchor);
  			append_dev(table, tbody);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(tbody, null);
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*attributes*/ 8) {
  				each_value = /*attributes*/ ctx[3];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(tbody, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(table);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$1.name,
  		type: "if",
  		source: "(50:4) {#if attributes}",
  		ctx
  	});

  	return block;
  }

  // (53:10) {#each attributes as attribute}
  function create_each_block(ctx) {
  	let tr;
  	let td0;
  	let t0_value = /*attribute*/ ctx[11].name + "";
  	let t0;
  	let t1;
  	let td1;
  	let t2_value = /*attribute*/ ctx[11].value + "";
  	let t2;
  	let t3;

  	const block = {
  		c: function create() {
  			tr = element("tr");
  			td0 = element("td");
  			t0 = text(t0_value);
  			t1 = space();
  			td1 = element("td");
  			t2 = text(t2_value);
  			t3 = space();
  			attr_dev(td0, "class", "svelte-k4txm1");
  			add_location(td0, file$3, 54, 14, 1122);
  			attr_dev(td1, "class", "right svelte-k4txm1");
  			add_location(td1, file$3, 55, 14, 1162);
  			add_location(tr, file$3, 53, 12, 1103);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, tr, anchor);
  			append_dev(tr, td0);
  			append_dev(td0, t0);
  			append_dev(tr, t1);
  			append_dev(tr, td1);
  			append_dev(td1, t2);
  			append_dev(tr, t3);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*attributes*/ 8 && t0_value !== (t0_value = /*attribute*/ ctx[11].name + "")) set_data_dev(t0, t0_value);
  			if (dirty & /*attributes*/ 8 && t2_value !== (t2_value = /*attribute*/ ctx[11].value + "")) set_data_dev(t2, t2_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(tr);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block.name,
  		type: "each",
  		source: "(53:10) {#each attributes as attribute}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$7(ctx) {
  	let div3;
  	let div0;
  	let img;
  	let img_src_value;
  	let t0;
  	let span0;
  	let t1;
  	let t2;
  	let span1;
  	let t3;
  	let t4;
  	let div1;
  	let t5;
  	let div2;
  	let button;
  	let dispose;
  	let if_block = /*attributes*/ ctx[3] && create_if_block$1(ctx);

  	const block = {
  		c: function create() {
  			div3 = element("div");
  			div0 = element("div");
  			img = element("img");
  			t0 = space();
  			span0 = element("span");
  			t1 = text(/*name*/ ctx[0]);
  			t2 = space();
  			span1 = element("span");
  			t3 = text(/*description*/ ctx[1]);
  			t4 = space();
  			div1 = element("div");
  			if (if_block) if_block.c();
  			t5 = space();
  			div2 = element("div");
  			button = element("button");
  			button.textContent = "Choose";
  			if (img.src !== (img_src_value = /*avatar*/ ctx[5]())) attr_dev(img, "src", img_src_value);
  			attr_dev(img, "alt", "");
  			attr_dev(img, "class", "circle img svelte-k4txm1");
  			add_location(img, file$3, 42, 4, 833);
  			attr_dev(span0, "class", "card-title");
  			add_location(span0, file$3, 43, 4, 888);
  			add_location(span1, file$3, 44, 4, 931);
  			attr_dev(div0, "class", "card-content white-text");
  			add_location(div0, file$3, 41, 2, 791);
  			attr_dev(div1, "class", "card-content");
  			add_location(div1, file$3, 47, 2, 970);
  			attr_dev(button, "class", "btn green");
  			add_location(button, file$3, 64, 4, 1330);
  			attr_dev(div2, "class", "card-content");
  			add_location(div2, file$3, 63, 2, 1299);
  			attr_dev(div3, "class", "card cyan darken-3 hoverable characterCard center-align svelte-k4txm1");
  			add_location(div3, file$3, 40, 0, 719);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div3, anchor);
  			append_dev(div3, div0);
  			append_dev(div0, img);
  			append_dev(div0, t0);
  			append_dev(div0, span0);
  			append_dev(span0, t1);
  			append_dev(div0, t2);
  			append_dev(div0, span1);
  			append_dev(span1, t3);
  			append_dev(div3, t4);
  			append_dev(div3, div1);
  			if (if_block) if_block.m(div1, null);
  			append_dev(div3, t5);
  			append_dev(div3, div2);
  			append_dev(div2, button);
  			if (remount) dispose();
  			dispose = listen_dev(button, "click", /*click_handler*/ ctx[10], false, false, false);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*name*/ 1) set_data_dev(t1, /*name*/ ctx[0]);
  			if (dirty & /*description*/ 2) set_data_dev(t3, /*description*/ ctx[1]);

  			if (/*attributes*/ ctx[3]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block$1(ctx);
  					if_block.c();
  					if_block.m(div1, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div3);
  			if (if_block) if_block.d();
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$7.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$7($$self, $$props, $$invalidate) {
  	let { name } = $$props;
  	let { description } = $$props;
  	let { created } = $$props;
  	let { level } = $$props;
  	let { xp } = $$props;
  	let { templateId } = $$props;
  	let { attributes } = $$props;
  	let { callback } = $$props;

  	function formattedDate() {
  		return moment(created).format("MMMM Do YYYY, h:mm:ss a");
  	}

  	function avatar() {
  		let num = 1 + Math.abs(name.hashCode() % 12);
  		return "img/avatars/" + num + "p.png";
  	}

  	const writable_props = [
  		"name",
  		"description",
  		"created",
  		"level",
  		"xp",
  		"templateId",
  		"attributes",
  		"callback"
  	];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharacterTemplate> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("CharacterTemplate", $$slots, []);

  	const click_handler = () => {
  		callback(templateId);
  	};

  	$$self.$set = $$props => {
  		if ("name" in $$props) $$invalidate(0, name = $$props.name);
  		if ("description" in $$props) $$invalidate(1, description = $$props.description);
  		if ("created" in $$props) $$invalidate(6, created = $$props.created);
  		if ("level" in $$props) $$invalidate(7, level = $$props.level);
  		if ("xp" in $$props) $$invalidate(8, xp = $$props.xp);
  		if ("templateId" in $$props) $$invalidate(2, templateId = $$props.templateId);
  		if ("attributes" in $$props) $$invalidate(3, attributes = $$props.attributes);
  		if ("callback" in $$props) $$invalidate(4, callback = $$props.callback);
  	};

  	$$self.$capture_state = () => ({
  		MediaQuery: MediaQuery$1,
  		fade,
  		moment,
  		name,
  		description,
  		created,
  		level,
  		xp,
  		templateId,
  		attributes,
  		callback,
  		formattedDate,
  		avatar
  	});

  	$$self.$inject_state = $$props => {
  		if ("name" in $$props) $$invalidate(0, name = $$props.name);
  		if ("description" in $$props) $$invalidate(1, description = $$props.description);
  		if ("created" in $$props) $$invalidate(6, created = $$props.created);
  		if ("level" in $$props) $$invalidate(7, level = $$props.level);
  		if ("xp" in $$props) $$invalidate(8, xp = $$props.xp);
  		if ("templateId" in $$props) $$invalidate(2, templateId = $$props.templateId);
  		if ("attributes" in $$props) $$invalidate(3, attributes = $$props.attributes);
  		if ("callback" in $$props) $$invalidate(4, callback = $$props.callback);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		name,
  		description,
  		templateId,
  		attributes,
  		callback,
  		avatar,
  		created,
  		level,
  		xp,
  		formattedDate,
  		click_handler
  	];
  }

  class CharacterTemplate extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
  			name: 0,
  			description: 1,
  			created: 6,
  			level: 7,
  			xp: 8,
  			templateId: 2,
  			attributes: 3,
  			callback: 4
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "CharacterTemplate",
  			options,
  			id: create_fragment$7.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'name'");
  		}

  		if (/*description*/ ctx[1] === undefined && !("description" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'description'");
  		}

  		if (/*created*/ ctx[6] === undefined && !("created" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'created'");
  		}

  		if (/*level*/ ctx[7] === undefined && !("level" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'level'");
  		}

  		if (/*xp*/ ctx[8] === undefined && !("xp" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'xp'");
  		}

  		if (/*templateId*/ ctx[2] === undefined && !("templateId" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'templateId'");
  		}

  		if (/*attributes*/ ctx[3] === undefined && !("attributes" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'attributes'");
  		}

  		if (/*callback*/ ctx[4] === undefined && !("callback" in props)) {
  			console.warn("<CharacterTemplate> was created without expected prop 'callback'");
  		}
  	}

  	get name() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set name(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get description() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set description(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get created() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set created(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get level() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set level(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xp() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xp(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get templateId() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set templateId(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get attributes() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set attributes(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get callback() {
  		throw new Error("<CharacterTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set callback(value) {
  		throw new Error("<CharacterTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */
  var e=function(t,n){return (e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n]);})(t,n)};function t(t,n){function r(){this.constructor=t;}e(t,n),t.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r);}var n=function(){return (n=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)};function r(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(e);o<r.length;o++)t.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(e,r[o])&&(n[r[o]]=e[r[o]]);}return n}function o(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{s(r.next(e));}catch(e){i(e);}}function c(e){try{s(r.throw(e));}catch(e){i(e);}}function s(e){e.done?o(e.value):new n((function(t){t(e.value);})).then(a,c);}s((r=r.apply(e,t||[])).next());}))}function i(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:c(0),throw:c(1),return:c(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function c(i){return function(c){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(o=a.trys,(o=o.length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=t.call(e,a);}catch(e){i=[6,e],r=0;}finally{n=o=0;}if(5&i[0])throw i[1];return {value:i[0]?i[1]:void 0,done:!0}}([i,c])}}}var a="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function c(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function s(e,t){return e(t={exports:{}},t.exports),t.exports}var u=function(e){return e&&e.Math==Math&&e},l=u("object"==typeof globalThis&&globalThis)||u("object"==typeof window&&window)||u("object"==typeof self&&self)||u("object"==typeof a&&a)||Function("return this")(),f=function(e){try{return !!e()}catch(e){return !0}},d=!f((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),p={}.propertyIsEnumerable,h=Object.getOwnPropertyDescriptor,y={f:h&&!p.call({1:2},1)?function(e){var t=h(this,e);return !!t&&t.enumerable}:p},v=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},m={}.toString,b=function(e){return m.call(e).slice(8,-1)},g="".split,w=f((function(){return !Object("z").propertyIsEnumerable(0)}))?function(e){return "String"==b(e)?g.call(e,""):Object(e)}:Object,S=function(e){if(null==e)throw TypeError("Can't call method on "+e);return e},_=function(e){return w(S(e))},k=function(e){return "object"==typeof e?null!==e:"function"==typeof e},T=function(e,t){if(!k(e))return e;var n,r;if(t&&"function"==typeof(n=e.toString)&&!k(r=n.call(e)))return r;if("function"==typeof(n=e.valueOf)&&!k(r=n.call(e)))return r;if(!t&&"function"==typeof(n=e.toString)&&!k(r=n.call(e)))return r;throw TypeError("Can't convert object to primitive value")},I={}.hasOwnProperty,O=function(e,t){return I.call(e,t)},x=l.document,j=k(x)&&k(x.createElement),E=function(e){return j?x.createElement(e):{}},L=!d&&!f((function(){return 7!=Object.defineProperty(E("div"),"a",{get:function(){return 7}}).a})),W=Object.getOwnPropertyDescriptor,A={f:d?W:function(e,t){if(e=_(e),t=T(t,!0),L)try{return W(e,t)}catch(e){}if(O(e,t))return v(!y.f.call(e,t),e[t])}},Z=function(e){if(!k(e))throw TypeError(String(e)+" is not an object");return e},R=Object.defineProperty,K={f:d?R:function(e,t,n){if(Z(e),t=T(t,!0),Z(n),L)try{return R(e,t,n)}catch(e){}if("get"in n||"set"in n)throw TypeError("Accessors not supported");return "value"in n&&(e[t]=n.value),e}},U=d?function(e,t,n){return K.f(e,t,v(1,n))}:function(e,t,n){return e[t]=n,e},C=function(e,t){try{U(l,e,t);}catch(n){l[e]=t;}return t},G=l["__core-js_shared__"]||C("__core-js_shared__",{}),P=Function.toString;"function"!=typeof G.inspectSource&&(G.inspectSource=function(e){return P.call(e)});var X,V,F,z=G.inspectSource,Y=l.WeakMap,J="function"==typeof Y&&/native code/.test(z(Y)),N=s((function(e){(e.exports=function(e,t){return G[e]||(G[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.6.4",mode:"global",copyright:" 2020 Denis Pushkarev (zloirock.ru)"});})),D=0,M$1=Math.random(),B=function(e){return "Symbol("+String(void 0===e?"":e)+")_"+(++D+M$1).toString(36)},q=N("keys"),H=function(e){return q[e]||(q[e]=B(e))},Q={},$$1=l.WeakMap;if(J){var ee=new $$1,te=ee.get,ne=ee.has,re=ee.set;X=function(e,t){return re.call(ee,e,t),t},V=function(e){return te.call(ee,e)||{}},F=function(e){return ne.call(ee,e)};}else {var oe=H("state");Q[oe]=!0,X=function(e,t){return U(e,oe,t),t},V=function(e){return O(e,oe)?e[oe]:{}},F=function(e){return O(e,oe)};}var ie,ae={set:X,get:V,has:F,enforce:function(e){return F(e)?V(e):X(e,{})},getterFor:function(e){return function(t){var n;if(!k(t)||(n=V(t)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return n}}},ce=s((function(e){var t=ae.get,n=ae.enforce,r=String(String).split("String");(e.exports=function(e,t,o,i){var a=!!i&&!!i.unsafe,c=!!i&&!!i.enumerable,s=!!i&&!!i.noTargetGet;"function"==typeof o&&("string"!=typeof t||O(o,"name")||U(o,"name",t),n(o).source=r.join("string"==typeof t?t:"")),e!==l?(a?!s&&e[t]&&(c=!0):delete e[t],c?e[t]=o:U(e,t,o)):c?e[t]=o:C(t,o);})(Function.prototype,"toString",(function(){return "function"==typeof this&&t(this).source||z(this)}));})),se=l,ue=function(e){return "function"==typeof e?e:void 0},le=function(e,t){return arguments.length<2?ue(se[e])||ue(l[e]):se[e]&&se[e][t]||l[e]&&l[e][t]},fe=Math.ceil,de=Math.floor,pe=function(e){return isNaN(e=+e)?0:(e>0?de:fe)(e)},he=Math.min,ye=function(e){return e>0?he(pe(e),9007199254740991):0},ve=Math.max,me=Math.min,be=function(e){return function(t,n,r){var o,i=_(t),a=ye(i.length),c=function(e,t){var n=pe(e);return n<0?ve(n+t,0):me(n,t)}(r,a);if(e&&n!=n){for(;a>c;)if((o=i[c++])!=o)return !0}else for(;a>c;c++)if((e||c in i)&&i[c]===n)return e||c||0;return !e&&-1}},ge={includes:be(!0),indexOf:be(!1)},we=ge.indexOf,Se=function(e,t){var n,r=_(e),o=0,i=[];for(n in r)!O(Q,n)&&O(r,n)&&i.push(n);for(;t.length>o;)O(r,n=t[o++])&&(~we(i,n)||i.push(n));return i},_e=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],ke=_e.concat("length","prototype"),Te={f:Object.getOwnPropertyNames||function(e){return Se(e,ke)}},Ie={f:Object.getOwnPropertySymbols},Oe=le("Reflect","ownKeys")||function(e){var t=Te.f(Z(e)),n=Ie.f;return n?t.concat(n(e)):t},xe=function(e,t){for(var n=Oe(t),r=K.f,o=A.f,i=0;i<n.length;i++){var a=n[i];O(e,a)||r(e,a,o(t,a));}},je=/#|\.prototype\./,Ee=function(e,t){var n=We[Le(e)];return n==Ze||n!=Ae&&("function"==typeof t?f(t):!!t)},Le=Ee.normalize=function(e){return String(e).replace(je,".").toLowerCase()},We=Ee.data={},Ae=Ee.NATIVE="N",Ze=Ee.POLYFILL="P",Re=Ee,Ke=A.f,Ue=function(e,t){var n,r,o,i,a,c=e.target,s=e.global,u=e.stat;if(n=s?l:u?l[c]||C(c,{}):(l[c]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=Ke(n,r))&&a.value:n[r],!Re(s?r:c+(u?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;xe(i,o);}(e.sham||o&&o.sham)&&U(i,"sham",!0),ce(n,r,i,e);}},Ce=!!Object.getOwnPropertySymbols&&!f((function(){return !String(Symbol())})),Ge=Ce&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,Pe=N("wks"),Xe=l.Symbol,Ve=Ge?Xe:Xe&&Xe.withoutSetter||B,Fe=function(e){return O(Pe,e)||(Ce&&O(Xe,e)?Pe[e]=Xe[e]:Pe[e]=Ve("Symbol."+e)),Pe[e]},ze=Fe("match"),Ye=function(e){if(function(e){var t;return k(e)&&(void 0!==(t=e[ze])?!!t:"RegExp"==b(e))}(e))throw TypeError("The method doesn't accept regular expressions");return e},Je=Fe("match"),Ne=function(e){var t=/./;try{"/./"[e](t);}catch(n){try{return t[Je]=!1,"/./"[e](t)}catch(e){}}return !1},De=A.f,Me="".startsWith,Be=Math.min,qe=Ne("startsWith"),He=!(qe||(ie=De(String.prototype,"startsWith"),!ie||ie.writable));Ue({target:"String",proto:!0,forced:!He&&!qe},{startsWith:function(e){var t=String(S(this));Ye(e);var n=ye(Be(arguments.length>1?arguments[1]:void 0,t.length)),r=String(e);return Me?Me.call(t,r,n):t.slice(n,n+r.length)===r}});var Qe,$e,et,tt=function(e){if("function"!=typeof e)throw TypeError(String(e)+" is not a function");return e},nt=function(e,t,n){if(tt(e),void 0===t)return e;switch(n){case 0:return function(){return e.call(t)};case 1:return function(n){return e.call(t,n)};case 2:return function(n,r){return e.call(t,n,r)};case 3:return function(n,r,o){return e.call(t,n,r,o)}}return function(){return e.apply(t,arguments)}},rt=Function.call,ot=function(e,t,n){return nt(rt,l[e].prototype[t],n)},it=(ot("String","startsWith"),function(e){return function(t,n){var r,o,i=String(S(t)),a=pe(n),c=i.length;return a<0||a>=c?e?"":void 0:(r=i.charCodeAt(a))<55296||r>56319||a+1===c||(o=i.charCodeAt(a+1))<56320||o>57343?e?i.charAt(a):r:e?i.slice(a,a+2):o-56320+(r-55296<<10)+65536}}),at={codeAt:it(!1),charAt:it(!0)},ct=function(e){return Object(S(e))},st=!f((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),ut=H("IE_PROTO"),lt=Object.prototype,ft=st?Object.getPrototypeOf:function(e){return e=ct(e),O(e,ut)?e[ut]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?lt:null},dt=Fe("iterator"),pt=!1;[].keys&&("next"in(et=[].keys())?($e=ft(ft(et)))!==Object.prototype&&(Qe=$e):pt=!0),null==Qe&&(Qe={}),O(Qe,dt)||U(Qe,dt,(function(){return this}));var ht,yt={IteratorPrototype:Qe,BUGGY_SAFARI_ITERATORS:pt},vt=Object.keys||function(e){return Se(e,_e)},mt=d?Object.defineProperties:function(e,t){Z(e);for(var n,r=vt(t),o=r.length,i=0;o>i;)K.f(e,n=r[i++],t[n]);return e},bt=le("document","documentElement"),gt=H("IE_PROTO"),wt=function(){},St=function(e){return "<script>"+e+"<\/script>"},_t=function(){try{ht=document.domain&&new ActiveXObject("htmlfile");}catch(e){}var e,t;_t=ht?function(e){e.write(St("")),e.close();var t=e.parentWindow.Object;return e=null,t}(ht):((t=E("iframe")).style.display="none",bt.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(St("document.F=Object")),e.close(),e.F);for(var n=_e.length;n--;)delete _t.prototype[_e[n]];return _t()};Q[gt]=!0;var kt=Object.create||function(e,t){var n;return null!==e?(wt.prototype=Z(e),n=new wt,wt.prototype=null,n[gt]=e):n=_t(),void 0===t?n:mt(n,t)},Tt=K.f,It=Fe("toStringTag"),Ot=function(e,t,n){e&&!O(e=n?e:e.prototype,It)&&Tt(e,It,{configurable:!0,value:t});},xt={},jt=yt.IteratorPrototype,Et=function(){return this},Lt=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(n,[]),t=n instanceof Array;}catch(e){}return function(n,r){return Z(n),function(e){if(!k(e)&&null!==e)throw TypeError("Can't set "+String(e)+" as a prototype")}(r),t?e.call(n,r):n.__proto__=r,n}}():void 0),Wt=yt.IteratorPrototype,At=yt.BUGGY_SAFARI_ITERATORS,Zt=Fe("iterator"),Rt=function(){return this},Kt=function(e,t,n,r,o,i,a){!function(e,t,n){var r=t+" Iterator";e.prototype=kt(jt,{next:v(1,n)}),Ot(e,r,!1),xt[r]=Et;}(n,t,r);var c,s,u,l=function(e){if(e===o&&y)return y;if(!At&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[Zt]||p["@@iterator"]||o&&p[o],y=!At&&h||l(o),m="Array"==t&&p.entries||h;if(m&&(c=ft(m.call(new e)),Wt!==Object.prototype&&c.next&&(ft(c)!==Wt&&(Lt?Lt(c,Wt):"function"!=typeof c[Zt]&&U(c,Zt,Rt)),Ot(c,f,!0))),"values"==o&&h&&"values"!==h.name&&(d=!0,y=function(){return h.call(this)}),p[Zt]!==y&&U(p,Zt,y),xt[t]=y,o)if(s={values:l("values"),keys:i?y:l("keys"),entries:l("entries")},a)for(u in s)(At||d||!(u in p))&&ce(p,u,s[u]);else Ue({target:t,proto:!0,forced:At||d},s);return s},Ut=at.charAt,Ct=ae.set,Gt=ae.getterFor("String Iterator");Kt(String,"String",(function(e){Ct(this,{type:"String Iterator",string:String(e),index:0});}),(function(){var e,t=Gt(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=Ut(n,r),t.index+=e.length,{value:e,done:!1})}));var Pt=function(e,t,n,r){try{return r?t(Z(n)[0],n[1]):t(n)}catch(t){var o=e.return;throw void 0!==o&&Z(o.call(e)),t}},Xt=Fe("iterator"),Vt=Array.prototype,Ft=function(e){return void 0!==e&&(xt.Array===e||Vt[Xt]===e)},zt=function(e,t,n){var r=T(t);r in e?K.f(e,r,v(0,n)):e[r]=n;},Yt={};Yt[Fe("toStringTag")]="z";var Jt="[object z]"===String(Yt),Nt=Fe("toStringTag"),Dt="Arguments"==b(function(){return arguments}()),Mt=Jt?b:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=Object(e),Nt))?n:Dt?b(t):"Object"==(r=b(t))&&"function"==typeof t.callee?"Arguments":r},Bt=Fe("iterator"),qt=function(e){if(null!=e)return e[Bt]||e["@@iterator"]||xt[Mt(e)]},Ht=Fe("iterator"),Qt=!1;try{var $t=0,en={next:function(){return {done:!!$t++}},return:function(){Qt=!0;}};en[Ht]=function(){return this},Array.from(en,(function(){throw 2}));}catch(e){}var tn=function(e,t){if(!t&&!Qt)return !1;var n=!1;try{var r={};r[Ht]=function(){return {next:function(){return {done:n=!0}}}},e(r);}catch(e){}return n},nn=!tn((function(e){Array.from(e);}));Ue({target:"Array",stat:!0,forced:nn},{from:function(e){var t,n,r,o,i,a,c=ct(e),s="function"==typeof this?this:Array,u=arguments.length,l=u>1?arguments[1]:void 0,f=void 0!==l,d=qt(c),p=0;if(f&&(l=nt(l,u>2?arguments[2]:void 0,2)),null==d||s==Array&&Ft(d))for(n=new s(t=ye(c.length));t>p;p++)a=f?l(c[p],p):c[p],zt(n,p,a);else for(i=(o=d.call(c)).next,n=new s;!(r=i.call(o)).done;p++)a=f?Pt(o,l,[r.value,p],!0):r.value,zt(n,p,a);return n.length=p,n}});se.Array.from;var rn,on="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView,an=K.f,cn=l.Int8Array,sn=cn&&cn.prototype,un=l.Uint8ClampedArray,ln=un&&un.prototype,fn=cn&&ft(cn),dn=sn&&ft(sn),pn=Object.prototype,hn=pn.isPrototypeOf,yn=Fe("toStringTag"),vn=B("TYPED_ARRAY_TAG"),mn=on&&!!Lt&&"Opera"!==Mt(l.opera),bn={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},gn=function(e){return k(e)&&O(bn,Mt(e))};for(rn in bn)l[rn]||(mn=!1);if((!mn||"function"!=typeof fn||fn===Function.prototype)&&(fn=function(){throw TypeError("Incorrect invocation")},mn))for(rn in bn)l[rn]&&Lt(l[rn],fn);if((!mn||!dn||dn===pn)&&(dn=fn.prototype,mn))for(rn in bn)l[rn]&&Lt(l[rn].prototype,dn);if(mn&&ft(ln)!==dn&&Lt(ln,dn),d&&!O(dn,yn))for(rn in an(dn,yn,{get:function(){return k(this)?this[vn]:void 0}}),bn)l[rn]&&U(l[rn],vn,rn);var wn=function(e){if(gn(e))return e;throw TypeError("Target is not a typed array")},Sn=function(e){if(Lt){if(hn.call(fn,e))return e}else for(var t in bn)if(O(bn,rn)){var n=l[t];if(n&&(e===n||hn.call(n,e)))return e}throw TypeError("Target is not a typed array constructor")},_n=function(e,t,n){if(d){if(n)for(var r in bn){var o=l[r];o&&O(o.prototype,e)&&delete o.prototype[e];}dn[e]&&!n||ce(dn,e,n?t:mn&&sn[e]||t);}},kn=Fe("species"),Tn=wn,In=Sn,On=[].slice;_n("slice",(function(e,t){for(var n=On.call(Tn(this),e,t),r=function(e,t){var n,r=Z(e).constructor;return void 0===r||null==(n=Z(r)[kn])?t:tt(n)}(this,this.constructor),o=0,i=n.length,a=new(In(r))(i);i>o;)a[o]=n[o++];return a}),f((function(){new Int8Array(1).slice();})));var xn=Fe("unscopables"),jn=Array.prototype;null==jn[xn]&&K.f(jn,xn,{configurable:!0,value:kt(null)});var En=function(e){jn[xn][e]=!0;},Ln=Object.defineProperty,Wn={},An=function(e){throw e},Zn=ge.includes,Rn=function(e,t){if(O(Wn,e))return Wn[e];t||(t={});var n=[][e],r=!!O(t,"ACCESSORS")&&t.ACCESSORS,o=O(t,0)?t[0]:An,i=O(t,1)?t[1]:void 0;return Wn[e]=!!n&&!f((function(){if(r&&!d)return !0;var e={length:-1};r?Ln(e,1,{enumerable:!0,get:An}):e[1]=1,n.call(e,o,i);}))}("indexOf",{ACCESSORS:!0,1:0});Ue({target:"Array",proto:!0,forced:!Rn},{includes:function(e){return Zn(this,e,arguments.length>1?arguments[1]:void 0)}}),En("includes");ot("Array","includes");Ue({target:"String",proto:!0,forced:!Ne("includes")},{includes:function(e){return !!~String(S(this)).indexOf(Ye(e),arguments.length>1?arguments[1]:void 0)}});ot("String","includes");var Kn=!f((function(){return Object.isExtensible(Object.preventExtensions({}))})),Un=s((function(e){var t=K.f,n=B("meta"),r=0,o=Object.isExtensible||function(){return !0},i=function(e){t(e,n,{value:{objectID:"O"+ ++r,weakData:{}}});},a=e.exports={REQUIRED:!1,fastKey:function(e,t){if(!k(e))return "symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!O(e,n)){if(!o(e))return "F";if(!t)return "E";i(e);}return e[n].objectID},getWeakData:function(e,t){if(!O(e,n)){if(!o(e))return !0;if(!t)return !1;i(e);}return e[n].weakData},onFreeze:function(e){return Kn&&a.REQUIRED&&o(e)&&!O(e,n)&&i(e),e}};Q[n]=!0;})),Cn=(Un.REQUIRED,Un.fastKey,Un.getWeakData,Un.onFreeze,s((function(e){var t=function(e,t){this.stopped=e,this.result=t;};(e.exports=function(e,n,r,o,i){var a,c,s,u,l,f,d,p=nt(n,r,o?2:1);if(i)a=e;else {if("function"!=typeof(c=qt(e)))throw TypeError("Target is not iterable");if(Ft(c)){for(s=0,u=ye(e.length);u>s;s++)if((l=o?p(Z(d=e[s])[0],d[1]):p(e[s]))&&l instanceof t)return l;return new t(!1)}a=c.call(e);}for(f=a.next;!(d=f.call(a)).done;)if("object"==typeof(l=Pt(a,p,d.value,o))&&l&&l instanceof t)return l;return new t(!1)}).stop=function(e){return new t(!0,e)};}))),Gn=function(e,t,n){if(!(e instanceof t))throw TypeError("Incorrect "+(n?n+" ":"")+"invocation");return e},Pn=function(e,t,n){for(var r in t)ce(e,r,t[r],n);return e},Xn=Fe("species"),Vn=K.f,Fn=Un.fastKey,zn=ae.set,Yn=ae.getterFor,Jn=(function(e,t,n){var r=-1!==e.indexOf("Map"),o=-1!==e.indexOf("Weak"),i=r?"set":"add",a=l[e],c=a&&a.prototype,s=a,u={},d=function(e){var t=c[e];ce(c,e,"add"==e?function(e){return t.call(this,0===e?0:e),this}:"delete"==e?function(e){return !(o&&!k(e))&&t.call(this,0===e?0:e)}:"get"==e?function(e){return o&&!k(e)?void 0:t.call(this,0===e?0:e)}:"has"==e?function(e){return !(o&&!k(e))&&t.call(this,0===e?0:e)}:function(e,n){return t.call(this,0===e?0:e,n),this});};if(Re(e,"function"!=typeof a||!(o||c.forEach&&!f((function(){(new a).entries().next();})))))s=n.getConstructor(t,e,r,i),Un.REQUIRED=!0;else if(Re(e,!0)){var p=new s,h=p[i](o?{}:-0,1)!=p,y=f((function(){p.has(1);})),v=tn((function(e){new a(e);})),m=!o&&f((function(){for(var e=new a,t=5;t--;)e[i](t,t);return !e.has(-0)}));v||((s=t((function(t,n){Gn(t,s,e);var o=function(e,t,n){var r,o;return Lt&&"function"==typeof(r=t.constructor)&&r!==n&&k(o=r.prototype)&&o!==n.prototype&&Lt(e,o),e}(new a,t,s);return null!=n&&Cn(n,o[i],o,r),o}))).prototype=c,c.constructor=s),(y||m)&&(d("delete"),d("has"),r&&d("get")),(m||h)&&d(i),o&&c.clear&&delete c.clear;}u[e]=s,Ue({global:!0,forced:s!=a},u),Ot(s,e),o||n.setStrong(s,e,r);}("Set",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),{getConstructor:function(e,t,n,r){var o=e((function(e,i){Gn(e,o,t),zn(e,{type:t,index:kt(null),first:void 0,last:void 0,size:0}),d||(e.size=0),null!=i&&Cn(i,e[r],e,n);})),i=Yn(t),a=function(e,t,n){var r,o,a=i(e),s=c(e,t);return s?s.value=n:(a.last=s={index:o=Fn(t,!0),key:t,value:n,previous:r=a.last,next:void 0,removed:!1},a.first||(a.first=s),r&&(r.next=s),d?a.size++:e.size++,"F"!==o&&(a.index[o]=s)),e},c=function(e,t){var n,r=i(e),o=Fn(t);if("F"!==o)return r.index[o];for(n=r.first;n;n=n.next)if(n.key==t)return n};return Pn(o.prototype,{clear:function(){for(var e=i(this),t=e.index,n=e.first;n;)n.removed=!0,n.previous&&(n.previous=n.previous.next=void 0),delete t[n.index],n=n.next;e.first=e.last=void 0,d?e.size=0:this.size=0;},delete:function(e){var t=i(this),n=c(this,e);if(n){var r=n.next,o=n.previous;delete t.index[n.index],n.removed=!0,o&&(o.next=r),r&&(r.previous=o),t.first==n&&(t.first=r),t.last==n&&(t.last=o),d?t.size--:this.size--;}return !!n},forEach:function(e){for(var t,n=i(this),r=nt(e,arguments.length>1?arguments[1]:void 0,3);t=t?t.next:n.first;)for(r(t.value,t.key,this);t&&t.removed;)t=t.previous;},has:function(e){return !!c(this,e)}}),Pn(o.prototype,n?{get:function(e){var t=c(this,e);return t&&t.value},set:function(e,t){return a(this,0===e?0:e,t)}}:{add:function(e){return a(this,e=0===e?0:e,e)}}),d&&Vn(o.prototype,"size",{get:function(){return i(this).size}}),o},setStrong:function(e,t,n){var r=t+" Iterator",o=Yn(t),i=Yn(r);Kt(e,t,(function(e,t){zn(this,{type:r,target:e,state:o(e),kind:t,last:void 0});}),(function(){for(var e=i(this),t=e.kind,n=e.last;n&&n.removed;)n=n.previous;return e.target&&(e.last=n=n?n.next:e.state.first)?"keys"==t?{value:n.key,done:!1}:"values"==t?{value:n.value,done:!1}:{value:[n.key,n.value],done:!1}:(e.target=void 0,{value:void 0,done:!0})}),n?"entries":"values",!n,!0),function(e){var t=le(e),n=K.f;d&&t&&!t[Xn]&&n(t,Xn,{configurable:!0,get:function(){return this}});}(t);}}),Jt?{}.toString:function(){return "[object "+Mt(this)+"]"});Jt||ce(Object.prototype,"toString",Jn,{unsafe:!0});var Nn={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},Dn=ae.set,Mn=ae.getterFor("Array Iterator"),Bn=Kt(Array,"Array",(function(e,t){Dn(this,{type:"Array Iterator",target:_(e),index:0,kind:t});}),(function(){var e=Mn(this),t=e.target,n=e.kind,r=e.index++;return !t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");xt.Arguments=xt.Array,En("keys"),En("values"),En("entries");var qn=Fe("iterator"),Hn=Fe("toStringTag"),Qn=Bn.values;for(var $n in Nn){var er=l[$n],tr=er&&er.prototype;if(tr){if(tr[qn]!==Qn)try{U(tr,qn,Qn);}catch(e){tr[qn]=Qn;}if(tr[Hn]||U(tr,Hn,$n),Nn[$n])for(var nr in Bn)if(tr[nr]!==Bn[nr])try{U(tr,nr,Bn[nr]);}catch(e){tr[nr]=Bn[nr];}}}se.Set;function rr(e){var t=this.constructor;return this.then((function(n){return t.resolve(e()).then((function(){return n}))}),(function(n){return t.resolve(e()).then((function(){return t.reject(n)}))}))}var or=setTimeout;function ir(e){return Boolean(e&&void 0!==e.length)}function ar(){}function cr(e){if(!(this instanceof cr))throw new TypeError("Promises must be constructed via new");if("function"!=typeof e)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],pr(e,this);}function sr(e,t){for(;3===e._state;)e=e._value;0!==e._state?(e._handled=!0,cr._immediateFn((function(){var n=1===e._state?t.onFulfilled:t.onRejected;if(null!==n){var r;try{r=n(e._value);}catch(e){return void lr(t.promise,e)}ur(t.promise,r);}else (1===e._state?ur:lr)(t.promise,e._value);}))):e._deferreds.push(t);}function ur(e,t){try{if(t===e)throw new TypeError("A promise cannot be resolved with itself.");if(t&&("object"==typeof t||"function"==typeof t)){var n=t.then;if(t instanceof cr)return e._state=3,e._value=t,void fr(e);if("function"==typeof n)return void pr((r=n,o=t,function(){r.apply(o,arguments);}),e)}e._state=1,e._value=t,fr(e);}catch(t){lr(e,t);}var r,o;}function lr(e,t){e._state=2,e._value=t,fr(e);}function fr(e){2===e._state&&0===e._deferreds.length&&cr._immediateFn((function(){e._handled||cr._unhandledRejectionFn(e._value);}));for(var t=0,n=e._deferreds.length;t<n;t++)sr(e,e._deferreds[t]);e._deferreds=null;}function dr(e,t,n){this.onFulfilled="function"==typeof e?e:null,this.onRejected="function"==typeof t?t:null,this.promise=n;}function pr(e,t){var n=!1;try{e((function(e){n||(n=!0,ur(t,e));}),(function(e){n||(n=!0,lr(t,e));}));}catch(e){if(n)return;n=!0,lr(t,e);}}cr.prototype.catch=function(e){return this.then(null,e)},cr.prototype.then=function(e,t){var n=new this.constructor(ar);return sr(this,new dr(e,t,n)),n},cr.prototype.finally=rr,cr.all=function(e){return new cr((function(t,n){if(!ir(e))return n(new TypeError("Promise.all accepts an array"));var r=Array.prototype.slice.call(e);if(0===r.length)return t([]);var o=r.length;function i(e,a){try{if(a&&("object"==typeof a||"function"==typeof a)){var c=a.then;if("function"==typeof c)return void c.call(a,(function(t){i(e,t);}),n)}r[e]=a,0==--o&&t(r);}catch(e){n(e);}}for(var a=0;a<r.length;a++)i(a,r[a]);}))},cr.resolve=function(e){return e&&"object"==typeof e&&e.constructor===cr?e:new cr((function(t){t(e);}))},cr.reject=function(e){return new cr((function(t,n){n(e);}))},cr.race=function(e){return new cr((function(t,n){if(!ir(e))return n(new TypeError("Promise.race accepts an array"));for(var r=0,o=e.length;r<o;r++)cr.resolve(e[r]).then(t,n);}))},cr._immediateFn="function"==typeof setImmediate&&function(e){setImmediate(e);}||function(e){or(e,0);},cr._unhandledRejectionFn=function(e){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",e);};var hr=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}();"Promise"in hr?hr.Promise.prototype.finally||(hr.Promise.prototype.finally=rr):hr.Promise=cr,function(e){function t(){}function n(e,t){if(e=void 0===e?"utf-8":e,t=void 0===t?{fatal:!1}:t,-1==r.indexOf(e.toLowerCase()))throw new RangeError("Failed to construct 'TextDecoder': The encoding label provided ('"+e+"') is invalid.");if(t.fatal)throw Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.")}if(e.TextEncoder&&e.TextDecoder)return !1;var r=["utf-8","utf8","unicode-1-1-utf-8"];Object.defineProperty(t.prototype,"encoding",{value:"utf-8"}),t.prototype.encode=function(e,t){if((t=void 0===t?{stream:!1}:t).stream)throw Error("Failed to encode: the 'stream' option is unsupported.");t=0;for(var n=e.length,r=0,o=Math.max(32,n+(n>>1)+7),i=new Uint8Array(o>>3<<3);t<n;){var a=e.charCodeAt(t++);if(55296<=a&&56319>=a){if(t<n){var c=e.charCodeAt(t);56320==(64512&c)&&(++t,a=((1023&a)<<10)+(1023&c)+65536);}if(55296<=a&&56319>=a)continue}if(r+4>i.length&&(o+=8,o=(o*=1+t/e.length*2)>>3<<3,(c=new Uint8Array(o)).set(i),i=c),0==(4294967168&a))i[r++]=a;else {if(0==(4294965248&a))i[r++]=a>>6&31|192;else if(0==(4294901760&a))i[r++]=a>>12&15|224,i[r++]=a>>6&63|128;else {if(0!=(4292870144&a))continue;i[r++]=a>>18&7|240,i[r++]=a>>12&63|128,i[r++]=a>>6&63|128;}i[r++]=63&a|128;}}return i.slice?i.slice(0,r):i.subarray(0,r)},Object.defineProperty(n.prototype,"encoding",{value:"utf-8"}),Object.defineProperty(n.prototype,"fatal",{value:!1}),Object.defineProperty(n.prototype,"ignoreBOM",{value:!1}),n.prototype.decode=function(e,t){if((t=void 0===t?{stream:!1}:t).stream)throw Error("Failed to decode: the 'stream' option is unsupported.");e.buffer instanceof ArrayBuffer&&(e=e.buffer),e=new Uint8Array(e),t=0;for(var n=[],r=[];;){var o=t<e.length;if(!o||65536&t){if(r.push(String.fromCharCode.apply(null,n)),!o)return r.join("");n=[],e=e.subarray(t),t=0;}if(0===(o=e[t++]))n.push(0);else if(0==(128&o))n.push(o);else if(192==(224&o)){var i=63&e[t++];n.push((31&o)<<6|i);}else if(224==(240&o)){i=63&e[t++];var a=63&e[t++];n.push((31&o)<<12|i<<6|a);}else if(240==(248&o)){65535<(o=(7&o)<<18|(i=63&e[t++])<<12|(a=63&e[t++])<<6|63&e[t++])&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|1023&o),n.push(o);}}},e.TextEncoder=t,e.TextDecoder=n;}("undefined"!=typeof window?window:a),function(){function e(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function t(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}function n(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}function r(e){return (r=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function o(e,t){return (o=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function i(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function c(e,t,n){return (c="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var o=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=r(e)););return e}(e,t);if(o){var i=Object.getOwnPropertyDescriptor(o,t);return i.get?i.get.call(n):i.value}})(e,t,n||e)}var s=function(){function t(){e(this,t),Object.defineProperty(this,"listeners",{value:{},writable:!0,configurable:!0});}return n(t,[{key:"addEventListener",value:function(e,t){e in this.listeners||(this.listeners[e]=[]),this.listeners[e].push(t);}},{key:"removeEventListener",value:function(e,t){if(e in this.listeners)for(var n=this.listeners[e],r=0,o=n.length;r<o;r++)if(n[r]===t)return void n.splice(r,1)}},{key:"dispatchEvent",value:function(e){var t=this;if(e.type in this.listeners){for(var n=function(n){setTimeout((function(){return n.call(t,e)}));},r=this.listeners[e.type],o=0,i=r.length;o<i;o++)n(r[o]);return !e.defaultPrevented}}}]),t}(),u=function(t){function a(){var t;return e(this,a),(t=function(e,t){return !t||"object"!=typeof t&&"function"!=typeof t?i(e):t}(this,r(a).call(this))).listeners||s.call(i(t)),Object.defineProperty(i(t),"aborted",{value:!1,writable:!0,configurable:!0}),Object.defineProperty(i(t),"onabort",{value:null,writable:!0,configurable:!0}),t}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&o(e,t);}(a,t),n(a,[{key:"toString",value:function(){return "[object AbortSignal]"}},{key:"dispatchEvent",value:function(e){"abort"===e.type&&(this.aborted=!0,"function"==typeof this.onabort&&this.onabort.call(this,e)),c(r(a.prototype),"dispatchEvent",this).call(this,e);}}]),a}(s),l=function(){function t(){e(this,t),Object.defineProperty(this,"signal",{value:new u,writable:!0,configurable:!0});}return n(t,[{key:"abort",value:function(){var e;try{e=new Event("abort");}catch(t){"undefined"!=typeof document?document.createEvent?(e=document.createEvent("Event")).initEvent("abort",!1,!1):(e=document.createEventObject()).type="abort":e={type:"abort",bubbles:!1,cancelable:!1};}this.signal.dispatchEvent(e);}},{key:"toString",value:function(){return "[object AbortController]"}}]),t}();"undefined"!=typeof Symbol&&Symbol.toStringTag&&(l.prototype[Symbol.toStringTag]="AbortController",u.prototype[Symbol.toStringTag]="AbortSignal"),function(e){(function(e){return e.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL?(console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill"),!0):"function"==typeof e.Request&&!e.Request.prototype.hasOwnProperty("signal")||!e.AbortController})(e)&&(e.AbortController=l,e.AbortSignal=u);}("undefined"!=typeof self?self:a);}();var yr=s((function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(){var e=this;this.locked=new Map,this.addToLocked=function(t,n){var r=e.locked.get(t);void 0===r?void 0===n?e.locked.set(t,[]):e.locked.set(t,[n]):void 0!==n&&(r.unshift(n),e.locked.set(t,r));},this.isLocked=function(t){return e.locked.has(t)},this.lock=function(t){return new Promise((function(n,r){e.isLocked(t)?e.addToLocked(t,n):(e.addToLocked(t),n());}))},this.unlock=function(t){var n=e.locked.get(t);if(void 0!==n&&0!==n.length){var r=n.pop();e.locked.set(t,n),void 0!==r&&setTimeout(r,0);}else e.locked.delete(t);};}return e.getInstance=function(){return void 0===e.instance&&(e.instance=new e),e.instance},e}();t.default=function(){return n.getInstance()};}));c(yr);var vr=c(s((function(e,t){var n=a&&a.__awaiter||function(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{s(r.next(e));}catch(e){i(e);}}function c(e){try{s(r.throw(e));}catch(e){i(e);}}function s(e){e.done?o(e.value):new n((function(t){t(e.value);})).then(a,c);}s((r=r.apply(e,t||[])).next());}))},r=a&&a.__generator||function(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:c(0),throw:c(1),return:c(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function c(i){return function(c){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!(o=a.trys,(o=o.length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=t.call(e,a);}catch(e){i=[6,e],r=0;}finally{n=o=0;}if(5&i[0])throw i[1];return {value:i[0]?i[1]:void 0,done:!0}}([i,c])}}};Object.defineProperty(t,"__esModule",{value:!0});function o(e){return new Promise((function(t){return setTimeout(t,e)}))}function i(e){for(var t="0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",n="",r=0;r<e;r++){n+=t[Math.floor(Math.random()*t.length)];}return n}var c=function(){function e(){this.acquiredIatSet=new Set,this.id=Date.now().toString()+i(15),this.acquireLock=this.acquireLock.bind(this),this.releaseLock=this.releaseLock.bind(this),this.releaseLock__private__=this.releaseLock__private__.bind(this),this.waitForSomethingToChange=this.waitForSomethingToChange.bind(this),this.refreshLockWhileAcquired=this.refreshLockWhileAcquired.bind(this),void 0===e.waiters&&(e.waiters=[]);}return e.prototype.acquireLock=function(t,a){return void 0===a&&(a=5e3),n(this,void 0,void 0,(function(){var n,c,s,u,l,f;return r(this,(function(r){switch(r.label){case 0:n=Date.now()+i(4),c=Date.now()+a,s="browser-tabs-lock-key-"+t,u=window.localStorage,r.label=1;case 1:return Date.now()<c?[4,o(30)]:[3,8];case 2:return r.sent(),null!==u.getItem(s)?[3,5]:(l=this.id+"-"+t+"-"+n,[4,o(Math.floor(25*Math.random()))]);case 3:return r.sent(),u.setItem(s,JSON.stringify({id:this.id,iat:n,timeoutKey:l,timeAcquired:Date.now(),timeRefreshed:Date.now()})),[4,o(30)];case 4:return r.sent(),null!==(f=u.getItem(s))&&(f=JSON.parse(f)).id===this.id&&f.iat===n?(this.acquiredIatSet.add(n),this.refreshLockWhileAcquired(s,n),[2,!0]):[3,7];case 5:return e.lockCorrector(),[4,this.waitForSomethingToChange(c)];case 6:r.sent(),r.label=7;case 7:return n=Date.now()+i(4),[3,1];case 8:return [2,!1]}}))}))},e.prototype.refreshLockWhileAcquired=function(e,t){return n(this,void 0,void 0,(function(){var o=this;return r(this,(function(i){return setTimeout((function(){return n(o,void 0,void 0,(function(){var n,o;return r(this,(function(r){switch(r.label){case 0:return [4,yr.default().lock(t)];case 1:return r.sent(),this.acquiredIatSet.has(t)?(n=window.localStorage,null===(o=n.getItem(e))?(yr.default().unlock(t),[2]):((o=JSON.parse(o)).timeRefreshed=Date.now(),n.setItem(e,JSON.stringify(o)),yr.default().unlock(t),this.refreshLockWhileAcquired(e,t),[2])):(yr.default().unlock(t),[2])}}))}))}),1e3),[2]}))}))},e.prototype.waitForSomethingToChange=function(t){return n(this,void 0,void 0,(function(){return r(this,(function(n){switch(n.label){case 0:return [4,new Promise((function(n){var r=!1,o=Date.now(),i=!1;function a(){if(i||(window.removeEventListener("storage",a),e.removeFromWaiting(a),clearTimeout(c),i=!0),!r){r=!0;var t=50-(Date.now()-o);t>0?setTimeout(n,t):n();}}window.addEventListener("storage",a),e.addToWaiting(a);var c=setTimeout(a,Math.max(0,t-Date.now()));}))];case 1:return n.sent(),[2]}}))}))},e.addToWaiting=function(t){this.removeFromWaiting(t),void 0!==e.waiters&&e.waiters.push(t);},e.removeFromWaiting=function(t){void 0!==e.waiters&&(e.waiters=e.waiters.filter((function(e){return e!==t})));},e.notifyWaiters=function(){void 0!==e.waiters&&e.waiters.slice().forEach((function(e){return e()}));},e.prototype.releaseLock=function(e){return n(this,void 0,void 0,(function(){return r(this,(function(t){switch(t.label){case 0:return [4,this.releaseLock__private__(e)];case 1:return [2,t.sent()]}}))}))},e.prototype.releaseLock__private__=function(t){return n(this,void 0,void 0,(function(){var n,o,i;return r(this,(function(r){switch(r.label){case 0:return n=window.localStorage,o="browser-tabs-lock-key-"+t,null===(i=n.getItem(o))?[2]:(i=JSON.parse(i)).id!==this.id?[3,2]:[4,yr.default().lock(i.iat)];case 1:r.sent(),this.acquiredIatSet.delete(i.iat),n.removeItem(o),yr.default().unlock(i.iat),e.notifyWaiters(),r.label=2;case 2:return [2]}}))}))},e.lockCorrector=function(){for(var t=Date.now()-5e3,n=window.localStorage,r=Object.keys(n),o=!1,i=0;i<r.length;i++){var a=r[i];if(a.includes("browser-tabs-lock-key")){var c=n.getItem(a);null!==c&&(void 0===(c=JSON.parse(c)).timeRefreshed&&c.timeAcquired<t||void 0!==c.timeRefreshed&&c.timeRefreshed<t)&&(n.removeItem(a),o=!0);}}o&&e.notifyWaiters();},e.waiters=void 0,e}();t.default=c;})));var mr={timeoutInSeconds:60},br={error:"timeout",error_description:"Timeout"},gr=function(e,t){var r,o,i,a=t.popup;if(a?a.location.href=e:(r=e,o=window.screenX+(window.innerWidth-400)/2,i=window.screenY+(window.innerHeight-600)/2,a=window.open(r,"auth0:authorize:popup","left="+o+",top="+i+",width=400,height=600,resizable,scrollbars=yes,status=1")),!a)throw new Error("Could not open popup");return new Promise((function(e,r){var o=setTimeout((function(){r(n(n({},br),{popup:a}));}),1e3*(t.timeoutInSeconds||60));window.addEventListener("message",(function(t){if(t.data&&"authorization_response"===t.data.type){if(clearTimeout(o),a.close(),t.data.response.error)return r(t.data.response);e(t.data.response);}}));}))},wr=function(){var e="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.",t="";return Array.from(Lr().getRandomValues(new Uint8Array(43))).forEach((function(n){return t+=e[n%e.length]})),t},Sr=function(e){return btoa(e)},_r=function(e){return Object.keys(e).filter((function(t){return void 0!==e[t]})).map((function(t){return encodeURIComponent(t)+"="+encodeURIComponent(e[t])})).join("&")},kr=function(e){return o(void 0,void 0,void 0,(function(){var t;return i(this,(function(n){switch(n.label){case 0:return t=Wr().digest({name:"SHA-256"},(new TextEncoder).encode(e)),window.msCrypto?[2,new Promise((function(e,n){t.oncomplete=function(t){e(t.target.result);},t.onerror=function(e){n(e.error);},t.onabort=function(){n("The digest operation was aborted");};}))]:[4,t];case 1:return [2,n.sent()]}}))}))},Tr=function(e){return function(e){return decodeURIComponent(atob(e).split("").map((function(e){return "%"+("00"+e.charCodeAt(0).toString(16)).slice(-2)})).join(""))}(e.replace(/_/g,"/").replace(/-/g,"+"))},Ir=function(e){var t=new Uint8Array(e);return function(e){var t={"+":"-","/":"_","=":""};return e.replace(/[\+\/=]/g,(function(e){return t[e]}))}(window.btoa(String.fromCharCode.apply(String,Array.from(t))))},Or=function(e,t,r,a){return o(void 0,void 0,void 0,(function(){var o,c;return i(this,(function(i){switch(i.label){case 0:return a?(delete t.signal,[2,(l=n({url:e,timeout:r},t),f=a,new Promise((function(e,t){var n=new MessageChannel;n.port1.onmessage=function(n){n.data.error?t(new Error(n.data.error)):e(n.data);},f.postMessage(l,[n.port2]);})))]):[3,1];case 1:return [4,(s=e,u=t,u=u||{},new Promise((function(e,t){var n=new XMLHttpRequest,r=[],o=[],i={},a=function(){return {ok:2==(n.status/100|0),statusText:n.statusText,status:n.status,url:n.responseURL,text:function(){return Promise.resolve(n.responseText)},json:function(){return Promise.resolve(JSON.parse(n.responseText))},blob:function(){return Promise.resolve(new Blob([n.response]))},clone:a,headers:{keys:function(){return r},entries:function(){return o},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var c in n.open(u.method||"get",s,!0),n.onload=function(){n.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,(function(e,t,n){r.push(t=t.toLowerCase()),o.push([t,n]),i[t]=i[t]?i[t]+","+n:n;})),e(a());},n.onerror=t,n.withCredentials="include"==u.credentials,u.headers)n.setRequestHeader(c,u.headers[c]);n.send(u.body||null);})))];case 2:return o=i.sent(),c={ok:o.ok},[4,o.json()];case 3:return [2,(c.json=i.sent(),c)]}var s,u,l,f;}))}))},xr=function(e,t,r,o){void 0===o&&(o=1e4);var i=new AbortController,a=i.signal,c=n(n({},t),{signal:a});return Promise.race([Or(e,c,o,r),new Promise((function(e,t){setTimeout((function(){i.abort(),t(new Error("Timeout when executing 'fetch'"));}),o);}))])},jr=function(e,t,n,a){return o(void 0,void 0,void 0,(function(){var o,c,s,u,l,f,d,p,h,y;return i(this,(function(i){switch(i.label){case 0:s=0,i.label=1;case 1:if(!(s<3))return [3,6];i.label=2;case 2:return i.trys.push([2,4,,5]),[4,xr(e,n,a,t)];case 3:return c=i.sent(),o=null,[3,6];case 4:return u=i.sent(),o=u,[3,5];case 5:return s++,[3,1];case 6:if(o)throw o;if(l=c.json,f=l.error,d=l.error_description,p=r(l,["error","error_description"]),!c.ok)throw h=d||"HTTP error. Unable to fetch "+e,(y=new Error(h)).error=f||"request_error",y.error_description=h,y;return [2,p]}}))}))},Er=function(e,t){return o(void 0,void 0,void 0,(function(){var o=e.baseUrl,a=e.timeout,c=r(e,["baseUrl","timeout"]);return i(this,(function(e){switch(e.label){case 0:return [4,jr(o+"/oauth/token",a,{method:"POST",body:JSON.stringify(n({redirect_uri:window.location.origin},c)),headers:{"Content-type":"application/json"}},t)];case 1:return [2,e.sent()]}}))}))},Lr=function(){return window.crypto||window.msCrypto},Wr=function(){var e=Lr();return e.subtle||e.webkitSubtle},Ar=function(e){return Array.from(new Set(e))},Zr=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return Ar(e.join(" ").trim().split(/\s+/)).join(" ")},Rr=function(e){return "@@auth0spajs@@::"+e.client_id+"::"+e.audience+"::"+e.scope},Kr=function(e){var t=Math.floor(Date.now()/1e3)+e.expires_in;return {body:e,expiresAt:Math.min(t,e.decodedToken.claims.exp)-60}},Ur=function(){function e(){}return e.prototype.save=function(e){var t=Rr(e),n=Kr(e);window.localStorage.setItem(t,JSON.stringify(n));},e.prototype.get=function(e){var t=Rr(e),n=this.readJson(t),r=Math.floor(Date.now()/1e3);if(n){if(!(n.expiresAt<r))return n.body;if(n.body.refresh_token){var o=this.stripData(n);return this.writeJson(t,o),o.body}localStorage.removeItem(t);}},e.prototype.clear=function(){for(var e=localStorage.length-1;e>=0;e--)localStorage.key(e).startsWith("@@auth0spajs@@")&&localStorage.removeItem(localStorage.key(e));},e.prototype.readJson=function(e){var t,n=window.localStorage.getItem(e);if(n&&(t=JSON.parse(n)))return t},e.prototype.writeJson=function(e,t){localStorage.setItem(e,JSON.stringify(t));},e.prototype.stripData=function(e){return {body:{refresh_token:e.body.refresh_token},expiresAt:e.expiresAt}},e}(),Cr=function(){this.enclosedCache=function(){var e={body:{},expiresAt:0};return {save:function(t){var n=Rr(t),r=Kr(t);e[n]=r;},get:function(t){var n=Rr(t),r=e[n],o=Math.floor(Date.now()/1e3);if(r)return r.expiresAt<o?r.body.refresh_token?(r.body={refresh_token:r.body.refresh_token},r.body):void delete e[n]:r.body},clear:function(){e={body:{},expiresAt:0};}}}();},Gr=s((function(e,t){var n=a&&a.__assign||function(){return (n=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e}).apply(this,arguments)};function r(e,t){if(!t)return "";var n="; "+e;return !0===t?n:n+"="+t}function o(e,t,n){return encodeURIComponent(e).replace(/%(23|24|26|2B|5E|60|7C)/g,decodeURIComponent).replace(/\(/g,"%28").replace(/\)/g,"%29")+"="+encodeURIComponent(t).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g,decodeURIComponent)+function(e){if("number"==typeof e.expires){var t=new Date;t.setMilliseconds(t.getMilliseconds()+864e5*e.expires),e.expires=t;}return r("Expires",e.expires?e.expires.toUTCString():"")+r("Domain",e.domain)+r("Path",e.path)+r("Secure",e.secure)+r("SameSite",e.sameSite)}(n)}function i(e){for(var t={},n=e?e.split("; "):[],r=/(%[\dA-F]{2})+/gi,o=0;o<n.length;o++){var i=n[o].split("="),a=i.slice(1).join("=");'"'===a.charAt(0)&&(a=a.slice(1,-1));try{t[i[0].replace(r,decodeURIComponent)]=a.replace(r,decodeURIComponent);}catch(e){}}return t}function c(){return i(document.cookie)}function s(e,t,r){document.cookie=o(e,t,n({path:"/"},r));}t.__esModule=!0,t.encode=o,t.parse=i,t.getAll=c,t.get=function(e){return c()[e]},t.set=s,t.remove=function(e,t){s(e,"",n(n({},t),{expires:-1}));};}));c(Gr);Gr.encode,Gr.parse;var Pr=Gr.getAll,Xr=Gr.get,Vr=Gr.set,Fr=Gr.remove,zr=function(e){var t=Xr(e);if(void 0!==t)return JSON.parse(t)},Yr=function(e,t,n){Vr(e,JSON.stringify(t),{expires:n.daysUntilExpire});},Jr=function(e){Fr(e);},Nr=function(e){return "a0.spajs.txs."+e},Dr=function(){function e(){var e=this;this.transactions={},Object.keys(Pr()||{}).filter((function(e){return e.startsWith("a0.spajs.txs.")})).forEach((function(t){var n=t.replace("a0.spajs.txs.","");e.transactions[n]=zr(t);}));}return e.prototype.create=function(e,t){this.transactions[e]=t,Yr(Nr(e),t,{daysUntilExpire:1});},e.prototype.get=function(e){return this.transactions[e]},e.prototype.remove=function(e){delete this.transactions[e],Jr(Nr(e));},e}(),Mr=function(e){return "number"==typeof e},Br=["iss","aud","exp","nbf","iat","jti","azp","nonce","auth_time","at_hash","c_hash","acr","amr","sub_jwk","cnf","sip_from_tag","sip_date","sip_callid","sip_cseq_num","sip_via_branch","orig","dest","mky","events","toe","txn","rph","sid","vot","vtm"],qr=function(e){if(!e.id_token)throw new Error("ID token is required but missing");var t=function(e){var t=e.split("."),n=t[0],r=t[1],o=t[2];if(3!==t.length||!n||!r||!o)throw new Error("ID token could not be decoded");var i=JSON.parse(Tr(r)),a={__raw:e},c={};return Object.keys(i).forEach((function(e){a[e]=i[e],Br.includes(e)||(c[e]=i[e]);})),{encoded:{header:n,payload:r,signature:o},header:JSON.parse(Tr(n)),claims:a,user:c}}(e.id_token);if(!t.claims.iss)throw new Error("Issuer (iss) claim must be a string present in the ID token");if(t.claims.iss!==e.iss)throw new Error('Issuer (iss) claim mismatch in the ID token; expected "'+e.iss+'", found "'+t.claims.iss+'"');if(!t.user.sub)throw new Error("Subject (sub) claim must be a string present in the ID token");if("RS256"!==t.header.alg)throw new Error('Signature algorithm of "'+t.header.alg+'" is not supported. Expected the ID token to be signed with "RS256".');if(!t.claims.aud||"string"!=typeof t.claims.aud&&!Array.isArray(t.claims.aud))throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");if(Array.isArray(t.claims.aud)){if(!t.claims.aud.includes(e.aud))throw new Error('Audience (aud) claim mismatch in the ID token; expected "'+e.aud+'" but was not one of "'+t.claims.aud.join(", ")+'"');if(t.claims.aud.length>1){if(!t.claims.azp)throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");if(t.claims.azp!==e.aud)throw new Error('Authorized Party (azp) claim mismatch in the ID token; expected "'+e.aud+'", found "'+t.claims.azp+'"')}}else if(t.claims.aud!==e.aud)throw new Error('Audience (aud) claim mismatch in the ID token; expected "'+e.aud+'" but found "'+t.claims.aud+'"');if(e.nonce){if(!t.claims.nonce)throw new Error("Nonce (nonce) claim must be a string present in the ID token");if(t.claims.nonce!==e.nonce)throw new Error('Nonce (nonce) claim mismatch in the ID token; expected "'+e.nonce+'", found "'+t.claims.nonce+'"')}if(e.max_age&&!Mr(t.claims.auth_time))throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");if(!Mr(t.claims.exp))throw new Error("Expiration Time (exp) claim must be a number present in the ID token");if(!Mr(t.claims.iat))throw new Error("Issued At (iat) claim must be a number present in the ID token");var n=e.leeway||60,r=new Date,o=new Date(0),i=new Date(0),a=new Date(0);if(a.setUTCSeconds((parseInt(t.claims.auth_time)+e.max_age)/1e3+n),o.setUTCSeconds(t.claims.exp+n),i.setUTCSeconds(t.claims.nbf-n),r>o)throw new Error("Expiration Time (exp) claim error in the ID token; current time ("+r+") is after expiration time ("+o+")");if(Mr(t.claims.nbf)&&r<i)throw new Error("Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Currrent time ("+r+") is before "+i);if(Mr(t.claims.auth_time)&&r>a)throw new Error("Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Currrent time ("+r+") is after last auth at "+a);return t},Hr=function(e){function n(t,r,o,i){void 0===i&&(i=null);var a=e.call(this,t,r)||this;return a.state=o,a.appState=i,Object.setPrototypeOf(a,n.prototype),a}return t(n,e),n}(function(e){function n(t,r){var o=e.call(this,r)||this;return o.error=t,o.error_description=r,Object.setPrototypeOf(o,n.prototype),o}return t(n,e),n}(Error));function Qr(e,t,n){var r=void 0===t?null:t,o=function(e,t){var n=atob(e);if(t){for(var r=new Uint8Array(n.length),o=0,i=n.length;o<i;++o)r[o]=n.charCodeAt(o);return String.fromCharCode.apply(null,new Uint16Array(r.buffer))}return n}(e,void 0!==n&&n),i=o.indexOf("\n",10)+1,a=o.substring(i)+(r?"//# sourceMappingURL="+r:""),c=new Blob([a],{type:"application/javascript"});return URL.createObjectURL(c)}var $r,eo,to,no,ro=($r="Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwovKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuCkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOyB5b3UgbWF5IG5vdCB1c2UKdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUKTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKClRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRApXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLApNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULgoKU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zCmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4KKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi8KdmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4oZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHIsdD0xLG49YXJndW1lbnRzLmxlbmd0aDt0PG47dCsrKWZvcih2YXIgbyBpbiByPWFyZ3VtZW50c1t0XSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixvKSYmKGVbb109cltvXSk7cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHIoZSxyKXt2YXIgdCxuLG8scyxhPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJm9bMF0pdGhyb3cgb1sxXTtyZXR1cm4gb1sxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBzPXtuZXh0OmkoMCksdGhyb3c6aSgxKSxyZXR1cm46aSgyKX0sImZ1bmN0aW9uIj09dHlwZW9mIFN5bWJvbCYmKHNbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSkscztmdW5jdGlvbiBpKHMpe3JldHVybiBmdW5jdGlvbihpKXtyZXR1cm4gZnVuY3Rpb24ocyl7aWYodCl0aHJvdyBuZXcgVHlwZUVycm9yKCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuIik7Zm9yKDthOyl0cnl7aWYodD0xLG4mJihvPTImc1swXT9uLnJldHVybjpzWzBdP24udGhyb3d8fCgobz1uLnJldHVybikmJm8uY2FsbChuKSwwKTpuLm5leHQpJiYhKG89by5jYWxsKG4sc1sxXSkpLmRvbmUpcmV0dXJuIG87c3dpdGNoKG49MCxvJiYocz1bMiZzWzBdLG8udmFsdWVdKSxzWzBdKXtjYXNlIDA6Y2FzZSAxOm89czticmVhaztjYXNlIDQ6cmV0dXJuIGEubGFiZWwrKyx7dmFsdWU6c1sxXSxkb25lOiExfTtjYXNlIDU6YS5sYWJlbCsrLG49c1sxXSxzPVswXTtjb250aW51ZTtjYXNlIDc6cz1hLm9wcy5wb3AoKSxhLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKG89YS50cnlzLChvPW8ubGVuZ3RoPjAmJm9bby5sZW5ndGgtMV0pfHw2IT09c1swXSYmMiE9PXNbMF0pKXthPTA7Y29udGludWV9aWYoMz09PXNbMF0mJighb3x8c1sxXT5vWzBdJiZzWzFdPG9bM10pKXthLmxhYmVsPXNbMV07YnJlYWt9aWYoNj09PXNbMF0mJmEubGFiZWw8b1sxXSl7YS5sYWJlbD1vWzFdLG89czticmVha31pZihvJiZhLmxhYmVsPG9bMl0pe2EubGFiZWw9b1syXSxhLm9wcy5wdXNoKHMpO2JyZWFrfW9bMl0mJmEub3BzLnBvcCgpLGEudHJ5cy5wb3AoKTtjb250aW51ZX1zPXIuY2FsbChlLGEpfWNhdGNoKGUpe3M9WzYsZV0sbj0wfWZpbmFsbHl7dD1vPTB9aWYoNSZzWzBdKXRocm93IHNbMV07cmV0dXJue3ZhbHVlOnNbMF0/c1sxXTp2b2lkIDAsZG9uZTohMH19KFtzLGldKX19fXZhciB0O2FkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLChmdW5jdGlvbihuKXt2YXIgbyxzLGEsaSx1LGwsYyxmLHA7cmV0dXJuIGw9dm9pZCAwLGM9dm9pZCAwLHA9ZnVuY3Rpb24oKXt2YXIgbCxjLGYscCxoLHksYjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOm89bi5kYXRhLHM9by51cmwsYT1vLnRpbWVvdXQsaT1mdW5jdGlvbihlLHIpe3ZhciB0PXt9O2Zvcih2YXIgbiBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pJiZyLmluZGV4T2Yobik8MCYmKHRbbl09ZVtuXSk7aWYobnVsbCE9ZSYmImZ1bmN0aW9uIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBvPTA7Zm9yKG49T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtvPG4ubGVuZ3RoO28rKylyLmluZGV4T2YobltvXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsbltvXSkmJih0W25bb11dPWVbbltvXV0pfXJldHVybiB0fShvLFsidXJsIiwidGltZW91dCJdKSx1PW4ucG9ydHNbMF0sci5sYWJlbD0xO2Nhc2UgMTppZihyLnRyeXMucHVzaChbMSw3LCw4XSksIShjPUpTT04ucGFyc2UoaS5ib2R5KSkucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09Yy5ncmFudF90eXBlKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoIlRoZSB3ZWIgd29ya2VyIGlzIG1pc3NpbmcgdGhlIHJlZnJlc2ggdG9rZW4iKTtpLmJvZHk9SlNPTi5zdHJpbmdpZnkoZShlKHt9LGMpLHtyZWZyZXNoX3Rva2VuOnR9KSl9Zj1uZXcgQWJvcnRDb250cm9sbGVyLHA9Zi5zaWduYWwsaD12b2lkIDAsci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gci50cnlzLnB1c2goWzIsNCwsNV0pLFs0LFByb21pc2UucmFjZShbKHY9YSxuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHNldFRpbWVvdXQoZSx2KX0pKSksZmV0Y2gocyxlKGUoe30saSkse3NpZ25hbDpwfSkpXSldO2Nhc2UgMzpyZXR1cm4gaD1yLnNlbnQoKSxbMyw1XTtjYXNlIDQ6cmV0dXJuIHk9ci5zZW50KCksdS5wb3N0TWVzc2FnZSh7ZXJyb3I6eS5tZXNzYWdlfSksWzJdO2Nhc2UgNTpyZXR1cm4gaD9bNCxoLmpzb24oKV06KGYuYWJvcnQoKSxbMl0pO2Nhc2UgNjpyZXR1cm4obD1yLnNlbnQoKSkucmVmcmVzaF90b2tlbj8odD1sLnJlZnJlc2hfdG9rZW4sZGVsZXRlIGwucmVmcmVzaF90b2tlbik6dD1udWxsLHUucG9zdE1lc3NhZ2Uoe29rOmgub2ssanNvbjpsfSksWzMsOF07Y2FzZSA3OnJldHVybiBiPXIuc2VudCgpLHUucG9zdE1lc3NhZ2Uoe29rOiExLGpzb246e2Vycm9yX2Rlc2NyaXB0aW9uOmIubWVzc2FnZX19KSxbMyw4XTtjYXNlIDg6cmV0dXJuWzJdfXZhciB2fSkpfSxuZXcoKGY9dm9pZCAwKXx8KGY9UHJvbWlzZSkpKChmdW5jdGlvbihlLHIpe2Z1bmN0aW9uIHQoZSl7dHJ5e28ocC5uZXh0KGUpKX1jYXRjaChlKXtyKGUpfX1mdW5jdGlvbiBuKGUpe3RyeXtvKHAudGhyb3coZSkpfWNhdGNoKGUpe3IoZSl9fWZ1bmN0aW9uIG8ocil7ci5kb25lP2Uoci52YWx1ZSk6bmV3IGYoKGZ1bmN0aW9uKGUpe2Uoci52YWx1ZSl9KSkudGhlbih0LG4pfW8oKHA9cC5hcHBseShsLGN8fFtdKSkubmV4dCgpKX0pKX0pKTsKCg==",eo=null,to=!1,function(e){return no=no||Qr($r,eo,to),new Worker(no,e)}),oo=new vr,io={memory:function(){return (new Cr).enclosedCache},localstorage:function(){return new Ur}},ao=function(e){return io[e]},co=function(){function e(e){var t,n;if(this.options=e,function(){if(!Lr())throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");if(void 0===Wr())throw new Error("\n      auth0-spa-js must run on a secure origin.\n      See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin \n      for more information.\n    ")}(),this.cacheLocation=e.cacheLocation||"memory",!ao(this.cacheLocation))throw new Error('Invalid cache location "'+this.cacheLocation+'"');this.cache=ao(this.cacheLocation)(),this.scope=this.options.scope,this.transactionManager=new Dr,this.domainUrl="https://"+this.options.domain,this.tokenIssuer=this.options.issuer?"https://"+this.options.issuer+"/":this.domainUrl+"/",this.defaultScope=Zr("openid",void 0!==(null===(n=null===(t=this.options)||void 0===t?void 0:t.advancedOptions)||void 0===n?void 0:n.defaultScope)?this.options.advancedOptions.defaultScope:"openid profile email"),this.options.useRefreshTokens&&(this.scope=Zr(this.scope,"offline_access")),window.Worker&&this.options.useRefreshTokens&&"memory"===this.cacheLocation&&!/Trident.*rv:11\.0/.test(navigator.userAgent)&&(this.worker=new ro);}return e.prototype._url=function(e){var t=encodeURIComponent(btoa(JSON.stringify({name:"auth0-spa-js",version:"1.8.1"})));return ""+this.domainUrl+e+"&auth0Client="+t},e.prototype._getParams=function(e,t,o,i,a){var c=this.options,s=(c.domain,c.leeway,c.useRefreshTokens,c.cacheLocation,c.advancedOptions,r(c,["domain","leeway","useRefreshTokens","cacheLocation","advancedOptions"]));return n(n(n({},s),e),{scope:Zr(this.defaultScope,this.scope,e.scope),response_type:"code",response_mode:"query",state:t,nonce:o,redirect_uri:a||this.options.redirect_uri,code_challenge:i,code_challenge_method:"S256"})},e.prototype._authorizeUrl=function(e){return this._url("/authorize?"+_r(e))},e.prototype._verifyIdToken=function(e,t){return qr({iss:this.tokenIssuer,aud:this.options.client_id,id_token:e,nonce:t,leeway:this.options.leeway,max_age:this._parseNumber(this.options.max_age)})},e.prototype._parseNumber=function(e){return "string"!=typeof e?e:parseInt(e,10)||void 0},e.prototype.buildAuthorizeUrl=function(e){return void 0===e&&(e={}),o(this,void 0,void 0,(function(){var t,n,o,a,c,s,u,l,f,d,p;return i(this,(function(i){switch(i.label){case 0:return t=e.redirect_uri,n=e.appState,o=r(e,["redirect_uri","appState"]),a=Sr(wr()),c=Sr(wr()),s=wr(),[4,kr(s)];case 1:return u=i.sent(),l=Ir(u),f=e.fragment?"#"+e.fragment:"",d=this._getParams(o,a,c,l,t),p=this._authorizeUrl(d),this.transactionManager.create(a,{nonce:c,code_verifier:s,appState:n,scope:d.scope,audience:d.audience||"default",redirect_uri:d.redirect_uri}),[2,p+f]}}))}))},e.prototype.loginWithPopup=function(e,t){return void 0===e&&(e={}),void 0===t&&(t={}),o(this,void 0,void 0,(function(){var o,a,c,s,u,l,f,d,p,h,y,v;return i(this,(function(i){switch(i.label){case 0:return o=r(e,[]),a=Sr(wr()),c=Sr(wr()),s=wr(),[4,kr(s)];case 1:return u=i.sent(),l=Ir(u),f=this._getParams(o,a,c,l,this.options.redirect_uri||window.location.origin),d=this._authorizeUrl(n(n({},f),{response_mode:"web_message"})),[4,gr(d,n(n({},t),{timeoutInSeconds:t.timeoutInSeconds||this.options.authorizeTimeoutInSeconds||60}))];case 2:if(p=i.sent(),a!==p.state)throw new Error("Invalid state");return [4,Er({baseUrl:this.domainUrl,client_id:this.options.client_id,code_verifier:s,code:p.code,grant_type:"authorization_code",redirect_uri:f.redirect_uri},this.worker)];case 3:return h=i.sent(),y=this._verifyIdToken(h.id_token,c),v=n(n({},h),{decodedToken:y,scope:f.scope,audience:f.audience||"default",client_id:this.options.client_id}),this.cache.save(v),Yr("auth0.is.authenticated",!0,{daysUntilExpire:1}),[2]}}))}))},e.prototype.getUser=function(e){return void 0===e&&(e={audience:this.options.audience||"default",scope:this.scope||this.defaultScope}),o(this,void 0,void 0,(function(){var t;return i(this,(function(r){return e.scope=Zr(this.defaultScope,e.scope),[2,(t=this.cache.get(n({client_id:this.options.client_id},e)))&&t.decodedToken&&t.decodedToken.user]}))}))},e.prototype.getIdTokenClaims=function(e){return void 0===e&&(e={audience:this.options.audience||"default",scope:this.scope||this.defaultScope}),o(this,void 0,void 0,(function(){var t;return i(this,(function(r){return e.scope=Zr(this.defaultScope,this.scope,e.scope),[2,(t=this.cache.get(n({client_id:this.options.client_id},e)))&&t.decodedToken&&t.decodedToken.claims]}))}))},e.prototype.loginWithRedirect=function(e){return void 0===e&&(e={}),o(this,void 0,void 0,(function(){var t;return i(this,(function(n){switch(n.label){case 0:return [4,this.buildAuthorizeUrl(e)];case 1:return t=n.sent(),window.location.assign(t),[2]}}))}))},e.prototype.handleRedirectCallback=function(e){return void 0===e&&(e=window.location.href),o(this,void 0,void 0,(function(){var t,r,o,a,c,s,u,l,f,d,p;return i(this,(function(i){switch(i.label){case 0:if(0===(t=e.split("?").slice(1)).length)throw new Error("There are no query params available for parsing.");if(r=function(e){e.indexOf("#")>-1&&(e=e.substr(0,e.indexOf("#")));var t=e.split("&"),r={};return t.forEach((function(e){var t=e.split("="),n=t[0],o=t[1];r[n]=decodeURIComponent(o);})),n(n({},r),{expires_in:parseInt(r.expires_in)})}(t.join("")),o=r.state,a=r.code,c=r.error,s=r.error_description,!(u=this.transactionManager.get(o)))throw new Error("Invalid state");if(c)throw this.transactionManager.remove(o),new Hr(c,s,o,u.appState);return this.transactionManager.remove(o),l={baseUrl:this.domainUrl,client_id:this.options.client_id,code_verifier:u.code_verifier,grant_type:"authorization_code",code:a},void 0!==u.redirect_uri&&(l.redirect_uri=u.redirect_uri),[4,Er(l,this.worker)];case 1:return f=i.sent(),d=this._verifyIdToken(f.id_token,u.nonce),p=n(n({},f),{decodedToken:d,audience:u.audience,scope:u.scope,client_id:this.options.client_id}),this.cache.save(p),Yr("auth0.is.authenticated",!0,{daysUntilExpire:1}),[2,{appState:u.appState}]}}))}))},e.prototype.getTokenSilently=function(e){return void 0===e&&(e={}),o(this,void 0,void 0,(function(){var t,o,a,c,s,u;return i(this,(function(i){switch(i.label){case 0:t=n({audience:this.options.audience,scope:Zr(this.defaultScope,this.scope,e.scope),ignoreCache:!1},e),o=t.ignoreCache,a=r(t,["ignoreCache"]),i.label=1;case 1:return i.trys.push([1,7,8,10]),!o&&(c=this.cache.get({scope:a.scope,audience:a.audience||"default",client_id:this.options.client_id}))&&c.access_token?[2,c.access_token]:[4,oo.acquireLock("auth0.lock.getTokenSilently",5e3)];case 2:return i.sent(),!this.options.useRefreshTokens||e.audience?[3,4]:[4,this._getTokenUsingRefreshToken(a)];case 3:return u=i.sent(),[3,6];case 4:return [4,this._getTokenFromIFrame(a)];case 5:u=i.sent(),i.label=6;case 6:return s=u,this.cache.save(n({client_id:this.options.client_id},s)),Yr("auth0.is.authenticated",!0,{daysUntilExpire:1}),[2,s.access_token];case 7:throw i.sent();case 8:return [4,oo.releaseLock("auth0.lock.getTokenSilently")];case 9:return i.sent(),[7];case 10:return [2]}}))}))},e.prototype.getTokenWithPopup=function(e,t){return void 0===e&&(e={audience:this.options.audience,scope:this.scope||this.defaultScope}),void 0===t&&(t=mr),o(this,void 0,void 0,(function(){return i(this,(function(n){switch(n.label){case 0:return e.scope=Zr(this.defaultScope,this.scope,e.scope),[4,this.loginWithPopup(e,t)];case 1:return n.sent(),[2,this.cache.get({scope:e.scope,audience:e.audience||"default",client_id:this.options.client_id}).access_token]}}))}))},e.prototype.isAuthenticated=function(){return o(this,void 0,void 0,(function(){return i(this,(function(e){switch(e.label){case 0:return [4,this.getUser()];case 1:return [2,!!e.sent()]}}))}))},e.prototype.logout=function(e){void 0===e&&(e={}),null!==e.client_id?e.client_id=e.client_id||this.options.client_id:delete e.client_id;var t=e.federated,n=e.localOnly,o=r(e,["federated","localOnly"]);if(n&&t)throw new Error("It is invalid to set both the `federated` and `localOnly` options to `true`");if(this.cache.clear(),Jr("auth0.is.authenticated"),!n){var i=t?"&federated":"",a=this._url("/v2/logout?"+_r(o));window.location.assign(""+a+i);}},e.prototype._getTokenFromIFrame=function(e){return o(this,void 0,void 0,(function(){var t,r,o,a,c,s,u,l,f,d,p;return i(this,(function(i){switch(i.label){case 0:return t=Sr(wr()),r=Sr(wr()),o=wr(),[4,kr(o)];case 1:return a=i.sent(),c=Ir(a),s=this._getParams(e,t,r,c,e.redirect_uri||this.options.redirect_uri||window.location.origin),u=this._authorizeUrl(n(n({},s),{prompt:"none",response_mode:"web_message"})),l=e.timeoutInSeconds||this.options.authorizeTimeoutInSeconds,[4,(h=u,y=this.domainUrl,v=l,void 0===v&&(v=60),new Promise((function(e,t){var n=window.document.createElement("iframe");n.setAttribute("width","0"),n.setAttribute("height","0"),n.style.display="none";var r=function(){window.document.body.contains(n)&&window.document.body.removeChild(n);},o=setTimeout((function(){t(br),r();}),1e3*v),i=function(n){if(n.origin==y&&n.data&&"authorization_response"===n.data.type){var a=n.source;a&&a.close(),n.data.response.error?t(n.data.response):e(n.data.response),clearTimeout(o),window.removeEventListener("message",i,!1),setTimeout(r,2e3);}};window.addEventListener("message",i,!1),window.document.body.appendChild(n),n.setAttribute("src",h);})))];case 2:if(f=i.sent(),t!==f.state)throw new Error("Invalid state");return [4,Er({baseUrl:this.domainUrl,client_id:this.options.client_id,code_verifier:o,code:f.code,grant_type:"authorization_code",redirect_uri:s.redirect_uri},this.worker)];case 3:return d=i.sent(),p=this._verifyIdToken(d.id_token,r),[2,n(n({},d),{decodedToken:p,scope:s.scope,audience:s.audience||"default"})]}var h,y,v;}))}))},e.prototype._getTokenUsingRefreshToken=function(e){return o(this,void 0,void 0,(function(){var t,r,o,a,c;return i(this,(function(i){switch(i.label){case 0:return e.scope=Zr(this.defaultScope,this.scope,e.scope),(t=this.cache.get({scope:e.scope,audience:e.audience||"default",client_id:this.options.client_id}))&&t.refresh_token||this.worker?[3,2]:[4,this._getTokenFromIFrame(e)];case 1:return [2,i.sent()];case 2:r=e.redirect_uri||this.options.redirect_uri||window.location.origin,i.label=3;case 3:return i.trys.push([3,5,,8]),[4,Er({baseUrl:this.domainUrl,client_id:this.options.client_id,grant_type:"refresh_token",refresh_token:t&&t.refresh_token,redirect_uri:r},this.worker)];case 4:return o=i.sent(),[3,8];case 5:return "The web worker is missing the refresh token"!==(a=i.sent()).message?[3,7]:[4,this._getTokenFromIFrame(e)];case 6:return [2,i.sent()];case 7:throw a;case 8:return c=this._verifyIdToken(o.id_token),[2,n(n({},o),{decodedToken:c,scope:e.scope,audience:e.audience||"default"})]}}))}))},e}();function createAuth0Client(e){return o(this,void 0,void 0,(function(){var t,n;return i(this,(function(r){switch(r.label){case 0:if("memory"===(t=new co(e)).cacheLocation&&!zr("auth0.is.authenticated"))return [2,t];r.label=1;case 1:return r.trys.push([1,3,,4]),[4,t.getTokenSilently()];case 2:return r.sent(),[3,4];case 3:if("login_required"!==(n=r.sent()).error)throw n;return [3,4];case 4:return [2,t]}}))}))}//# sourceMappingURL=auth0-spa-js.production.esm.js.map

  // src/auth.js

  const isLoading = writable(true);
  const isAuthenticated = writable(false);
  const authToken = writable("");
  const userInfo = writable({});
  const authError = writable(null);
  const AUTH_KEY = {};

  // Default Auth0 expiration time is 10 hours or something like that.
  // If you want to get fancy you can parse the JWT token and get
  // token's actual expiration time.
  const refreshRate = 10 * 60 * 60 * 1000;

  function createAuth(config) {
    let auth0 = null;
    let intervalId = undefined;

    // You can use Svelte's hooks in plain JS files. How nice!
    onMount(async () => {
      auth0 = await createAuth0Client(config);

      // Not all browsers support this, please program defensively!
      const params = new URLSearchParams(window.location.search);

      // Check if something went wrong during login redirect
      // and extract the error message
      if (params.has("error")) {
        authError.set(new Error(params.get("error_description")));
      }

      // if code then login success
      if (params.has("code")) {
        // Let the Auth0 SDK do it's stuff - save some state, etc.
        await auth0.handleRedirectCallback();
        // Can be smart here and redirect to original path instead of root
        window.history.replaceState({}, document.title, "/");
        authError.set(null);
      }

      const _isAuthenticated = await auth0.isAuthenticated();
      isAuthenticated.set(_isAuthenticated);

      if (_isAuthenticated) {
        // while on it, fetch the user info
        userInfo.set(await auth0.getUser());

        // Get the access token. Make sure to supply audience property
        // in Auth0 config, otherwise you will soon start throwing stuff!
        const token = await auth0.getTokenSilently(config.audience);

        console.log("GET TOKEN SILENTLY " + token);

        authToken.set(token);

        // refresh token after specific period or things will stop
        // working. Useful for long-lived apps like dashboards.
        intervalId = setInterval(async () => {
          authToken.set(await auth0.getTokenSilently(config.audience));
        }, refreshRate);
      }
      isLoading.set(false);

      // clear token refresh interval on component unmount
      return () => {
        intervalId && clearInterval(intervalId);
      };
    });

    // Provide a redirect page if you need.
    // It must be whitelisted in Auth0. I think.
    const login = async (redirectPage) => {
      await auth0.loginWithRedirect({
        redirect_uri: redirectPage || window.location.origin,
        prompt: "login", // Force login prompt. No silence auth for you!
      });
    };

    const logout = async () => {
      auth0.logout({
        returnTo: window.location.origin,
      });
    };

    const auth = {
      isLoading,
      isAuthenticated,
      authToken,
      authError,
      login,
      logout,
      userInfo,
    };

    // Put everything in context so that child
    // components can access the state
    setContext(AUTH_KEY, auth);

    return auth;
  }

  // helper function for child components
  // to access the auth context
  function getAuth() {
    return getContext(AUTH_KEY);
  }

  var bind = function bind(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };

  /*global toString:true*/

  // utils is a library of generic helper functions non-specific to axios

  var toString = Object.prototype.toString;

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Array, otherwise false
   */
  function isArray(val) {
    return toString.call(val) === '[object Array]';
  }

  /**
   * Determine if a value is undefined
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  function isUndefined(val) {
    return typeof val === 'undefined';
  }

  /**
   * Determine if a value is a Buffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Buffer, otherwise false
   */
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
      && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  function isArrayBuffer(val) {
    return toString.call(val) === '[object ArrayBuffer]';
  }

  /**
   * Determine if a value is a FormData
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  function isFormData(val) {
    return (typeof FormData !== 'undefined') && (val instanceof FormData);
  }

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    var result;
    if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
      result = ArrayBuffer.isView(val);
    } else {
      result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a String, otherwise false
   */
  function isString(val) {
    return typeof val === 'string';
  }

  /**
   * Determine if a value is a Number
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Number, otherwise false
   */
  function isNumber(val) {
    return typeof val === 'number';
  }

  /**
   * Determine if a value is an Object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is an Object, otherwise false
   */
  function isObject(val) {
    return val !== null && typeof val === 'object';
  }

  /**
   * Determine if a value is a Date
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Date, otherwise false
   */
  function isDate(val) {
    return toString.call(val) === '[object Date]';
  }

  /**
   * Determine if a value is a File
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a File, otherwise false
   */
  function isFile(val) {
    return toString.call(val) === '[object File]';
  }

  /**
   * Determine if a value is a Blob
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  function isBlob(val) {
    return toString.call(val) === '[object Blob]';
  }

  /**
   * Determine if a value is a Function
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  function isFunction(val) {
    return toString.call(val) === '[object Function]';
  }

  /**
   * Determine if a value is a Stream
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {Object} val The value to test
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
  }

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   * @returns {String} The String freed of excess whitespace
   */
  function trim(str) {
    return str.replace(/^\s*/, '').replace(/\s*$/, '');
  }

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   */
  function isStandardBrowserEnv() {
    if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                             navigator.product === 'NativeScript' ||
                                             navigator.product === 'NS')) {
      return false;
    }
    return (
      typeof window !== 'undefined' &&
      typeof document !== 'undefined'
    );
  }

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   */
  function forEach(obj, fn) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }

    // Force an array if not already something iterable
    if (typeof obj !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }

    if (isArray(obj)) {
      // Iterate over array values
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function merge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = merge(result[key], val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Function equal to merge with the difference being that no reference
   * to original objects is kept.
   *
   * @see merge
   * @param {Object} obj1 Object to merge
   * @returns {Object} Result of all merge properties
   */
  function deepMerge(/* obj1, obj2, obj3, ... */) {
    var result = {};
    function assignValue(val, key) {
      if (typeof result[key] === 'object' && typeof val === 'object') {
        result[key] = deepMerge(result[key], val);
      } else if (typeof val === 'object') {
        result[key] = deepMerge({}, val);
      } else {
        result[key] = val;
      }
    }

    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   * @return {Object} The resulting value of object a
   */
  function extend(a, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === 'function') {
        a[key] = bind(val, thisArg);
      } else {
        a[key] = val;
      }
    });
    return a;
  }

  var utils = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isObject: isObject,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isStandardBrowserEnv: isStandardBrowserEnv,
    forEach: forEach,
    merge: merge,
    deepMerge: deepMerge,
    extend: extend,
    trim: trim
  };

  function encode(val) {
    return encodeURIComponent(val).
      replace(/%40/gi, '@').
      replace(/%3A/gi, ':').
      replace(/%24/g, '$').
      replace(/%2C/gi, ',').
      replace(/%20/g, '+').
      replace(/%5B/gi, '[').
      replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @returns {string} The formatted url
   */
  var buildURL = function buildURL(url, params, paramsSerializer) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }

    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];

      utils.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === 'undefined') {
          return;
        }

        if (utils.isArray(val)) {
          key = key + '[]';
        } else {
          val = [val];
        }

        utils.forEach(val, function parseValue(v) {
          if (utils.isDate(v)) {
            v = v.toISOString();
          } else if (utils.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode(key) + '=' + encode(v));
        });
      });

      serializedParams = parts.join('&');
    }

    if (serializedParams) {
      var hashmarkIndex = url.indexOf('#');
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }

      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }

    return url;
  };

  function InterceptorManager() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  InterceptorManager.prototype.use = function use(fulfilled, rejected) {
    this.handlers.push({
      fulfilled: fulfilled,
      rejected: rejected
    });
    return this.handlers.length - 1;
  };

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   */
  InterceptorManager.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   */
  InterceptorManager.prototype.forEach = function forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };

  var InterceptorManager_1 = InterceptorManager;

  /**
   * Transform the data for a request or a response
   *
   * @param {Object|String} data The data to be transformed
   * @param {Array} headers The headers for the request or response
   * @param {Array|Function} fns A single function or Array of functions
   * @returns {*} The resulting transformed data
   */
  var transformData = function transformData(data, headers, fns) {
    /*eslint no-param-reassign:0*/
    utils.forEach(fns, function transform(fn) {
      data = fn(data, headers);
    });

    return data;
  };

  var isCancel = function isCancel(value) {
    return !!(value && value.__CANCEL__);
  };

  var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
    utils.forEach(headers, function processHeader(value, name) {
      if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name];
      }
    });
  };

  /**
   * Update an Error with the specified config, error code, and response.
   *
   * @param {Error} error The error to update.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The error.
   */
  var enhanceError = function enhanceError(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }

    error.request = request;
    error.response = response;
    error.isAxiosError = true;

    error.toJSON = function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error;
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {Object} config The config.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   * @returns {Error} The created error.
   */
  var createError = function createError(message, config, code, request, response) {
    var error = new Error(message);
    return enhanceError(error, config, code, request, response);
  };

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   */
  var settle = function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(createError(
        'Request failed with status code ' + response.status,
        response.config,
        null,
        response.request,
        response
      ));
    }
  };

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  var isAbsoluteURL = function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
  };

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   * @returns {string} The combined URL
   */
  var combineURLs = function combineURLs(baseURL, relativeURL) {
    return relativeURL
      ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
      : baseURL;
  };

  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   * @returns {string} The combined full path
   */
  var buildFullPath = function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  };

  // Headers whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  var ignoreDuplicateOf = [
    'age', 'authorization', 'content-length', 'content-type', 'etag',
    'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
    'last-modified', 'location', 'max-forwards', 'proxy-authorization',
    'referer', 'retry-after', 'user-agent'
  ];

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} headers Headers needing to be parsed
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = function parseHeaders(headers) {
    var parsed = {};
    var key;
    var val;
    var i;

    if (!headers) { return parsed; }

    utils.forEach(headers.split('\n'), function parser(line) {
      i = line.indexOf(':');
      key = utils.trim(line.substr(0, i)).toLowerCase();
      val = utils.trim(line.substr(i + 1));

      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === 'set-cookie') {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
    });

    return parsed;
  };

  var isURLSameOrigin = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
      (function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement('a');
        var originURL;

        /**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */
        function resolveURL(url) {
          var href = url;

          if (msie) {
          // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute('href', href);
            href = urlParsingNode.href;
          }

          urlParsingNode.setAttribute('href', href);

          // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
              urlParsingNode.pathname :
              '/' + urlParsingNode.pathname
          };
        }

        originURL = resolveURL(window.location.href);

        /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */
        return function isURLSameOrigin(requestURL) {
          var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
          return (parsed.protocol === originURL.protocol &&
              parsed.host === originURL.host);
        };
      })() :

    // Non standard browser envs (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      })()
  );

  var cookies = (
    utils.isStandardBrowserEnv() ?

    // Standard browser envs support document.cookie
      (function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + '=' + encodeURIComponent(value));

            if (utils.isNumber(expires)) {
              cookie.push('expires=' + new Date(expires).toGMTString());
            }

            if (utils.isString(path)) {
              cookie.push('path=' + path);
            }

            if (utils.isString(domain)) {
              cookie.push('domain=' + domain);
            }

            if (secure === true) {
              cookie.push('secure');
            }

            document.cookie = cookie.join('; ');
          },

          read: function read(name) {
            var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
            return (match ? decodeURIComponent(match[3]) : null);
          },

          remove: function remove(name) {
            this.write(name, '', Date.now() - 86400000);
          }
        };
      })() :

    // Non standard browser env (web workers, react-native) lack needed support.
      (function nonStandardBrowserEnv() {
        return {
          write: function write() {},
          read: function read() { return null; },
          remove: function remove() {}
        };
      })()
  );

  var xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;

      if (utils.isFormData(requestData)) {
        delete requestHeaders['Content-Type']; // Let the browser set it
      }

      var request = new XMLHttpRequest();

      // HTTP basic authentication
      if (config.auth) {
        var username = config.auth.username || '';
        var password = config.auth.password || '';
        requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
      }

      var fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

      // Set the request timeout in MS
      request.timeout = config.timeout;

      // Listen for ready state
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }

        // Prepare the response
        var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
        var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };

        settle(resolve, reject, response);

        // Clean up request
        request = null;
      };

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }

        reject(createError('Request aborted', config, 'ECONNABORTED', request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(createError('Network Error', config, null, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
          request));

        // Clean up request
        request = null;
      };

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.
      if (utils.isStandardBrowserEnv()) {
        var cookies$1 = cookies;

        // Add xsrf header
        var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
          cookies$1.read(config.xsrfCookieName) :
          undefined;

        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
            // Remove Content-Type if data is undefined
            delete requestHeaders[key];
          } else {
            // Otherwise add header to the request
            request.setRequestHeader(key, val);
          }
        });
      }

      // Add withCredentials to request if needed
      if (!utils.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }

      // Add responseType to request if needed
      if (config.responseType) {
        try {
          request.responseType = config.responseType;
        } catch (e) {
          // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
          // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
          if (config.responseType !== 'json') {
            throw e;
          }
        }
      }

      // Handle progress if needed
      if (typeof config.onDownloadProgress === 'function') {
        request.addEventListener('progress', config.onDownloadProgress);
      }

      // Not all browsers support upload events
      if (typeof config.onUploadProgress === 'function' && request.upload) {
        request.upload.addEventListener('progress', config.onUploadProgress);
      }

      if (config.cancelToken) {
        // Handle cancellation
        config.cancelToken.promise.then(function onCanceled(cancel) {
          if (!request) {
            return;
          }

          request.abort();
          reject(cancel);
          // Clean up request
          request = null;
        });
      }

      if (requestData === undefined) {
        requestData = null;
      }

      // Send the request
      request.send(requestData);
    });
  };

  var DEFAULT_CONTENT_TYPE = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  function setContentTypeIfUnset(headers, value) {
    if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
      headers['Content-Type'] = value;
    }
  }

  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== 'undefined') {
      // For browsers use XHR adapter
      adapter = xhr;
    } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
      // For node use HTTP adapter
      adapter = xhr;
    }
    return adapter;
  }

  var defaults = {
    adapter: getDefaultAdapter(),

    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, 'Accept');
      normalizeHeaderName(headers, 'Content-Type');
      if (utils.isFormData(data) ||
        utils.isArrayBuffer(data) ||
        utils.isBuffer(data) ||
        utils.isStream(data) ||
        utils.isFile(data) ||
        utils.isBlob(data)
      ) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
        return data.toString();
      }
      if (utils.isObject(data)) {
        setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
        return JSON.stringify(data);
      }
      return data;
    }],

    transformResponse: [function transformResponse(data) {
      /*eslint no-param-reassign:0*/
      if (typeof data === 'string') {
        try {
          data = JSON.parse(data);
        } catch (e) { /* Ignore */ }
      }
      return data;
    }],

    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,

    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',

    maxContentLength: -1,

    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };

  defaults.headers = {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  };

  utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
    defaults.headers[method] = {};
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
  });

  var defaults_1 = defaults;

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   * @returns {Promise} The Promise to be fulfilled
   */
  var dispatchRequest = function dispatchRequest(config) {
    throwIfCancellationRequested(config);

    // Ensure headers exist
    config.headers = config.headers || {};

    // Transform request data
    config.data = transformData(
      config.data,
      config.headers,
      config.transformRequest
    );

    // Flatten headers
    config.headers = utils.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers
    );

    utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );

    var adapter = config.adapter || defaults_1.adapter;

    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData(
        response.data,
        response.headers,
        config.transformResponse
      );

      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData(
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }

      return Promise.reject(reason);
    });
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   * @returns {Object} New object resulting from merging config2 to config1
   */
  var mergeConfig = function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};

    var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
    var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
    var defaultToConfig2Keys = [
      'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
      'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
      'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
      'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
      'httpsAgent', 'cancelToken', 'socketPath'
    ];

    utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      }
    });

    utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
      if (utils.isObject(config2[prop])) {
        config[prop] = utils.deepMerge(config1[prop], config2[prop]);
      } else if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (utils.isObject(config1[prop])) {
        config[prop] = utils.deepMerge(config1[prop]);
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    var axiosKeys = valueFromConfig2Keys
      .concat(mergeDeepPropertiesKeys)
      .concat(defaultToConfig2Keys);

    var otherKeys = Object
      .keys(config2)
      .filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });

    utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
      if (typeof config2[prop] !== 'undefined') {
        config[prop] = config2[prop];
      } else if (typeof config1[prop] !== 'undefined') {
        config[prop] = config1[prop];
      }
    });

    return config;
  };

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   */
  function Axios(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_1(),
      response: new InterceptorManager_1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {Object} config The config specific for this request (merged with this.defaults)
   */
  Axios.prototype.request = function request(config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof config === 'string') {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }

    config = mergeConfig(this.defaults, config);

    // Set config.method
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = 'get';
    }

    // Hook up interceptors middleware
    var chain = [dispatchRequest, undefined];
    var promise = Promise.resolve(config);

    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      chain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      chain.push(interceptor.fulfilled, interceptor.rejected);
    });

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  };

  Axios.prototype.getUri = function getUri(config) {
    config = mergeConfig(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
  };

  // Provide aliases for supported request methods
  utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url
      }));
    };
  });

  utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function(url, data, config) {
      return this.request(utils.merge(config || {}, {
        method: method,
        url: url,
        data: data
      }));
    };
  });

  var Axios_1 = Axios;

  /**
   * A `Cancel` is an object that is thrown when an operation is canceled.
   *
   * @class
   * @param {string=} message The message.
   */
  function Cancel(message) {
    this.message = message;
  }

  Cancel.prototype.toString = function toString() {
    return 'Cancel' + (this.message ? ': ' + this.message : '');
  };

  Cancel.prototype.__CANCEL__ = true;

  var Cancel_1 = Cancel;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @class
   * @param {Function} executor The executor function.
   */
  function CancelToken(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    var token = this;
    executor(function cancel(message) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new Cancel_1(message);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `Cancel` if cancellation has been requested.
   */
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  CancelToken.source = function source() {
    var cancel;
    var token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token: token,
      cancel: cancel
    };
  };

  var CancelToken_1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   * @returns {Function}
   */
  var spread = function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   * @return {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    var context = new Axios_1(defaultConfig);
    var instance = bind(Axios_1.prototype.request, context);

    // Copy axios.prototype to instance
    utils.extend(instance, Axios_1.prototype, context);

    // Copy context to instance
    utils.extend(instance, context);

    return instance;
  }

  // Create the default instance to be exported
  var axios = createInstance(defaults_1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios_1;

  // Factory for creating new instances
  axios.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios.defaults, instanceConfig));
  };

  // Expose Cancel & CancelToken
  axios.Cancel = Cancel_1;
  axios.CancelToken = CancelToken_1;
  axios.isCancel = isCancel;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;

  var axios_1 = axios;

  // Allow use of default import syntax in TypeScript
  var default_1 = axios;
  axios_1.default = default_1;

  var axios$1 = axios_1;

  function onInterval(callback, milliseconds) {
  	const interval = setInterval(callback, milliseconds);

  	onDestroy(() => {
  		clearInterval(interval);
  	});
  }

  //const backend = "http://localhost:8010/api"
  //const wsbackend = "ws://localhost:8010/ws"

  //TODO: make this configurable
  const backend = "/api";
  const wsbackend = "wss://talesofapirate.com/ws";

  function createNewCharacter (token, createDTO, cb, errorCb) {
    axios$1
      .post(`${backend}/newcharacter`, createDTO, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data))
      .catch((err) => errorCb(err));
  }

  function getCharacters(token, cb, errorCb) {
      axios$1
        .get(`${backend}/characters`, {
          mode: "no-cors",
          credentials: "same-origin",
          headers: {
            Authorization: `Bearer ${token}`,
          },
        })
        .then((result) => cb(result.data))
        .catch((err) => errorCb(err));
    }
    // public API
    function getCharacterTemplates(cb, errorCb) {
      axios$1
        .get(`${backend}/templates/characters`, {
          mode: "no-cors",
          credentials: "same-origin",
        })
        .then((result) => cb(result.data))
        .catch((err) => errorCb(err));
    }

  /* src/characters/CharacterCreator.svelte generated by Svelte v3.22.3 */

  const { console: console_1 } = globals;
  const file$4 = "src/characters/CharacterCreator.svelte";

  function get_each_context$1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[23] = list[i];
  	return child_ctx;
  }

  // (89:4) {#if !$store.templateSelected}
  function create_if_block_1$1(ctx) {
  	let p;
  	let t1;
  	let div;
  	let current;
  	let each_value = /*$templates*/ ctx[2];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  	}

  	const out = i => transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const block = {
  		c: function create() {
  			p = element("p");
  			p.textContent = "Select a template which fits you most, you can change starting\n        attributes as well";
  			t1 = space();
  			div = element("div");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			add_location(p, file$4, 89, 6, 1905);
  			attr_dev(div, "class", "row");
  			add_location(div, file$4, 93, 6, 2024);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, p, anchor);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, div, anchor);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$templates, store*/ 12) {
  				each_value = /*$templates*/ ctx[2];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$1(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block$1(child_ctx);
  						each_blocks[i].c();
  						transition_in(each_blocks[i], 1);
  						each_blocks[i].m(div, null);
  					}
  				}

  				group_outros();

  				for (i = each_value.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(p);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(div);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$1.name,
  		type: "if",
  		source: "(89:4) {#if !$store.templateSelected}",
  		ctx
  	});

  	return block;
  }

  // (95:8) {#each $templates as character}
  function create_each_block$1(ctx) {
  	let div;
  	let t;
  	let current;

  	function func(...args) {
  		return /*func*/ ctx[20](/*character*/ ctx[23], ...args);
  	}

  	const charactertemplate = new CharacterTemplate({
  			props: {
  				name: /*character*/ ctx[23].name,
  				description: /*character*/ ctx[23].description,
  				created: /*character*/ ctx[23].created,
  				attributes: /*character*/ ctx[23].attributes,
  				templateId: /*character*/ ctx[23].templateId,
  				callback: func
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			div = element("div");
  			create_component(charactertemplate.$$.fragment);
  			t = space();
  			attr_dev(div, "class", "col s4");
  			add_location(div, file$4, 95, 10, 2092);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			mount_component(charactertemplate, div, null);
  			append_dev(div, t);
  			current = true;
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;
  			const charactertemplate_changes = {};
  			if (dirty & /*$templates*/ 4) charactertemplate_changes.name = /*character*/ ctx[23].name;
  			if (dirty & /*$templates*/ 4) charactertemplate_changes.description = /*character*/ ctx[23].description;
  			if (dirty & /*$templates*/ 4) charactertemplate_changes.created = /*character*/ ctx[23].created;
  			if (dirty & /*$templates*/ 4) charactertemplate_changes.attributes = /*character*/ ctx[23].attributes;
  			if (dirty & /*$templates*/ 4) charactertemplate_changes.templateId = /*character*/ ctx[23].templateId;
  			if (dirty & /*$templates*/ 4) charactertemplate_changes.callback = func;
  			charactertemplate.$set(charactertemplate_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(charactertemplate.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(charactertemplate.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			destroy_component(charactertemplate);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$1.name,
  		type: "each",
  		source: "(95:8) {#each $templates as character}",
  		ctx
  	});

  	return block;
  }

  // (120:6) {#if $store.templateSelected}
  function create_if_block$2(ctx) {
  	let div;
  	let current;

  	const charactertemplate = new CharacterTemplate({
  			props: {
  				name: /*$store*/ ctx[1].name,
  				description: /*$store*/ ctx[1].description,
  				created: /*$store*/ ctx[1].character.created,
  				attributes: /*$store*/ ctx[1].character.attributes
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			div = element("div");
  			create_component(charactertemplate.$$.fragment);
  			attr_dev(div, "class", "col s4");
  			add_location(div, file$4, 120, 8, 2914);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			mount_component(charactertemplate, div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const charactertemplate_changes = {};
  			if (dirty & /*$store*/ 2) charactertemplate_changes.name = /*$store*/ ctx[1].name;
  			if (dirty & /*$store*/ 2) charactertemplate_changes.description = /*$store*/ ctx[1].description;
  			if (dirty & /*$store*/ 2) charactertemplate_changes.created = /*$store*/ ctx[1].character.created;
  			if (dirty & /*$store*/ 2) charactertemplate_changes.attributes = /*$store*/ ctx[1].character.attributes;
  			charactertemplate.$set(charactertemplate_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(charactertemplate.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(charactertemplate.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			destroy_component(charactertemplate);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$2.name,
  		type: "if",
  		source: "(120:6) {#if $store.templateSelected}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$8(ctx) {
  	let div6;
  	let div4;
  	let h4;
  	let t1;
  	let t2;
  	let div3;
  	let t3;
  	let div2;
  	let div0;
  	let input0;
  	let t4;
  	let label0;
  	let t6;
  	let div1;
  	let input1;
  	let t7;
  	let label1;
  	let t9;
  	let div5;
  	let button0;
  	let t11;
  	let button1;
  	let current;
  	let dispose;
  	let if_block0 = !/*$store*/ ctx[1].templateSelected && create_if_block_1$1(ctx);
  	let if_block1 = /*$store*/ ctx[1].templateSelected && create_if_block$2(ctx);

  	const block = {
  		c: function create() {
  			div6 = element("div");
  			div4 = element("div");
  			h4 = element("h4");
  			h4.textContent = "Create new Character";
  			t1 = space();
  			if (if_block0) if_block0.c();
  			t2 = space();
  			div3 = element("div");
  			if (if_block1) if_block1.c();
  			t3 = space();
  			div2 = element("div");
  			div0 = element("div");
  			input0 = element("input");
  			t4 = space();
  			label0 = element("label");
  			label0.textContent = "Name";
  			t6 = space();
  			div1 = element("div");
  			input1 = element("input");
  			t7 = space();
  			label1 = element("label");
  			label1.textContent = "Description";
  			t9 = space();
  			div5 = element("div");
  			button0 = element("button");
  			button0.textContent = "Cancel";
  			t11 = space();
  			button1 = element("button");
  			button1.textContent = "Create";
  			add_location(h4, file$4, 86, 4, 1833);
  			attr_dev(input0, "id", "name");
  			attr_dev(input0, "type", "text");
  			attr_dev(input0, "class", "validate svelte-zc7mv9");
  			add_location(input0, file$4, 132, 10, 3260);
  			attr_dev(label0, "for", "name");
  			attr_dev(label0, "class", "active");
  			add_location(label0, file$4, 138, 10, 3404);
  			attr_dev(div0, "class", "input-field");
  			add_location(div0, file$4, 131, 8, 3224);
  			attr_dev(input1, "id", "description");
  			attr_dev(input1, "type", "text");
  			attr_dev(input1, "class", "svelte-zc7mv9");
  			add_location(input1, file$4, 142, 10, 3510);
  			attr_dev(label1, "for", "description");
  			attr_dev(label1, "class", "active");
  			add_location(label1, file$4, 147, 10, 3639);
  			attr_dev(div1, "class", "input-field");
  			add_location(div1, file$4, 141, 8, 3474);
  			attr_dev(div2, "class", "col s8");
  			add_location(div2, file$4, 129, 6, 3194);
  			attr_dev(div3, "class", "row");
  			add_location(div3, file$4, 118, 4, 2852);
  			attr_dev(div4, "class", "modal-content");
  			add_location(div4, file$4, 85, 2, 1801);
  			attr_dev(button0, "href", "#!");
  			attr_dev(button0, "class", "modal-close waves-effect waves-red btn");
  			add_location(button0, file$4, 153, 4, 3780);
  			attr_dev(button1, "href", "#!");
  			attr_dev(button1, "class", "modal-close waves-effect waves-green btn");
  			add_location(button1, file$4, 159, 4, 3900);
  			attr_dev(div5, "class", "modal-footer");
  			add_location(div5, file$4, 152, 2, 3749);
  			attr_dev(div6, "id", "modal1");
  			attr_dev(div6, "class", "modal svelte-zc7mv9");
  			add_location(div6, file$4, 84, 0, 1767);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div6, anchor);
  			append_dev(div6, div4);
  			append_dev(div4, h4);
  			append_dev(div4, t1);
  			if (if_block0) if_block0.m(div4, null);
  			append_dev(div4, t2);
  			append_dev(div4, div3);
  			if (if_block1) if_block1.m(div3, null);
  			append_dev(div3, t3);
  			append_dev(div3, div2);
  			append_dev(div2, div0);
  			append_dev(div0, input0);
  			set_input_value(input0, /*$store*/ ctx[1].name);
  			append_dev(div0, t4);
  			append_dev(div0, label0);
  			append_dev(div2, t6);
  			append_dev(div2, div1);
  			append_dev(div1, input1);
  			set_input_value(input1, /*$store*/ ctx[1].description);
  			append_dev(div1, t7);
  			append_dev(div1, label1);
  			append_dev(div6, t9);
  			append_dev(div6, div5);
  			append_dev(div5, button0);
  			append_dev(div5, t11);
  			append_dev(div5, button1);
  			current = true;
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input0, "input", /*input0_input_handler*/ ctx[21]),
  				listen_dev(input1, "input", /*input1_input_handler*/ ctx[22]),
  				listen_dev(button1, "click", /*create*/ ctx[9], false, false, false)
  			];
  		},
  		p: function update(ctx, [dirty]) {
  			if (!/*$store*/ ctx[1].templateSelected) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty & /*$store*/ 2) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_1$1(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div4, t2);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (/*$store*/ ctx[1].templateSelected) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty & /*$store*/ 2) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block$2(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div3, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (dirty & /*$store*/ 2 && input0.value !== /*$store*/ ctx[1].name) {
  				set_input_value(input0, /*$store*/ ctx[1].name);
  			}

  			if (dirty & /*$store*/ 2 && input1.value !== /*$store*/ ctx[1].description) {
  				set_input_value(input1, /*$store*/ ctx[1].description);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div6);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$8.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$8($$self, $$props, $$invalidate) {
  	let $isLoading;
  	let $isAuthenticated;
  	let $authError;
  	let $userInfo;
  	let $authToken;
  	let $store;
  	let $templates;
  	let data = [];
  	let topTen = [];

  	const store = writable({
  		templateSelected: false,
  		selectedTemplate: 0,
  		character: {},
  		name: "unnamed",
  		description: "Describe your new character"
  	});

  	validate_store(store, "store");
  	component_subscribe($$self, store, value => $$invalidate(1, $store = value));
  	const { isLoading, isAuthenticated, login, logout, authToken, authError, userInfo } = getAuth();
  	validate_store(isLoading, "isLoading");
  	component_subscribe($$self, isLoading, value => $$invalidate(11, $isLoading = value));
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(12, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(15, $authToken = value));
  	validate_store(authError, "authError");
  	component_subscribe($$self, authError, value => $$invalidate(13, $authError = value));
  	validate_store(userInfo, "userInfo");
  	component_subscribe($$self, userInfo, value => $$invalidate(14, $userInfo = value));

  	const create = () => {
  		const createDTO = {
  			name: $store.name,
  			description: $store.description,
  			templateId: $store.selectedTemplate
  		};

  		createNewCharacter($authToken, createDTO, character => console.log("Created character " + character.id), err => console.log(err));
  	};

  	onMount(async () => {
  		document.addEventListener("DOMContentLoaded", function () {
  			var elems = document.querySelectorAll(".modal");
  			var instances = M.Modal.init(elems, {});
  		});

  		getCharacterTemplates(
  			result => {
  				templates.set(result);
  			},
  			err => {
  				console.log(err);
  			}
  		);
  	});

  	const templates = writable([]);
  	validate_store(templates, "templates");
  	component_subscribe($$self, templates, value => $$invalidate(2, $templates = value));
  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<CharacterCreator> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("CharacterCreator", $$slots, []);

  	const func = (character, id) => {
  		store.update(state => {
  			state.templateSelected = true;
  			state.selectedTemplate = id;
  			state.character = character;
  			state.name = character.name;
  			state.description = character.description;
  			return state;
  		});
  	};

  	function input0_input_handler() {
  		$store.name = this.value;
  		store.set($store);
  	}

  	function input1_input_handler() {
  		$store.description = this.value;
  		store.set($store);
  	}

  	$$self.$capture_state = () => ({
  		CharacterTemplate,
  		onMount,
  		writable,
  		createAuth,
  		getAuth,
  		axios: axios$1,
  		onInterval,
  		getCharacterTemplates,
  		createNewCharacter,
  		data,
  		topTen,
  		store,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		authError,
  		userInfo,
  		create,
  		templates,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken,
  		$store,
  		$templates
  	});

  	$$self.$inject_state = $$props => {
  		if ("data" in $$props) data = $$props.data;
  		if ("topTen" in $$props) topTen = $$props.topTen;
  		if ("state" in $$props) $$invalidate(0, state = $$props.state);
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isLoading, $isAuthenticated, $authError, $userInfo, $authToken*/ 63488) {
  			 $$invalidate(0, state = {
  				isLoading: $isLoading,
  				isAuthenticated: $isAuthenticated,
  				authError: $authError,
  				userInfo: $userInfo ? $userInfo.name : null,
  				authToken: $authToken.slice(0, 20)
  			});
  		}
  	};

  	return [
  		state,
  		$store,
  		$templates,
  		store,
  		isLoading,
  		isAuthenticated,
  		authToken,
  		authError,
  		userInfo,
  		create,
  		templates,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken,
  		data,
  		topTen,
  		login,
  		logout,
  		func,
  		input0_input_handler,
  		input1_input_handler
  	];
  }

  class CharacterCreator extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "CharacterCreator",
  			options,
  			id: create_fragment$8.name
  		});
  	}
  }

  var xterm = createCommonjsModule(function (module, exports) {
  !function(e,t){module.exports=t();}(window,(function(){return function(e){var t={};function r(i){if(t[i])return t[i].exports;var n=t[i]={i:i,l:!1,exports:{}};return e[i].call(n.exports,n,n.exports,r),n.l=!0,n.exports}return r.m=e,r.c=t,r.d=function(e,t,i){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i});},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)r.d(i,n,function(t){return e[t]}.bind(null,n));return i},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=33)}([function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.forwardEvent=t.EventEmitter=void 0;var i=function(){function e(){this._listeners=[],this._disposed=!1;}return Object.defineProperty(e.prototype,"event",{get:function(){var e=this;return this._event||(this._event=function(t){return e._listeners.push(t),{dispose:function(){if(!e._disposed)for(var r=0;r<e._listeners.length;r++)if(e._listeners[r]===t)return void e._listeners.splice(r,1)}}}),this._event},enumerable:!1,configurable:!0}),e.prototype.fire=function(e,t){for(var r=[],i=0;i<this._listeners.length;i++)r.push(this._listeners[i]);for(i=0;i<r.length;i++)r[i].call(void 0,e,t);},e.prototype.dispose=function(){this._listeners&&(this._listeners.length=0),this._disposed=!0;},e}();t.EventEmitter=i,t.forwardEvent=function(e,t){return e((function(e){return t.fire(e)}))};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.IUnicodeService=t.IOptionsService=t.ILogService=t.IInstantiationService=t.IDirtyRowService=t.ICharsetService=t.ICoreService=t.ICoreMouseService=t.IBufferService=void 0;var i=r(14);t.IBufferService=i.createDecorator("BufferService"),t.ICoreMouseService=i.createDecorator("CoreMouseService"),t.ICoreService=i.createDecorator("CoreService"),t.ICharsetService=i.createDecorator("CharsetService"),t.IDirtyRowService=i.createDecorator("DirtyRowService"),t.IInstantiationService=i.createDecorator("InstantiationService"),t.ILogService=i.createDecorator("LogService"),t.IOptionsService=i.createDecorator("OptionsService"),t.IUnicodeService=i.createDecorator("UnicodeService");},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.getDisposeArrayDisposable=t.disposeArray=t.Disposable=void 0;var i=function(){function e(){this._disposables=[],this._isDisposed=!1;}return e.prototype.dispose=function(){this._isDisposed=!0,this._disposables.forEach((function(e){return e.dispose()})),this._disposables.length=0;},e.prototype.register=function(e){return this._disposables.push(e),e},e.prototype.unregister=function(e){var t=this._disposables.indexOf(e);-1!==t&&this._disposables.splice(t,1);},e}();function n(e){e.forEach((function(e){return e.dispose()})),e.length=0;}t.Disposable=i,t.disposeArray=n,t.getDisposeArrayDisposable=function(e){return {dispose:function(){return n(e)}}};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.WHITESPACE_CELL_CODE=t.WHITESPACE_CELL_WIDTH=t.WHITESPACE_CELL_CHAR=t.NULL_CELL_CODE=t.NULL_CELL_WIDTH=t.NULL_CELL_CHAR=t.CHAR_DATA_CODE_INDEX=t.CHAR_DATA_WIDTH_INDEX=t.CHAR_DATA_CHAR_INDEX=t.CHAR_DATA_ATTR_INDEX=t.DEFAULT_ATTR=t.DEFAULT_COLOR=void 0,t.DEFAULT_COLOR=256,t.DEFAULT_ATTR=256|t.DEFAULT_COLOR<<9,t.CHAR_DATA_ATTR_INDEX=0,t.CHAR_DATA_CHAR_INDEX=1,t.CHAR_DATA_WIDTH_INDEX=2,t.CHAR_DATA_CODE_INDEX=3,t.NULL_CELL_CHAR="",t.NULL_CELL_WIDTH=1,t.NULL_CELL_CODE=0,t.WHITESPACE_CELL_CHAR=" ",t.WHITESPACE_CELL_WIDTH=1,t.WHITESPACE_CELL_CODE=32;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.CellData=void 0;var o=r(8),s=r(3),a=r(6),c=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.content=0,t.fg=0,t.bg=0,t.extended=new a.ExtendedAttrs,t.combinedData="",t}return n(t,e),t.fromCharData=function(e){var r=new t;return r.setFromCharData(e),r},t.prototype.isCombined=function(){return 2097152&this.content},t.prototype.getWidth=function(){return this.content>>22},t.prototype.getChars=function(){return 2097152&this.content?this.combinedData:2097151&this.content?o.stringFromCodePoint(2097151&this.content):""},t.prototype.getCode=function(){return this.isCombined()?this.combinedData.charCodeAt(this.combinedData.length-1):2097151&this.content},t.prototype.setFromCharData=function(e){this.fg=e[s.CHAR_DATA_ATTR_INDEX],this.bg=0;var t=!1;if(e[s.CHAR_DATA_CHAR_INDEX].length>2)t=!0;else if(2===e[s.CHAR_DATA_CHAR_INDEX].length){var r=e[s.CHAR_DATA_CHAR_INDEX].charCodeAt(0);if(55296<=r&&r<=56319){var i=e[s.CHAR_DATA_CHAR_INDEX].charCodeAt(1);56320<=i&&i<=57343?this.content=1024*(r-55296)+i-56320+65536|e[s.CHAR_DATA_WIDTH_INDEX]<<22:t=!0;}else t=!0;}else this.content=e[s.CHAR_DATA_CHAR_INDEX].charCodeAt(0)|e[s.CHAR_DATA_WIDTH_INDEX]<<22;t&&(this.combinedData=e[s.CHAR_DATA_CHAR_INDEX],this.content=2097152|e[s.CHAR_DATA_WIDTH_INDEX]<<22);},t.prototype.getAsCharData=function(){return [this.fg,this.getChars(),this.getWidth(),this.getCode()]},t}(a.AttributeData);t.CellData=c;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.ISoundService=t.ISelectionService=t.IRenderService=t.IMouseService=t.ICoreBrowserService=t.ICharSizeService=void 0;var i=r(14);t.ICharSizeService=i.createDecorator("CharSizeService"),t.ICoreBrowserService=i.createDecorator("CoreBrowserService"),t.IMouseService=i.createDecorator("MouseService"),t.IRenderService=i.createDecorator("RenderService"),t.ISelectionService=i.createDecorator("SelectionService"),t.ISoundService=i.createDecorator("SoundService");},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.ExtendedAttrs=t.AttributeData=void 0;var i=function(){function e(){this.fg=0,this.bg=0,this.extended=new n;}return e.toColorRGB=function(e){return [e>>>16&255,e>>>8&255,255&e]},e.fromColorRGB=function(e){return (255&e[0])<<16|(255&e[1])<<8|255&e[2]},e.prototype.clone=function(){var t=new e;return t.fg=this.fg,t.bg=this.bg,t.extended=this.extended.clone(),t},e.prototype.isInverse=function(){return 67108864&this.fg},e.prototype.isBold=function(){return 134217728&this.fg},e.prototype.isUnderline=function(){return 268435456&this.fg},e.prototype.isBlink=function(){return 536870912&this.fg},e.prototype.isInvisible=function(){return 1073741824&this.fg},e.prototype.isItalic=function(){return 67108864&this.bg},e.prototype.isDim=function(){return 134217728&this.bg},e.prototype.getFgColorMode=function(){return 50331648&this.fg},e.prototype.getBgColorMode=function(){return 50331648&this.bg},e.prototype.isFgRGB=function(){return 50331648==(50331648&this.fg)},e.prototype.isBgRGB=function(){return 50331648==(50331648&this.bg)},e.prototype.isFgPalette=function(){return 16777216==(50331648&this.fg)||33554432==(50331648&this.fg)},e.prototype.isBgPalette=function(){return 16777216==(50331648&this.bg)||33554432==(50331648&this.bg)},e.prototype.isFgDefault=function(){return 0==(50331648&this.fg)},e.prototype.isBgDefault=function(){return 0==(50331648&this.bg)},e.prototype.isAttributeDefault=function(){return 0===this.fg&&0===this.bg},e.prototype.getFgColor=function(){switch(50331648&this.fg){case 16777216:case 33554432:return 255&this.fg;case 50331648:return 16777215&this.fg;default:return -1}},e.prototype.getBgColor=function(){switch(50331648&this.bg){case 16777216:case 33554432:return 255&this.bg;case 50331648:return 16777215&this.bg;default:return -1}},e.prototype.hasExtendedAttrs=function(){return 268435456&this.bg},e.prototype.updateExtended=function(){this.extended.isEmpty()?this.bg&=-268435457:this.bg|=268435456;},e.prototype.getUnderlineColor=function(){if(268435456&this.bg&&~this.extended.underlineColor)switch(50331648&this.extended.underlineColor){case 16777216:case 33554432:return 255&this.extended.underlineColor;case 50331648:return 16777215&this.extended.underlineColor;default:return this.getFgColor()}return this.getFgColor()},e.prototype.getUnderlineColorMode=function(){return 268435456&this.bg&&~this.extended.underlineColor?50331648&this.extended.underlineColor:this.getFgColorMode()},e.prototype.isUnderlineColorRGB=function(){return 268435456&this.bg&&~this.extended.underlineColor?50331648==(50331648&this.extended.underlineColor):this.isFgRGB()},e.prototype.isUnderlineColorPalette=function(){return 268435456&this.bg&&~this.extended.underlineColor?16777216==(50331648&this.extended.underlineColor)||33554432==(50331648&this.extended.underlineColor):this.isFgPalette()},e.prototype.isUnderlineColorDefault=function(){return 268435456&this.bg&&~this.extended.underlineColor?0==(50331648&this.extended.underlineColor):this.isFgDefault()},e.prototype.getUnderlineStyle=function(){return 268435456&this.fg?268435456&this.bg?this.extended.underlineStyle:1:0},e}();t.AttributeData=i;var n=function(){function e(e,t){void 0===e&&(e=0),void 0===t&&(t=-1),this.underlineStyle=e,this.underlineColor=t;}return e.prototype.clone=function(){return new e(this.underlineStyle,this.underlineColor)},e.prototype.isEmpty=function(){return 0===this.underlineStyle},e}();t.ExtendedAttrs=n;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.addDisposableDomListener=void 0,t.addDisposableDomListener=function(e,t,r,i){e.addEventListener(t,r,i);var n=!1;return {dispose:function(){n||(n=!0,e.removeEventListener(t,r,i));}}};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.Utf8ToUtf32=t.StringToUtf32=t.utf32ToString=t.stringFromCodePoint=void 0,t.stringFromCodePoint=function(e){return e>65535?(e-=65536,String.fromCharCode(55296+(e>>10))+String.fromCharCode(e%1024+56320)):String.fromCharCode(e)},t.utf32ToString=function(e,t,r){void 0===t&&(t=0),void 0===r&&(r=e.length);for(var i="",n=t;n<r;++n){var o=e[n];o>65535?(o-=65536,i+=String.fromCharCode(55296+(o>>10))+String.fromCharCode(o%1024+56320)):i+=String.fromCharCode(o);}return i};var i=function(){function e(){this._interim=0;}return e.prototype.clear=function(){this._interim=0;},e.prototype.decode=function(e,t){var r=e.length;if(!r)return 0;var i=0,n=0;this._interim&&(56320<=(a=e.charCodeAt(n++))&&a<=57343?t[i++]=1024*(this._interim-55296)+a-56320+65536:(t[i++]=this._interim,t[i++]=a),this._interim=0);for(var o=n;o<r;++o){var s=e.charCodeAt(o);if(55296<=s&&s<=56319){if(++o>=r)return this._interim=s,i;var a;56320<=(a=e.charCodeAt(o))&&a<=57343?t[i++]=1024*(s-55296)+a-56320+65536:(t[i++]=s,t[i++]=a);}else t[i++]=s;}return i},e}();t.StringToUtf32=i;var n=function(){function e(){this.interim=new Uint8Array(3);}return e.prototype.clear=function(){this.interim.fill(0);},e.prototype.decode=function(e,t){var r=e.length;if(!r)return 0;var i,n,o,s,a=0,c=0,l=0;if(this.interim[0]){var h=!1,u=this.interim[0];u&=192==(224&u)?31:224==(240&u)?15:7;for(var f=0,_=void 0;(_=63&this.interim[++f])&&f<4;)u<<=6,u|=_;for(var d=192==(224&this.interim[0])?2:224==(240&this.interim[0])?3:4,p=d-f;l<p;){if(l>=r)return 0;if(128!=(192&(_=e[l++]))){l--,h=!0;break}this.interim[f++]=_,u<<=6,u|=63&_;}h||(2===d?u<128?l--:t[a++]=u:3===d?u<2048||u>=55296&&u<=57343||(t[a++]=u):u<65536||u>1114111||(t[a++]=u)),this.interim.fill(0);}for(var v=r-4,g=l;g<r;){for(;!(!(g<v)||128&(i=e[g])||128&(n=e[g+1])||128&(o=e[g+2])||128&(s=e[g+3]));)t[a++]=i,t[a++]=n,t[a++]=o,t[a++]=s,g+=4;if((i=e[g++])<128)t[a++]=i;else if(192==(224&i)){if(g>=r)return this.interim[0]=i,a;if(128!=(192&(n=e[g++]))){g--;continue}if((c=(31&i)<<6|63&n)<128){g--;continue}t[a++]=c;}else if(224==(240&i)){if(g>=r)return this.interim[0]=i,a;if(128!=(192&(n=e[g++]))){g--;continue}if(g>=r)return this.interim[0]=i,this.interim[1]=n,a;if(128!=(192&(o=e[g++]))){g--;continue}if((c=(15&i)<<12|(63&n)<<6|63&o)<2048||c>=55296&&c<=57343)continue;t[a++]=c;}else if(240==(248&i)){if(g>=r)return this.interim[0]=i,a;if(128!=(192&(n=e[g++]))){g--;continue}if(g>=r)return this.interim[0]=i,this.interim[1]=n,a;if(128!=(192&(o=e[g++]))){g--;continue}if(g>=r)return this.interim[0]=i,this.interim[1]=n,this.interim[2]=o,a;if(128!=(192&(s=e[g++]))){g--;continue}if((c=(7&i)<<18|(63&n)<<12|(63&o)<<6|63&s)<65536||c>1114111)continue;t[a++]=c;}}return a},e}();t.Utf8ToUtf32=n;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.CHAR_ATLAS_CELL_SPACING=t.DIM_OPACITY=t.INVERTED_DEFAULT_COLOR=void 0,t.INVERTED_DEFAULT_COLOR=257,t.DIM_OPACITY=.5,t.CHAR_ATLAS_CELL_SPACING=1;},function(e,t,r){var i,n,o,s;function a(e){var t=e.toString(16);return t.length<2?"0"+t:t}function c(e,t){return e<t?(t+.05)/(e+.05):(e+.05)/(t+.05)}Object.defineProperty(t,"__esModule",{value:!0}),t.contrastRatio=t.toPaddedHex=t.rgba=t.rgb=t.css=t.color=t.channels=void 0,function(e){e.toCss=function(e,t,r,i){return void 0!==i?"#"+a(e)+a(t)+a(r)+a(i):"#"+a(e)+a(t)+a(r)},e.toRgba=function(e,t,r,i){return void 0===i&&(i=255),(e<<24|t<<16|r<<8|i)>>>0};}(i=t.channels||(t.channels={})),(n=t.color||(t.color={})).blend=function(e,t){var r=(255&t.rgba)/255;if(1===r)return {css:t.css,rgba:t.rgba};var n=t.rgba>>24&255,o=t.rgba>>16&255,s=t.rgba>>8&255,a=e.rgba>>24&255,c=e.rgba>>16&255,l=e.rgba>>8&255,h=a+Math.round((n-a)*r),u=c+Math.round((o-c)*r),f=l+Math.round((s-l)*r);return {css:i.toCss(h,u,f),rgba:i.toRgba(h,u,f)}},n.ensureContrastRatio=function(e,t,r){var i=s.ensureContrastRatio(e.rgba,t.rgba,r);if(i)return s.toColor(i>>24&255,i>>16&255,i>>8&255)},n.opaque=function(e){var t=(255|e.rgba)>>>0,r=s.toChannels(t),n=r[0],o=r[1],a=r[2];return {css:i.toCss(n,o,a),rgba:t}},(t.css||(t.css={})).toColor=function(e){return {css:e,rgba:(parseInt(e.slice(1),16)<<8|255)>>>0}},function(e){function t(e,t,r){var i=e/255,n=t/255,o=r/255;return .2126*(i<=.03928?i/12.92:Math.pow((i+.055)/1.055,2.4))+.7152*(n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4))+.0722*(o<=.03928?o/12.92:Math.pow((o+.055)/1.055,2.4))}e.relativeLuminance=function(e){return t(e>>16&255,e>>8&255,255&e)},e.relativeLuminance2=t;}(o=t.rgb||(t.rgb={})),function(e){function t(e,t,r){for(var i=e>>24&255,n=e>>16&255,s=e>>8&255,a=t>>24&255,l=t>>16&255,h=t>>8&255,u=c(o.relativeLuminance2(a,h,l),o.relativeLuminance2(i,n,s));u<r&&(a>0||l>0||h>0);)a-=Math.max(0,Math.ceil(.1*a)),l-=Math.max(0,Math.ceil(.1*l)),h-=Math.max(0,Math.ceil(.1*h)),u=c(o.relativeLuminance2(a,h,l),o.relativeLuminance2(i,n,s));return (a<<24|l<<16|h<<8|255)>>>0}function r(e,t,r){for(var i=e>>24&255,n=e>>16&255,s=e>>8&255,a=t>>24&255,l=t>>16&255,h=t>>8&255,u=c(o.relativeLuminance2(a,h,l),o.relativeLuminance2(i,n,s));u<r&&(a<255||l<255||h<255);)a=Math.min(255,a+Math.ceil(.1*(255-a))),l=Math.min(255,l+Math.ceil(.1*(255-l))),h=Math.min(255,h+Math.ceil(.1*(255-h))),u=c(o.relativeLuminance2(a,h,l),o.relativeLuminance2(i,n,s));return (a<<24|l<<16|h<<8|255)>>>0}e.ensureContrastRatio=function(e,i,n){var s=o.relativeLuminance(e>>8),a=o.relativeLuminance(i>>8);if(c(s,a)<n)return a<s?t(e,i,n):r(e,i,n)},e.reduceLuminance=t,e.increaseLuminance=r,e.toChannels=function(e){return [e>>24&255,e>>16&255,e>>8&255,255&e]},e.toColor=function(e,t,r){return {css:i.toCss(e,t,r),rgba:i.toRgba(e,t,r)}};}(s=t.rgba||(t.rgba={})),t.toPaddedHex=a,t.contrastRatio=c;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.isLinux=t.isWindows=t.isIphone=t.isIpad=t.isMac=t.isSafari=t.isFirefox=void 0;var i="undefined"==typeof navigator,n=i?"node":navigator.userAgent,o=i?"node":navigator.platform;function s(e,t){return e.indexOf(t)>=0}t.isFirefox=!!~n.indexOf("Firefox"),t.isSafari=/^((?!chrome|android).)*safari/i.test(n),t.isMac=s(["Macintosh","MacIntel","MacPPC","Mac68K"],o),t.isIpad="iPad"===o,t.isIphone="iPhone"===o,t.isWindows=s(["Windows","Win16","Win32","WinCE"],o),t.isLinux=o.indexOf("Linux")>=0;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.C1=t.C0=void 0,function(e){e.NUL="\0",e.SOH="",e.STX="",e.ETX="",e.EOT="",e.ENQ="",e.ACK="",e.BEL="",e.BS="\b",e.HT="\t",e.LF="\n",e.VT="\v",e.FF="\f",e.CR="\r",e.SO="",e.SI="",e.DLE="",e.DC1="",e.DC2="",e.DC3="",e.DC4="",e.NAK="",e.SYN="",e.ETB="",e.CAN="",e.EM="",e.SUB="",e.ESC="",e.FS="",e.GS="",e.RS="",e.US="",e.SP=" ",e.DEL="";}(t.C0||(t.C0={})),function(e){e.PAD="",e.HOP="",e.BPH="",e.NBH="",e.IND="",e.NEL="",e.SSA="",e.ESA="",e.HTS="",e.HTJ="",e.VTS="",e.PLD="",e.PLU="",e.RI="",e.SS2="",e.SS3="",e.DCS="",e.PU1="",e.PU2="",e.STS="",e.CCH="",e.MW="",e.SPA="",e.EPA="",e.SOS="",e.SGCI="",e.SCI="",e.CSI="",e.ST="",e.OSC="",e.PM="",e.APC="";}(t.C1||(t.C1={}));},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.BaseRenderLayer=void 0;var i=r(3),n=r(9),o=r(24),s=r(6),a=r(27),c=r(10),l=function(){function e(e,t,r,i,n,o,s,a){this._container=e,this._alpha=i,this._colors=n,this._rendererId=o,this._bufferService=s,this._optionsService=a,this._scaledCharWidth=0,this._scaledCharHeight=0,this._scaledCellWidth=0,this._scaledCellHeight=0,this._scaledCharLeft=0,this._scaledCharTop=0,this._currentGlyphIdentifier={chars:"",code:0,bg:0,fg:0,bold:!1,dim:!1,italic:!1},this._canvas=document.createElement("canvas"),this._canvas.classList.add("xterm-"+t+"-layer"),this._canvas.style.zIndex=r.toString(),this._initCanvas(),this._container.appendChild(this._canvas);}return e.prototype.dispose=function(){var e,t;null===(e=this._canvas.parentElement)||void 0===e||e.removeChild(this._canvas),null===(t=this._charAtlas)||void 0===t||t.dispose();},e.prototype._initCanvas=function(){this._ctx=a.throwIfFalsy(this._canvas.getContext("2d",{alpha:this._alpha})),this._alpha||this._clearAll();},e.prototype.onOptionsChanged=function(){},e.prototype.onBlur=function(){},e.prototype.onFocus=function(){},e.prototype.onCursorMove=function(){},e.prototype.onGridChanged=function(e,t){},e.prototype.onSelectionChanged=function(e,t,r){},e.prototype.setColors=function(e){this._refreshCharAtlas(e);},e.prototype._setTransparency=function(e){if(e!==this._alpha){var t=this._canvas;this._alpha=e,this._canvas=this._canvas.cloneNode(),this._initCanvas(),this._container.replaceChild(this._canvas,t),this._refreshCharAtlas(this._colors),this.onGridChanged(0,this._bufferService.rows-1);}},e.prototype._refreshCharAtlas=function(e){this._scaledCharWidth<=0&&this._scaledCharHeight<=0||(this._charAtlas=o.acquireCharAtlas(this._optionsService.options,this._rendererId,e,this._scaledCharWidth,this._scaledCharHeight),this._charAtlas.warmUp());},e.prototype.resize=function(e){this._scaledCellWidth=e.scaledCellWidth,this._scaledCellHeight=e.scaledCellHeight,this._scaledCharWidth=e.scaledCharWidth,this._scaledCharHeight=e.scaledCharHeight,this._scaledCharLeft=e.scaledCharLeft,this._scaledCharTop=e.scaledCharTop,this._canvas.width=e.scaledCanvasWidth,this._canvas.height=e.scaledCanvasHeight,this._canvas.style.width=e.canvasWidth+"px",this._canvas.style.height=e.canvasHeight+"px",this._alpha||this._clearAll(),this._refreshCharAtlas(this._colors);},e.prototype._fillCells=function(e,t,r,i){this._ctx.fillRect(e*this._scaledCellWidth,t*this._scaledCellHeight,r*this._scaledCellWidth,i*this._scaledCellHeight);},e.prototype._fillBottomLineAtCells=function(e,t,r){void 0===r&&(r=1),this._ctx.fillRect(e*this._scaledCellWidth,(t+1)*this._scaledCellHeight-window.devicePixelRatio-1,r*this._scaledCellWidth,window.devicePixelRatio);},e.prototype._fillLeftLineAtCell=function(e,t,r){this._ctx.fillRect(e*this._scaledCellWidth,t*this._scaledCellHeight,window.devicePixelRatio*r,this._scaledCellHeight);},e.prototype._strokeRectAtCell=function(e,t,r,i){this._ctx.lineWidth=window.devicePixelRatio,this._ctx.strokeRect(e*this._scaledCellWidth+window.devicePixelRatio/2,t*this._scaledCellHeight+window.devicePixelRatio/2,r*this._scaledCellWidth-window.devicePixelRatio,i*this._scaledCellHeight-window.devicePixelRatio);},e.prototype._clearAll=function(){this._alpha?this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height):(this._ctx.fillStyle=this._colors.background.css,this._ctx.fillRect(0,0,this._canvas.width,this._canvas.height));},e.prototype._clearCells=function(e,t,r,i){this._alpha?this._ctx.clearRect(e*this._scaledCellWidth,t*this._scaledCellHeight,r*this._scaledCellWidth,i*this._scaledCellHeight):(this._ctx.fillStyle=this._colors.background.css,this._ctx.fillRect(e*this._scaledCellWidth,t*this._scaledCellHeight,r*this._scaledCellWidth,i*this._scaledCellHeight));},e.prototype._fillCharTrueColor=function(e,t,r){this._ctx.font=this._getFont(!1,!1),this._ctx.textBaseline="middle",this._clipRow(r),this._ctx.fillText(e.getChars(),t*this._scaledCellWidth+this._scaledCharLeft,r*this._scaledCellHeight+this._scaledCharTop+this._scaledCharHeight/2);},e.prototype._drawChars=function(e,t,r){var o,s,a=this._getContrastColor(e);a||e.isFgRGB()||e.isBgRGB()?this._drawUncachedChars(e,t,r,a):(e.isInverse()?(o=e.isBgDefault()?n.INVERTED_DEFAULT_COLOR:e.getBgColor(),s=e.isFgDefault()?n.INVERTED_DEFAULT_COLOR:e.getFgColor()):(s=e.isBgDefault()?i.DEFAULT_COLOR:e.getBgColor(),o=e.isFgDefault()?i.DEFAULT_COLOR:e.getFgColor()),o+=this._optionsService.options.drawBoldTextInBrightColors&&e.isBold()&&o<8?8:0,this._currentGlyphIdentifier.chars=e.getChars()||i.WHITESPACE_CELL_CHAR,this._currentGlyphIdentifier.code=e.getCode()||i.WHITESPACE_CELL_CODE,this._currentGlyphIdentifier.bg=s,this._currentGlyphIdentifier.fg=o,this._currentGlyphIdentifier.bold=!!e.isBold(),this._currentGlyphIdentifier.dim=!!e.isDim(),this._currentGlyphIdentifier.italic=!!e.isItalic(),this._charAtlas&&this._charAtlas.draw(this._ctx,this._currentGlyphIdentifier,t*this._scaledCellWidth+this._scaledCharLeft,r*this._scaledCellHeight+this._scaledCharTop)||this._drawUncachedChars(e,t,r));},e.prototype._drawUncachedChars=function(e,t,r,i){if(this._ctx.save(),this._ctx.font=this._getFont(!!e.isBold(),!!e.isItalic()),this._ctx.textBaseline="middle",e.isInverse())if(i)this._ctx.fillStyle=i.css;else if(e.isBgDefault())this._ctx.fillStyle=c.color.opaque(this._colors.background).css;else if(e.isBgRGB())this._ctx.fillStyle="rgb("+s.AttributeData.toColorRGB(e.getBgColor()).join(",")+")";else {var o=e.getBgColor();this._optionsService.options.drawBoldTextInBrightColors&&e.isBold()&&o<8&&(o+=8),this._ctx.fillStyle=this._colors.ansi[o].css;}else if(i)this._ctx.fillStyle=i.css;else if(e.isFgDefault())this._ctx.fillStyle=this._colors.foreground.css;else if(e.isFgRGB())this._ctx.fillStyle="rgb("+s.AttributeData.toColorRGB(e.getFgColor()).join(",")+")";else {var a=e.getFgColor();this._optionsService.options.drawBoldTextInBrightColors&&e.isBold()&&a<8&&(a+=8),this._ctx.fillStyle=this._colors.ansi[a].css;}this._clipRow(r),e.isDim()&&(this._ctx.globalAlpha=n.DIM_OPACITY),this._ctx.fillText(e.getChars(),t*this._scaledCellWidth+this._scaledCharLeft,r*this._scaledCellHeight+this._scaledCharTop+this._scaledCharHeight/2),this._ctx.restore();},e.prototype._clipRow=function(e){this._ctx.beginPath(),this._ctx.rect(0,e*this._scaledCellHeight,this._bufferService.cols*this._scaledCellWidth,this._scaledCellHeight),this._ctx.clip();},e.prototype._getFont=function(e,t){return (t?"italic":"")+" "+(e?this._optionsService.options.fontWeightBold:this._optionsService.options.fontWeight)+" "+this._optionsService.options.fontSize*window.devicePixelRatio+"px "+this._optionsService.options.fontFamily},e.prototype._getContrastColor=function(e){if(1!==this._optionsService.options.minimumContrastRatio){var t=this._colors.contrastCache.getColor(e.bg,e.fg);if(void 0!==t)return t||void 0;var r=e.getFgColor(),i=e.getFgColorMode(),n=e.getBgColor(),o=e.getBgColorMode(),s=!!e.isInverse(),a=!!e.isInverse();if(s){var l=r;r=n,n=l;var h=i;i=o,o=h;}var u=this._resolveBackgroundRgba(o,n,s),f=this._resolveForegroundRgba(i,r,s,a),_=c.rgba.ensureContrastRatio(u,f,this._optionsService.options.minimumContrastRatio);if(_){var d={css:c.channels.toCss(_>>24&255,_>>16&255,_>>8&255),rgba:_};return this._colors.contrastCache.setColor(e.bg,e.fg,d),d}this._colors.contrastCache.setColor(e.bg,e.fg,null);}},e.prototype._resolveBackgroundRgba=function(e,t,r){switch(e){case 16777216:case 33554432:return this._colors.ansi[t].rgba;case 50331648:return t<<8;case 0:default:return r?this._colors.foreground.rgba:this._colors.background.rgba}},e.prototype._resolveForegroundRgba=function(e,t,r,i){switch(e){case 16777216:case 33554432:return this._optionsService.options.drawBoldTextInBrightColors&&i&&t<8&&(t+=8),this._colors.ansi[t].rgba;case 50331648:return t<<8;case 0:default:return r?this._colors.background.rgba:this._colors.foreground.rgba}},e}();t.BaseRenderLayer=l;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.createDecorator=t.getServiceDependencies=t.serviceRegistry=void 0;function i(e,t,r){t.di$target===t?t.di$dependencies.push({id:e,index:r}):(t.di$dependencies=[{id:e,index:r}],t.di$target=t);}t.serviceRegistry=new Map,t.getServiceDependencies=function(e){return e.di$dependencies||[]},t.createDecorator=function(e){if(t.serviceRegistry.has(e))return t.serviceRegistry.get(e);var r=function(e,t,n){if(3!==arguments.length)throw new Error("@IServiceName-decorator can only be used to decorate a parameter");i(r,e,n);};return r.toString=function(){return e},t.serviceRegistry.set(e,r),r};},function(e,t,r){function i(e,t,r,i){if(void 0===r&&(r=0),void 0===i&&(i=e.length),r>=e.length)return e;r=(e.length+r)%e.length,i=i>=e.length?e.length:(e.length+i)%e.length;for(var n=r;n<i;++n)e[n]=t;return e}Object.defineProperty(t,"__esModule",{value:!0}),t.concat=t.fillFallback=t.fill=void 0,t.fill=function(e,t,r,n){return e.fill?e.fill(t,r,n):i(e,t,r,n)},t.fillFallback=i,t.concat=function(e,t){var r=new e.constructor(e.length+t.length);return r.set(e),r.set(t,e.length),r};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.BufferLine=t.DEFAULT_ATTR_DATA=void 0;var i=r(8),n=r(3),o=r(4),s=r(6);t.DEFAULT_ATTR_DATA=Object.freeze(new s.AttributeData);var a=function(){function e(e,t,r){void 0===r&&(r=!1),this.isWrapped=r,this._combined={},this._extendedAttrs={},this._data=new Uint32Array(3*e);for(var i=t||o.CellData.fromCharData([0,n.NULL_CELL_CHAR,n.NULL_CELL_WIDTH,n.NULL_CELL_CODE]),s=0;s<e;++s)this.setCell(s,i);this.length=e;}return e.prototype.get=function(e){var t=this._data[3*e+0],r=2097151&t;return [this._data[3*e+1],2097152&t?this._combined[e]:r?i.stringFromCodePoint(r):"",t>>22,2097152&t?this._combined[e].charCodeAt(this._combined[e].length-1):r]},e.prototype.set=function(e,t){this._data[3*e+1]=t[n.CHAR_DATA_ATTR_INDEX],t[n.CHAR_DATA_CHAR_INDEX].length>1?(this._combined[e]=t[1],this._data[3*e+0]=2097152|e|t[n.CHAR_DATA_WIDTH_INDEX]<<22):this._data[3*e+0]=t[n.CHAR_DATA_CHAR_INDEX].charCodeAt(0)|t[n.CHAR_DATA_WIDTH_INDEX]<<22;},e.prototype.getWidth=function(e){return this._data[3*e+0]>>22},e.prototype.hasWidth=function(e){return 12582912&this._data[3*e+0]},e.prototype.getFg=function(e){return this._data[3*e+1]},e.prototype.getBg=function(e){return this._data[3*e+2]},e.prototype.hasContent=function(e){return 4194303&this._data[3*e+0]},e.prototype.getCodePoint=function(e){var t=this._data[3*e+0];return 2097152&t?this._combined[e].charCodeAt(this._combined[e].length-1):2097151&t},e.prototype.isCombined=function(e){return 2097152&this._data[3*e+0]},e.prototype.getString=function(e){var t=this._data[3*e+0];return 2097152&t?this._combined[e]:2097151&t?i.stringFromCodePoint(2097151&t):""},e.prototype.loadCell=function(e,t){var r=3*e;return t.content=this._data[r+0],t.fg=this._data[r+1],t.bg=this._data[r+2],2097152&t.content&&(t.combinedData=this._combined[e]),268435456&t.bg&&(t.extended=this._extendedAttrs[e]),t},e.prototype.setCell=function(e,t){2097152&t.content&&(this._combined[e]=t.combinedData),268435456&t.bg&&(this._extendedAttrs[e]=t.extended),this._data[3*e+0]=t.content,this._data[3*e+1]=t.fg,this._data[3*e+2]=t.bg;},e.prototype.setCellFromCodePoint=function(e,t,r,i,n,o){268435456&n&&(this._extendedAttrs[e]=o),this._data[3*e+0]=t|r<<22,this._data[3*e+1]=i,this._data[3*e+2]=n;},e.prototype.addCodepointToCell=function(e,t){var r=this._data[3*e+0];2097152&r?this._combined[e]+=i.stringFromCodePoint(t):(2097151&r?(this._combined[e]=i.stringFromCodePoint(2097151&r)+i.stringFromCodePoint(t),r&=-2097152,r|=2097152):r=t|1<<22,this._data[3*e+0]=r);},e.prototype.insertCells=function(e,t,r,i){if((e%=this.length)&&2===this.getWidth(e-1)&&this.setCellFromCodePoint(e-1,0,1,(null==i?void 0:i.fg)||0,(null==i?void 0:i.bg)||0,(null==i?void 0:i.extended)||new s.ExtendedAttrs),t<this.length-e){for(var n=new o.CellData,a=this.length-e-t-1;a>=0;--a)this.setCell(e+t+a,this.loadCell(e+a,n));for(a=0;a<t;++a)this.setCell(e+a,r);}else for(a=e;a<this.length;++a)this.setCell(a,r);2===this.getWidth(this.length-1)&&this.setCellFromCodePoint(this.length-1,0,1,(null==i?void 0:i.fg)||0,(null==i?void 0:i.bg)||0,(null==i?void 0:i.extended)||new s.ExtendedAttrs);},e.prototype.deleteCells=function(e,t,r,i){if(e%=this.length,t<this.length-e){for(var n=new o.CellData,a=0;a<this.length-e-t;++a)this.setCell(e+a,this.loadCell(e+t+a,n));for(a=this.length-t;a<this.length;++a)this.setCell(a,r);}else for(a=e;a<this.length;++a)this.setCell(a,r);e&&2===this.getWidth(e-1)&&this.setCellFromCodePoint(e-1,0,1,(null==i?void 0:i.fg)||0,(null==i?void 0:i.bg)||0,(null==i?void 0:i.extended)||new s.ExtendedAttrs),0!==this.getWidth(e)||this.hasContent(e)||this.setCellFromCodePoint(e,0,1,(null==i?void 0:i.fg)||0,(null==i?void 0:i.bg)||0,(null==i?void 0:i.extended)||new s.ExtendedAttrs);},e.prototype.replaceCells=function(e,t,r,i){for(e&&2===this.getWidth(e-1)&&this.setCellFromCodePoint(e-1,0,1,(null==i?void 0:i.fg)||0,(null==i?void 0:i.bg)||0,(null==i?void 0:i.extended)||new s.ExtendedAttrs),t<this.length&&2===this.getWidth(t-1)&&this.setCellFromCodePoint(t,0,1,(null==i?void 0:i.fg)||0,(null==i?void 0:i.bg)||0,(null==i?void 0:i.extended)||new s.ExtendedAttrs);e<t&&e<this.length;)this.setCell(e++,r);},e.prototype.resize=function(e,t){if(e!==this.length){if(e>this.length){var r=new Uint32Array(3*e);this.length&&(3*e<this._data.length?r.set(this._data.subarray(0,3*e)):r.set(this._data)),this._data=r;for(var i=this.length;i<e;++i)this.setCell(i,t);}else if(e){(r=new Uint32Array(3*e)).set(this._data.subarray(0,3*e)),this._data=r;var n=Object.keys(this._combined);for(i=0;i<n.length;i++){var o=parseInt(n[i],10);o>=e&&delete this._combined[o];}}else this._data=new Uint32Array(0),this._combined={};this.length=e;}},e.prototype.fill=function(e){this._combined={},this._extendedAttrs={};for(var t=0;t<this.length;++t)this.setCell(t,e);},e.prototype.copyFrom=function(e){for(var t in this.length!==e.length?this._data=new Uint32Array(e._data):this._data.set(e._data),this.length=e.length,this._combined={},e._combined)this._combined[t]=e._combined[t];for(var t in this._extendedAttrs={},e._extendedAttrs)this._extendedAttrs[t]=e._extendedAttrs[t];this.isWrapped=e.isWrapped;},e.prototype.clone=function(){var t=new e(0);for(var r in t._data=new Uint32Array(this._data),t.length=this.length,this._combined)t._combined[r]=this._combined[r];for(var r in this._extendedAttrs)t._extendedAttrs[r]=this._extendedAttrs[r];return t.isWrapped=this.isWrapped,t},e.prototype.getTrimmedLength=function(){for(var e=this.length-1;e>=0;--e)if(4194303&this._data[3*e+0])return e+(this._data[3*e+0]>>22);return 0},e.prototype.copyCellsFrom=function(e,t,r,i,n){var o=e._data;if(n)for(var s=i-1;s>=0;s--)for(var a=0;a<3;a++)this._data[3*(r+s)+a]=o[3*(t+s)+a];else for(s=0;s<i;s++)for(a=0;a<3;a++)this._data[3*(r+s)+a]=o[3*(t+s)+a];var c=Object.keys(e._combined);for(a=0;a<c.length;a++){var l=parseInt(c[a],10);l>=t&&(this._combined[l-t+r]=e._combined[l]);}},e.prototype.translateToString=function(e,t,r){void 0===e&&(e=!1),void 0===t&&(t=0),void 0===r&&(r=this.length),e&&(r=Math.min(r,this.getTrimmedLength()));for(var o="";t<r;){var s=this._data[3*t+0],a=2097151&s;o+=2097152&s?this._combined[t]:a?i.stringFromCodePoint(a):n.WHITESPACE_CELL_CHAR,t+=s>>22||1;}return o},e}();t.BufferLine=a;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.tooMuchOutput=t.promptLabel=void 0,t.promptLabel="Terminal input",t.tooMuchOutput="Too much output to announce, navigate to rows manually to read";},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.InputHandler=t.WindowsOptionsReportType=void 0;var o,s=r(12),a=r(19),c=r(38),l=r(2),h=r(15),u=r(8),f=r(16),_=r(0),d=r(3),p=r(4),v=r(6),g=r(21),y=r(23),b={"(":0,")":1,"*":2,"+":3,"-":1,".":2};function S(e,t){if(e>24)return t.setWinLines||!1;switch(e){case 1:return !!t.restoreWin;case 2:return !!t.minimizeWin;case 3:return !!t.setWinPosition;case 4:return !!t.setWinSizePixels;case 5:return !!t.raiseWin;case 6:return !!t.lowerWin;case 7:return !!t.refreshWin;case 8:return !!t.setWinSizeChars;case 9:return !!t.maximizeWin;case 10:return !!t.fullscreenWin;case 11:return !!t.getWinState;case 13:return !!t.getWinPosition;case 14:return !!t.getWinSizePixels;case 15:return !!t.getScreenSizePixels;case 16:return !!t.getCellSizePixels;case 18:return !!t.getWinSizeChars;case 19:return !!t.getScreenSizeChars;case 20:return !!t.getIconTitle;case 21:return !!t.getWinTitle;case 22:return !!t.pushTitle;case 23:return !!t.popTitle;case 24:return !!t.setWinLines}return !1}!function(e){e[e.GET_WIN_SIZE_PIXELS=0]="GET_WIN_SIZE_PIXELS",e[e.GET_CELL_SIZE_PIXELS=1]="GET_CELL_SIZE_PIXELS";}(o=t.WindowsOptionsReportType||(t.WindowsOptionsReportType={}));var m=function(){function e(e,t,r,i){this._bufferService=e,this._coreService=t,this._logService=r,this._optionsService=i,this._data=new Uint32Array(0);}return e.prototype.hook=function(e){this._data=new Uint32Array(0);},e.prototype.put=function(e,t,r){this._data=h.concat(this._data,e.subarray(t,r));},e.prototype.unhook=function(e){if(e){var t=u.utf32ToString(this._data);switch(this._data=new Uint32Array(0),t){case'"q':return this._coreService.triggerDataEvent(s.C0.ESC+'P1$r0"q'+s.C0.ESC+"\\");case'"p':return this._coreService.triggerDataEvent(s.C0.ESC+'P1$r61;1"p'+s.C0.ESC+"\\");case"r":var r=this._bufferService.buffer.scrollTop+1+";"+(this._bufferService.buffer.scrollBottom+1)+"r";return this._coreService.triggerDataEvent(s.C0.ESC+"P1$r"+r+s.C0.ESC+"\\");case"m":return this._coreService.triggerDataEvent(s.C0.ESC+"P1$r0m"+s.C0.ESC+"\\");case" q":var i={block:2,underline:4,bar:6}[this._optionsService.options.cursorStyle];return i-=this._optionsService.options.cursorBlink?1:0,this._coreService.triggerDataEvent(s.C0.ESC+"P1$r"+i+" q"+s.C0.ESC+"\\");default:this._logService.debug("Unknown DCS $q %s",t),this._coreService.triggerDataEvent(s.C0.ESC+"P0$r"+s.C0.ESC+"\\");}}else this._data=new Uint32Array(0);},e}(),C=function(e){function t(t,r,i,n,o,l,h,d,v){void 0===v&&(v=new c.EscapeSequenceParser);var y=e.call(this)||this;y._bufferService=t,y._charsetService=r,y._coreService=i,y._dirtyRowService=n,y._logService=o,y._optionsService=l,y._coreMouseService=h,y._unicodeService=d,y._parser=v,y._parseBuffer=new Uint32Array(4096),y._stringDecoder=new u.StringToUtf32,y._utf8Decoder=new u.Utf8ToUtf32,y._workCell=new p.CellData,y._windowTitle="",y._iconName="",y._windowTitleStack=[],y._iconNameStack=[],y._curAttrData=f.DEFAULT_ATTR_DATA.clone(),y._eraseAttrDataInternal=f.DEFAULT_ATTR_DATA.clone(),y._onRequestBell=new _.EventEmitter,y._onRequestRefreshRows=new _.EventEmitter,y._onRequestReset=new _.EventEmitter,y._onRequestScroll=new _.EventEmitter,y._onRequestSyncScrollBar=new _.EventEmitter,y._onRequestWindowsOptionsReport=new _.EventEmitter,y._onA11yChar=new _.EventEmitter,y._onA11yTab=new _.EventEmitter,y._onCursorMove=new _.EventEmitter,y._onLineFeed=new _.EventEmitter,y._onScroll=new _.EventEmitter,y._onTitleChange=new _.EventEmitter,y.register(y._parser),y._parser.setCsiHandlerFallback((function(e,t){y._logService.debug("Unknown CSI code: ",{identifier:y._parser.identToString(e),params:t.toArray()});})),y._parser.setEscHandlerFallback((function(e){y._logService.debug("Unknown ESC code: ",{identifier:y._parser.identToString(e)});})),y._parser.setExecuteHandlerFallback((function(e){y._logService.debug("Unknown EXECUTE code: ",{code:e});})),y._parser.setOscHandlerFallback((function(e,t,r){y._logService.debug("Unknown OSC code: ",{identifier:e,action:t,data:r});})),y._parser.setDcsHandlerFallback((function(e,t,r){"HOOK"===t&&(r=r.toArray()),y._logService.debug("Unknown DCS code: ",{identifier:y._parser.identToString(e),action:t,payload:r});})),y._parser.setPrintHandler((function(e,t,r){return y.print(e,t,r)})),y._parser.setCsiHandler({final:"@"},(function(e){return y.insertChars(e)})),y._parser.setCsiHandler({intermediates:" ",final:"@"},(function(e){return y.scrollLeft(e)})),y._parser.setCsiHandler({final:"A"},(function(e){return y.cursorUp(e)})),y._parser.setCsiHandler({intermediates:" ",final:"A"},(function(e){return y.scrollRight(e)})),y._parser.setCsiHandler({final:"B"},(function(e){return y.cursorDown(e)})),y._parser.setCsiHandler({final:"C"},(function(e){return y.cursorForward(e)})),y._parser.setCsiHandler({final:"D"},(function(e){return y.cursorBackward(e)})),y._parser.setCsiHandler({final:"E"},(function(e){return y.cursorNextLine(e)})),y._parser.setCsiHandler({final:"F"},(function(e){return y.cursorPrecedingLine(e)})),y._parser.setCsiHandler({final:"G"},(function(e){return y.cursorCharAbsolute(e)})),y._parser.setCsiHandler({final:"H"},(function(e){return y.cursorPosition(e)})),y._parser.setCsiHandler({final:"I"},(function(e){return y.cursorForwardTab(e)})),y._parser.setCsiHandler({final:"J"},(function(e){return y.eraseInDisplay(e)})),y._parser.setCsiHandler({prefix:"?",final:"J"},(function(e){return y.eraseInDisplay(e)})),y._parser.setCsiHandler({final:"K"},(function(e){return y.eraseInLine(e)})),y._parser.setCsiHandler({prefix:"?",final:"K"},(function(e){return y.eraseInLine(e)})),y._parser.setCsiHandler({final:"L"},(function(e){return y.insertLines(e)})),y._parser.setCsiHandler({final:"M"},(function(e){return y.deleteLines(e)})),y._parser.setCsiHandler({final:"P"},(function(e){return y.deleteChars(e)})),y._parser.setCsiHandler({final:"S"},(function(e){return y.scrollUp(e)})),y._parser.setCsiHandler({final:"T"},(function(e){return y.scrollDown(e)})),y._parser.setCsiHandler({final:"X"},(function(e){return y.eraseChars(e)})),y._parser.setCsiHandler({final:"Z"},(function(e){return y.cursorBackwardTab(e)})),y._parser.setCsiHandler({final:"`"},(function(e){return y.charPosAbsolute(e)})),y._parser.setCsiHandler({final:"a"},(function(e){return y.hPositionRelative(e)})),y._parser.setCsiHandler({final:"b"},(function(e){return y.repeatPrecedingCharacter(e)})),y._parser.setCsiHandler({final:"c"},(function(e){return y.sendDeviceAttributesPrimary(e)})),y._parser.setCsiHandler({prefix:">",final:"c"},(function(e){return y.sendDeviceAttributesSecondary(e)})),y._parser.setCsiHandler({final:"d"},(function(e){return y.linePosAbsolute(e)})),y._parser.setCsiHandler({final:"e"},(function(e){return y.vPositionRelative(e)})),y._parser.setCsiHandler({final:"f"},(function(e){return y.hVPosition(e)})),y._parser.setCsiHandler({final:"g"},(function(e){return y.tabClear(e)})),y._parser.setCsiHandler({final:"h"},(function(e){return y.setMode(e)})),y._parser.setCsiHandler({prefix:"?",final:"h"},(function(e){return y.setModePrivate(e)})),y._parser.setCsiHandler({final:"l"},(function(e){return y.resetMode(e)})),y._parser.setCsiHandler({prefix:"?",final:"l"},(function(e){return y.resetModePrivate(e)})),y._parser.setCsiHandler({final:"m"},(function(e){return y.charAttributes(e)})),y._parser.setCsiHandler({final:"n"},(function(e){return y.deviceStatus(e)})),y._parser.setCsiHandler({prefix:"?",final:"n"},(function(e){return y.deviceStatusPrivate(e)})),y._parser.setCsiHandler({intermediates:"!",final:"p"},(function(e){return y.softReset(e)})),y._parser.setCsiHandler({intermediates:" ",final:"q"},(function(e){return y.setCursorStyle(e)})),y._parser.setCsiHandler({final:"r"},(function(e){return y.setScrollRegion(e)})),y._parser.setCsiHandler({final:"s"},(function(e){return y.saveCursor(e)})),y._parser.setCsiHandler({final:"t"},(function(e){return y.windowOptions(e)})),y._parser.setCsiHandler({final:"u"},(function(e){return y.restoreCursor(e)})),y._parser.setCsiHandler({intermediates:"'",final:"}"},(function(e){return y.insertColumns(e)})),y._parser.setCsiHandler({intermediates:"'",final:"~"},(function(e){return y.deleteColumns(e)})),y._parser.setExecuteHandler(s.C0.BEL,(function(){return y.bell()})),y._parser.setExecuteHandler(s.C0.LF,(function(){return y.lineFeed()})),y._parser.setExecuteHandler(s.C0.VT,(function(){return y.lineFeed()})),y._parser.setExecuteHandler(s.C0.FF,(function(){return y.lineFeed()})),y._parser.setExecuteHandler(s.C0.CR,(function(){return y.carriageReturn()})),y._parser.setExecuteHandler(s.C0.BS,(function(){return y.backspace()})),y._parser.setExecuteHandler(s.C0.HT,(function(){return y.tab()})),y._parser.setExecuteHandler(s.C0.SO,(function(){return y.shiftOut()})),y._parser.setExecuteHandler(s.C0.SI,(function(){return y.shiftIn()})),y._parser.setExecuteHandler(s.C1.IND,(function(){return y.index()})),y._parser.setExecuteHandler(s.C1.NEL,(function(){return y.nextLine()})),y._parser.setExecuteHandler(s.C1.HTS,(function(){return y.tabSet()})),y._parser.setOscHandler(0,new g.OscHandler((function(e){y.setTitle(e),y.setIconName(e);}))),y._parser.setOscHandler(1,new g.OscHandler((function(e){return y.setIconName(e)}))),y._parser.setOscHandler(2,new g.OscHandler((function(e){return y.setTitle(e)}))),y._parser.setEscHandler({final:"7"},(function(){return y.saveCursor()})),y._parser.setEscHandler({final:"8"},(function(){return y.restoreCursor()})),y._parser.setEscHandler({final:"D"},(function(){return y.index()})),y._parser.setEscHandler({final:"E"},(function(){return y.nextLine()})),y._parser.setEscHandler({final:"H"},(function(){return y.tabSet()})),y._parser.setEscHandler({final:"M"},(function(){return y.reverseIndex()})),y._parser.setEscHandler({final:"="},(function(){return y.keypadApplicationMode()})),y._parser.setEscHandler({final:">"},(function(){return y.keypadNumericMode()})),y._parser.setEscHandler({final:"c"},(function(){return y.fullReset()})),y._parser.setEscHandler({final:"n"},(function(){return y.setgLevel(2)})),y._parser.setEscHandler({final:"o"},(function(){return y.setgLevel(3)})),y._parser.setEscHandler({final:"|"},(function(){return y.setgLevel(3)})),y._parser.setEscHandler({final:"}"},(function(){return y.setgLevel(2)})),y._parser.setEscHandler({final:"~"},(function(){return y.setgLevel(1)})),y._parser.setEscHandler({intermediates:"%",final:"@"},(function(){return y.selectDefaultCharset()})),y._parser.setEscHandler({intermediates:"%",final:"G"},(function(){return y.selectDefaultCharset()}));var b=function(e){S._parser.setEscHandler({intermediates:"(",final:e},(function(){return y.selectCharset("("+e)})),S._parser.setEscHandler({intermediates:")",final:e},(function(){return y.selectCharset(")"+e)})),S._parser.setEscHandler({intermediates:"*",final:e},(function(){return y.selectCharset("*"+e)})),S._parser.setEscHandler({intermediates:"+",final:e},(function(){return y.selectCharset("+"+e)})),S._parser.setEscHandler({intermediates:"-",final:e},(function(){return y.selectCharset("-"+e)})),S._parser.setEscHandler({intermediates:".",final:e},(function(){return y.selectCharset("."+e)})),S._parser.setEscHandler({intermediates:"/",final:e},(function(){return y.selectCharset("/"+e)}));},S=this;for(var C in a.CHARSETS)b(C);return y._parser.setEscHandler({intermediates:"#",final:"8"},(function(){return y.screenAlignmentPattern()})),y._parser.setErrorHandler((function(e){return y._logService.error("Parsing error: ",e),e})),y._parser.setDcsHandler({intermediates:"$",final:"q"},new m(y._bufferService,y._coreService,y._logService,y._optionsService)),y}return n(t,e),Object.defineProperty(t.prototype,"onRequestBell",{get:function(){return this._onRequestBell.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRequestRefreshRows",{get:function(){return this._onRequestRefreshRows.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRequestReset",{get:function(){return this._onRequestReset.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRequestScroll",{get:function(){return this._onRequestScroll.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRequestSyncScrollBar",{get:function(){return this._onRequestSyncScrollBar.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRequestWindowsOptionsReport",{get:function(){return this._onRequestWindowsOptionsReport.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onA11yChar",{get:function(){return this._onA11yChar.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onA11yTab",{get:function(){return this._onA11yTab.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onCursorMove",{get:function(){return this._onCursorMove.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onLineFeed",{get:function(){return this._onLineFeed.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onScroll",{get:function(){return this._onScroll.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onTitleChange",{get:function(){return this._onTitleChange.event},enumerable:!1,configurable:!0}),t.prototype.dispose=function(){e.prototype.dispose.call(this);},t.prototype.parse=function(e){var t=this._bufferService.buffer,r=t.x,i=t.y;if(this._logService.debug("parsing data",e),this._parseBuffer.length<e.length&&this._parseBuffer.length<131072&&(this._parseBuffer=new Uint32Array(Math.min(e.length,131072))),this._dirtyRowService.clearRange(),e.length>131072)for(var n=0;n<e.length;n+=131072){var o=n+131072<e.length?n+131072:e.length,s="string"==typeof e?this._stringDecoder.decode(e.substring(n,o),this._parseBuffer):this._utf8Decoder.decode(e.subarray(n,o),this._parseBuffer);this._parser.parse(this._parseBuffer,s);}else {s="string"==typeof e?this._stringDecoder.decode(e,this._parseBuffer):this._utf8Decoder.decode(e,this._parseBuffer);this._parser.parse(this._parseBuffer,s);}(t=this._bufferService.buffer).x===r&&t.y===i||this._onCursorMove.fire(),this._onRequestRefreshRows.fire(this._dirtyRowService.start,this._dirtyRowService.end);},t.prototype.print=function(e,t,r){var i,n,o=this._bufferService.buffer,s=this._charsetService.charset,a=this._optionsService.options.screenReaderMode,c=this._bufferService.cols,l=this._coreService.decPrivateModes.wraparound,h=this._coreService.modes.insertMode,f=this._curAttrData,_=o.lines.get(o.ybase+o.y);this._dirtyRowService.markDirty(o.y),o.x&&r-t>0&&2===_.getWidth(o.x-1)&&_.setCellFromCodePoint(o.x-1,0,1,f.fg,f.bg,f.extended);for(var p=t;p<r;++p){if(i=e[p],n=this._unicodeService.wcwidth(i),i<127&&s){var v=s[String.fromCharCode(i)];v&&(i=v.charCodeAt(0));}if(a&&this._onA11yChar.fire(u.stringFromCodePoint(i)),n||!o.x){if(o.x+n-1>=c)if(l){for(;o.x<c;)_.setCellFromCodePoint(o.x++,0,1,f.fg,f.bg,f.extended);o.x=0,o.y++,o.y===o.scrollBottom+1?(o.y--,this._onRequestScroll.fire(this._eraseAttrData(),!0)):(o.y>=this._bufferService.rows&&(o.y=this._bufferService.rows-1),o.lines.get(o.ybase+o.y).isWrapped=!0),_=o.lines.get(o.ybase+o.y);}else if(o.x=c-1,2===n)continue;if(h&&(_.insertCells(o.x,n,o.getNullCell(f),f),2===_.getWidth(c-1)&&_.setCellFromCodePoint(c-1,d.NULL_CELL_CODE,d.NULL_CELL_WIDTH,f.fg,f.bg,f.extended)),_.setCellFromCodePoint(o.x++,i,n,f.fg,f.bg,f.extended),n>0)for(;--n;)_.setCellFromCodePoint(o.x++,0,0,f.fg,f.bg,f.extended);}else _.getWidth(o.x-1)?_.addCodepointToCell(o.x-1,i):_.addCodepointToCell(o.x-2,i);}r-t>0&&(_.loadCell(o.x-1,this._workCell),2===this._workCell.getWidth()||this._workCell.getCode()>65535?this._parser.precedingCodepoint=0:this._workCell.isCombined()?this._parser.precedingCodepoint=this._workCell.getChars().charCodeAt(0):this._parser.precedingCodepoint=this._workCell.content),o.x<c&&r-t>0&&0===_.getWidth(o.x)&&!_.hasContent(o.x)&&_.setCellFromCodePoint(o.x,0,1,f.fg,f.bg,f.extended),this._dirtyRowService.markDirty(o.y);},t.prototype.addCsiHandler=function(e,t){var r=this;return "t"!==e.final||e.prefix||e.intermediates?this._parser.addCsiHandler(e,t):this._parser.addCsiHandler(e,(function(e){return !S(e.params[0],r._optionsService.options.windowOptions)||t(e)}))},t.prototype.addDcsHandler=function(e,t){return this._parser.addDcsHandler(e,new y.DcsHandler(t))},t.prototype.addEscHandler=function(e,t){return this._parser.addEscHandler(e,t)},t.prototype.addOscHandler=function(e,t){return this._parser.addOscHandler(e,new g.OscHandler(t))},t.prototype.bell=function(){this._onRequestBell.fire();},t.prototype.lineFeed=function(){var e=this._bufferService.buffer;this._dirtyRowService.markDirty(e.y),this._optionsService.options.convertEol&&(e.x=0),e.y++,e.y===e.scrollBottom+1?(e.y--,this._onRequestScroll.fire(this._eraseAttrData())):e.y>=this._bufferService.rows&&(e.y=this._bufferService.rows-1),e.x>=this._bufferService.cols&&e.x--,this._dirtyRowService.markDirty(e.y),this._onLineFeed.fire();},t.prototype.carriageReturn=function(){this._bufferService.buffer.x=0;},t.prototype.backspace=function(){var e,t=this._bufferService.buffer;if(!this._coreService.decPrivateModes.reverseWraparound)return this._restrictCursor(),void(t.x>0&&t.x--);if(this._restrictCursor(this._bufferService.cols),t.x>0)t.x--;else if(0===t.x&&t.y>t.scrollTop&&t.y<=t.scrollBottom&&(null===(e=t.lines.get(t.ybase+t.y))||void 0===e?void 0:e.isWrapped)){t.lines.get(t.ybase+t.y).isWrapped=!1,t.y--,t.x=this._bufferService.cols-1;var r=t.lines.get(t.ybase+t.y);r.hasWidth(t.x)&&!r.hasContent(t.x)&&t.x--;}this._restrictCursor();},t.prototype.tab=function(){if(!(this._bufferService.buffer.x>=this._bufferService.cols)){var e=this._bufferService.buffer.x;this._bufferService.buffer.x=this._bufferService.buffer.nextStop(),this._optionsService.options.screenReaderMode&&this._onA11yTab.fire(this._bufferService.buffer.x-e);}},t.prototype.shiftOut=function(){this._charsetService.setgLevel(1);},t.prototype.shiftIn=function(){this._charsetService.setgLevel(0);},t.prototype._restrictCursor=function(e){void 0===e&&(e=this._bufferService.cols-1),this._bufferService.buffer.x=Math.min(e,Math.max(0,this._bufferService.buffer.x)),this._bufferService.buffer.y=this._coreService.decPrivateModes.origin?Math.min(this._bufferService.buffer.scrollBottom,Math.max(this._bufferService.buffer.scrollTop,this._bufferService.buffer.y)):Math.min(this._bufferService.rows-1,Math.max(0,this._bufferService.buffer.y)),this._dirtyRowService.markDirty(this._bufferService.buffer.y);},t.prototype._setCursor=function(e,t){this._dirtyRowService.markDirty(this._bufferService.buffer.y),this._coreService.decPrivateModes.origin?(this._bufferService.buffer.x=e,this._bufferService.buffer.y=this._bufferService.buffer.scrollTop+t):(this._bufferService.buffer.x=e,this._bufferService.buffer.y=t),this._restrictCursor(),this._dirtyRowService.markDirty(this._bufferService.buffer.y);},t.prototype._moveCursor=function(e,t){this._restrictCursor(),this._setCursor(this._bufferService.buffer.x+e,this._bufferService.buffer.y+t);},t.prototype.cursorUp=function(e){var t=this._bufferService.buffer.y-this._bufferService.buffer.scrollTop;t>=0?this._moveCursor(0,-Math.min(t,e.params[0]||1)):this._moveCursor(0,-(e.params[0]||1));},t.prototype.cursorDown=function(e){var t=this._bufferService.buffer.scrollBottom-this._bufferService.buffer.y;t>=0?this._moveCursor(0,Math.min(t,e.params[0]||1)):this._moveCursor(0,e.params[0]||1);},t.prototype.cursorForward=function(e){this._moveCursor(e.params[0]||1,0);},t.prototype.cursorBackward=function(e){this._moveCursor(-(e.params[0]||1),0);},t.prototype.cursorNextLine=function(e){this.cursorDown(e),this._bufferService.buffer.x=0;},t.prototype.cursorPrecedingLine=function(e){this.cursorUp(e),this._bufferService.buffer.x=0;},t.prototype.cursorCharAbsolute=function(e){this._setCursor((e.params[0]||1)-1,this._bufferService.buffer.y);},t.prototype.cursorPosition=function(e){this._setCursor(e.length>=2?(e.params[1]||1)-1:0,(e.params[0]||1)-1);},t.prototype.charPosAbsolute=function(e){this._setCursor((e.params[0]||1)-1,this._bufferService.buffer.y);},t.prototype.hPositionRelative=function(e){this._moveCursor(e.params[0]||1,0);},t.prototype.linePosAbsolute=function(e){this._setCursor(this._bufferService.buffer.x,(e.params[0]||1)-1);},t.prototype.vPositionRelative=function(e){this._moveCursor(0,e.params[0]||1);},t.prototype.hVPosition=function(e){this.cursorPosition(e);},t.prototype.tabClear=function(e){var t=e.params[0];0===t?delete this._bufferService.buffer.tabs[this._bufferService.buffer.x]:3===t&&(this._bufferService.buffer.tabs={});},t.prototype.cursorForwardTab=function(e){if(!(this._bufferService.buffer.x>=this._bufferService.cols))for(var t=e.params[0]||1;t--;)this._bufferService.buffer.x=this._bufferService.buffer.nextStop();},t.prototype.cursorBackwardTab=function(e){if(!(this._bufferService.buffer.x>=this._bufferService.cols))for(var t=e.params[0]||1,r=this._bufferService.buffer;t--;)r.x=r.prevStop();},t.prototype._eraseInBufferLine=function(e,t,r,i){void 0===i&&(i=!1);var n=this._bufferService.buffer.lines.get(this._bufferService.buffer.ybase+e);n.replaceCells(t,r,this._bufferService.buffer.getNullCell(this._eraseAttrData()),this._eraseAttrData()),i&&(n.isWrapped=!1);},t.prototype._resetBufferLine=function(e){var t=this._bufferService.buffer.lines.get(this._bufferService.buffer.ybase+e);t.fill(this._bufferService.buffer.getNullCell(this._eraseAttrData())),t.isWrapped=!1;},t.prototype.eraseInDisplay=function(e){var t;switch(this._restrictCursor(),e.params[0]){case 0:for(t=this._bufferService.buffer.y,this._dirtyRowService.markDirty(t),this._eraseInBufferLine(t++,this._bufferService.buffer.x,this._bufferService.cols,0===this._bufferService.buffer.x);t<this._bufferService.rows;t++)this._resetBufferLine(t);this._dirtyRowService.markDirty(t);break;case 1:for(t=this._bufferService.buffer.y,this._dirtyRowService.markDirty(t),this._eraseInBufferLine(t,0,this._bufferService.buffer.x+1,!0),this._bufferService.buffer.x+1>=this._bufferService.cols&&(this._bufferService.buffer.lines.get(t+1).isWrapped=!1);t--;)this._resetBufferLine(t);this._dirtyRowService.markDirty(0);break;case 2:for(t=this._bufferService.rows,this._dirtyRowService.markDirty(t-1);t--;)this._resetBufferLine(t);this._dirtyRowService.markDirty(0);break;case 3:var r=this._bufferService.buffer.lines.length-this._bufferService.rows;r>0&&(this._bufferService.buffer.lines.trimStart(r),this._bufferService.buffer.ybase=Math.max(this._bufferService.buffer.ybase-r,0),this._bufferService.buffer.ydisp=Math.max(this._bufferService.buffer.ydisp-r,0),this._onScroll.fire(0));}},t.prototype.eraseInLine=function(e){switch(this._restrictCursor(),e.params[0]){case 0:this._eraseInBufferLine(this._bufferService.buffer.y,this._bufferService.buffer.x,this._bufferService.cols);break;case 1:this._eraseInBufferLine(this._bufferService.buffer.y,0,this._bufferService.buffer.x+1);break;case 2:this._eraseInBufferLine(this._bufferService.buffer.y,0,this._bufferService.cols);}this._dirtyRowService.markDirty(this._bufferService.buffer.y);},t.prototype.insertLines=function(e){this._restrictCursor();var t=e.params[0]||1,r=this._bufferService.buffer;if(!(r.y>r.scrollBottom||r.y<r.scrollTop)){for(var i=r.ybase+r.y,n=this._bufferService.rows-1-r.scrollBottom,o=this._bufferService.rows-1+r.ybase-n+1;t--;)r.lines.splice(o-1,1),r.lines.splice(i,0,r.getBlankLine(this._eraseAttrData()));this._dirtyRowService.markRangeDirty(r.y,r.scrollBottom),r.x=0;}},t.prototype.deleteLines=function(e){this._restrictCursor();var t=e.params[0]||1,r=this._bufferService.buffer;if(!(r.y>r.scrollBottom||r.y<r.scrollTop)){var i,n=r.ybase+r.y;for(i=this._bufferService.rows-1-r.scrollBottom,i=this._bufferService.rows-1+r.ybase-i;t--;)r.lines.splice(n,1),r.lines.splice(i,0,r.getBlankLine(this._eraseAttrData()));this._dirtyRowService.markRangeDirty(r.y,r.scrollBottom),r.x=0;}},t.prototype.insertChars=function(e){this._restrictCursor();var t=this._bufferService.buffer.lines.get(this._bufferService.buffer.ybase+this._bufferService.buffer.y);t&&(t.insertCells(this._bufferService.buffer.x,e.params[0]||1,this._bufferService.buffer.getNullCell(this._eraseAttrData()),this._eraseAttrData()),this._dirtyRowService.markDirty(this._bufferService.buffer.y));},t.prototype.deleteChars=function(e){this._restrictCursor();var t=this._bufferService.buffer.lines.get(this._bufferService.buffer.ybase+this._bufferService.buffer.y);t&&(t.deleteCells(this._bufferService.buffer.x,e.params[0]||1,this._bufferService.buffer.getNullCell(this._eraseAttrData()),this._eraseAttrData()),this._dirtyRowService.markDirty(this._bufferService.buffer.y));},t.prototype.scrollUp=function(e){for(var t=e.params[0]||1,r=this._bufferService.buffer;t--;)r.lines.splice(r.ybase+r.scrollTop,1),r.lines.splice(r.ybase+r.scrollBottom,0,r.getBlankLine(this._eraseAttrData()));this._dirtyRowService.markRangeDirty(r.scrollTop,r.scrollBottom);},t.prototype.scrollDown=function(e){for(var t=e.params[0]||1,r=this._bufferService.buffer;t--;)r.lines.splice(r.ybase+r.scrollBottom,1),r.lines.splice(r.ybase+r.scrollTop,0,r.getBlankLine(f.DEFAULT_ATTR_DATA));this._dirtyRowService.markRangeDirty(r.scrollTop,r.scrollBottom);},t.prototype.scrollLeft=function(e){var t=this._bufferService.buffer;if(!(t.y>t.scrollBottom||t.y<t.scrollTop)){for(var r=e.params[0]||1,i=t.scrollTop;i<=t.scrollBottom;++i){var n=t.lines.get(t.ybase+i);n.deleteCells(0,r,t.getNullCell(this._eraseAttrData()),this._eraseAttrData()),n.isWrapped=!1;}this._dirtyRowService.markRangeDirty(t.scrollTop,t.scrollBottom);}},t.prototype.scrollRight=function(e){var t=this._bufferService.buffer;if(!(t.y>t.scrollBottom||t.y<t.scrollTop)){for(var r=e.params[0]||1,i=t.scrollTop;i<=t.scrollBottom;++i){var n=t.lines.get(t.ybase+i);n.insertCells(0,r,t.getNullCell(this._eraseAttrData()),this._eraseAttrData()),n.isWrapped=!1;}this._dirtyRowService.markRangeDirty(t.scrollTop,t.scrollBottom);}},t.prototype.insertColumns=function(e){var t=this._bufferService.buffer;if(!(t.y>t.scrollBottom||t.y<t.scrollTop)){for(var r=e.params[0]||1,i=t.scrollTop;i<=t.scrollBottom;++i){var n=this._bufferService.buffer.lines.get(t.ybase+i);n.insertCells(t.x,r,t.getNullCell(this._eraseAttrData()),this._eraseAttrData()),n.isWrapped=!1;}this._dirtyRowService.markRangeDirty(t.scrollTop,t.scrollBottom);}},t.prototype.deleteColumns=function(e){var t=this._bufferService.buffer;if(!(t.y>t.scrollBottom||t.y<t.scrollTop)){for(var r=e.params[0]||1,i=t.scrollTop;i<=t.scrollBottom;++i){var n=t.lines.get(t.ybase+i);n.deleteCells(t.x,r,t.getNullCell(this._eraseAttrData()),this._eraseAttrData()),n.isWrapped=!1;}this._dirtyRowService.markRangeDirty(t.scrollTop,t.scrollBottom);}},t.prototype.eraseChars=function(e){this._restrictCursor();var t=this._bufferService.buffer.lines.get(this._bufferService.buffer.ybase+this._bufferService.buffer.y);t&&(t.replaceCells(this._bufferService.buffer.x,this._bufferService.buffer.x+(e.params[0]||1),this._bufferService.buffer.getNullCell(this._eraseAttrData()),this._eraseAttrData()),this._dirtyRowService.markDirty(this._bufferService.buffer.y));},t.prototype.repeatPrecedingCharacter=function(e){if(this._parser.precedingCodepoint){for(var t=e.params[0]||1,r=new Uint32Array(t),i=0;i<t;++i)r[i]=this._parser.precedingCodepoint;this.print(r,0,r.length);}},t.prototype.sendDeviceAttributesPrimary=function(e){e.params[0]>0||(this._is("xterm")||this._is("rxvt-unicode")||this._is("screen")?this._coreService.triggerDataEvent(s.C0.ESC+"[?1;2c"):this._is("linux")&&this._coreService.triggerDataEvent(s.C0.ESC+"[?6c"));},t.prototype.sendDeviceAttributesSecondary=function(e){e.params[0]>0||(this._is("xterm")?this._coreService.triggerDataEvent(s.C0.ESC+"[>0;276;0c"):this._is("rxvt-unicode")?this._coreService.triggerDataEvent(s.C0.ESC+"[>85;95;0c"):this._is("linux")?this._coreService.triggerDataEvent(e.params[0]+"c"):this._is("screen")&&this._coreService.triggerDataEvent(s.C0.ESC+"[>83;40003;0c"));},t.prototype._is=function(e){return 0===(this._optionsService.options.termName+"").indexOf(e)},t.prototype.setMode=function(e){for(var t=0;t<e.length;t++)switch(e.params[t]){case 4:this._coreService.modes.insertMode=!0;}},t.prototype.setModePrivate=function(e){for(var t=0;t<e.length;t++)switch(e.params[t]){case 1:this._coreService.decPrivateModes.applicationCursorKeys=!0;break;case 2:this._charsetService.setgCharset(0,a.DEFAULT_CHARSET),this._charsetService.setgCharset(1,a.DEFAULT_CHARSET),this._charsetService.setgCharset(2,a.DEFAULT_CHARSET),this._charsetService.setgCharset(3,a.DEFAULT_CHARSET);break;case 3:this._optionsService.options.windowOptions.setWinLines&&(this._bufferService.resize(132,this._bufferService.rows),this._onRequestReset.fire());break;case 6:this._coreService.decPrivateModes.origin=!0,this._setCursor(0,0);break;case 7:this._coreService.decPrivateModes.wraparound=!0;break;case 12:break;case 45:this._coreService.decPrivateModes.reverseWraparound=!0;break;case 66:this._logService.debug("Serial port requested application keypad."),this._coreService.decPrivateModes.applicationKeypad=!0,this._onRequestSyncScrollBar.fire();break;case 9:this._coreMouseService.activeProtocol="X10";break;case 1e3:this._coreMouseService.activeProtocol="VT200";break;case 1002:this._coreMouseService.activeProtocol="DRAG";break;case 1003:this._coreMouseService.activeProtocol="ANY";break;case 1004:this._coreService.decPrivateModes.sendFocus=!0;break;case 1005:this._logService.debug("DECSET 1005 not supported (see #2507)");break;case 1006:this._coreMouseService.activeEncoding="SGR";break;case 1015:this._logService.debug("DECSET 1015 not supported (see #2507)");break;case 25:this._coreService.isCursorHidden=!1;break;case 1048:this.saveCursor();break;case 1049:this.saveCursor();case 47:case 1047:this._bufferService.buffers.activateAltBuffer(this._eraseAttrData()),this._coreService.isCursorInitialized=!0,this._onRequestRefreshRows.fire(0,this._bufferService.rows-1),this._onRequestSyncScrollBar.fire();break;case 2004:this._coreService.decPrivateModes.bracketedPasteMode=!0;}},t.prototype.resetMode=function(e){for(var t=0;t<e.length;t++)switch(e.params[t]){case 4:this._coreService.modes.insertMode=!1;}},t.prototype.resetModePrivate=function(e){for(var t=0;t<e.length;t++)switch(e.params[t]){case 1:this._coreService.decPrivateModes.applicationCursorKeys=!1;break;case 3:this._optionsService.options.windowOptions.setWinLines&&(this._bufferService.resize(80,this._bufferService.rows),this._onRequestReset.fire());break;case 6:this._coreService.decPrivateModes.origin=!1,this._setCursor(0,0);break;case 7:this._coreService.decPrivateModes.wraparound=!1;break;case 12:break;case 45:this._coreService.decPrivateModes.reverseWraparound=!1;break;case 66:this._logService.debug("Switching back to normal keypad."),this._coreService.decPrivateModes.applicationKeypad=!1,this._onRequestSyncScrollBar.fire();break;case 9:case 1e3:case 1002:case 1003:this._coreMouseService.activeProtocol="NONE";break;case 1004:this._coreService.decPrivateModes.sendFocus=!1;break;case 1005:this._logService.debug("DECRST 1005 not supported (see #2507)");break;case 1006:this._coreMouseService.activeEncoding="DEFAULT";break;case 1015:this._logService.debug("DECRST 1015 not supported (see #2507)");break;case 25:this._coreService.isCursorHidden=!0;break;case 1048:this.restoreCursor();break;case 1049:case 47:case 1047:this._bufferService.buffers.activateNormalBuffer(),1049===e.params[t]&&this.restoreCursor(),this._coreService.isCursorInitialized=!0,this._onRequestRefreshRows.fire(0,this._bufferService.rows-1),this._onRequestSyncScrollBar.fire();break;case 2004:this._coreService.decPrivateModes.bracketedPasteMode=!1;}},t.prototype._updateAttrColor=function(e,t,r,i,n){return 2===t?(e|=50331648,e&=-16777216,e|=v.AttributeData.fromColorRGB([r,i,n])):5===t&&(e&=-50331904,e|=33554432|255&r),e},t.prototype._extractColor=function(e,t,r){var i=[0,0,-1,0,0,0],n=0,o=0;do{if(i[o+n]=e.params[t+o],e.hasSubParams(t+o)){var s=e.getSubParams(t+o),a=0;do{5===i[1]&&(n=1),i[o+a+1+n]=s[a];}while(++a<s.length&&a+o+1+n<i.length);break}if(5===i[1]&&o+n>=2||2===i[1]&&o+n>=5)break;i[1]&&(n=1);}while(++o+t<e.length&&o+n<i.length);for(a=2;a<i.length;++a)-1===i[a]&&(i[a]=0);switch(i[0]){case 38:r.fg=this._updateAttrColor(r.fg,i[1],i[3],i[4],i[5]);break;case 48:r.bg=this._updateAttrColor(r.bg,i[1],i[3],i[4],i[5]);break;case 58:r.extended=r.extended.clone(),r.extended.underlineColor=this._updateAttrColor(r.extended.underlineColor,i[1],i[3],i[4],i[5]);}return o},t.prototype._processUnderline=function(e,t){t.extended=t.extended.clone(),(!~e||e>5)&&(e=1),t.extended.underlineStyle=e,t.fg|=268435456,0===e&&(t.fg&=-268435457),t.updateExtended();},t.prototype.charAttributes=function(e){if(1===e.length&&0===e.params[0])return this._curAttrData.fg=f.DEFAULT_ATTR_DATA.fg,void(this._curAttrData.bg=f.DEFAULT_ATTR_DATA.bg);for(var t,r=e.length,i=this._curAttrData,n=0;n<r;n++)(t=e.params[n])>=30&&t<=37?(i.fg&=-50331904,i.fg|=16777216|t-30):t>=40&&t<=47?(i.bg&=-50331904,i.bg|=16777216|t-40):t>=90&&t<=97?(i.fg&=-50331904,i.fg|=16777224|t-90):t>=100&&t<=107?(i.bg&=-50331904,i.bg|=16777224|t-100):0===t?(i.fg=f.DEFAULT_ATTR_DATA.fg,i.bg=f.DEFAULT_ATTR_DATA.bg):1===t?i.fg|=134217728:3===t?i.bg|=67108864:4===t?(i.fg|=268435456,this._processUnderline(e.hasSubParams(n)?e.getSubParams(n)[0]:1,i)):5===t?i.fg|=536870912:7===t?i.fg|=67108864:8===t?i.fg|=1073741824:2===t?i.bg|=134217728:21===t?this._processUnderline(2,i):22===t?(i.fg&=-134217729,i.bg&=-134217729):23===t?i.bg&=-67108865:24===t?i.fg&=-268435457:25===t?i.fg&=-536870913:27===t?i.fg&=-67108865:28===t?i.fg&=-1073741825:39===t?(i.fg&=-67108864,i.fg|=16777215&f.DEFAULT_ATTR_DATA.fg):49===t?(i.bg&=-67108864,i.bg|=16777215&f.DEFAULT_ATTR_DATA.bg):38===t||48===t||58===t?n+=this._extractColor(e,n,i):59===t?(i.extended=i.extended.clone(),i.extended.underlineColor=-1,i.updateExtended()):100===t?(i.fg&=-67108864,i.fg|=16777215&f.DEFAULT_ATTR_DATA.fg,i.bg&=-67108864,i.bg|=16777215&f.DEFAULT_ATTR_DATA.bg):this._logService.debug("Unknown SGR attribute: %d.",t);},t.prototype.deviceStatus=function(e){switch(e.params[0]){case 5:this._coreService.triggerDataEvent(s.C0.ESC+"[0n");break;case 6:var t=this._bufferService.buffer.y+1,r=this._bufferService.buffer.x+1;this._coreService.triggerDataEvent(s.C0.ESC+"["+t+";"+r+"R");}},t.prototype.deviceStatusPrivate=function(e){switch(e.params[0]){case 6:var t=this._bufferService.buffer.y+1,r=this._bufferService.buffer.x+1;this._coreService.triggerDataEvent(s.C0.ESC+"[?"+t+";"+r+"R");}},t.prototype.softReset=function(e){this._coreService.isCursorHidden=!1,this._onRequestSyncScrollBar.fire(),this._bufferService.buffer.scrollTop=0,this._bufferService.buffer.scrollBottom=this._bufferService.rows-1,this._curAttrData=f.DEFAULT_ATTR_DATA.clone(),this._coreService.reset(),this._charsetService.reset(),this._bufferService.buffer.savedX=0,this._bufferService.buffer.savedY=this._bufferService.buffer.ybase,this._bufferService.buffer.savedCurAttrData.fg=this._curAttrData.fg,this._bufferService.buffer.savedCurAttrData.bg=this._curAttrData.bg,this._bufferService.buffer.savedCharset=this._charsetService.charset,this._coreService.decPrivateModes.origin=!1;},t.prototype.setCursorStyle=function(e){var t=e.params[0]||1;switch(t){case 1:case 2:this._optionsService.options.cursorStyle="block";break;case 3:case 4:this._optionsService.options.cursorStyle="underline";break;case 5:case 6:this._optionsService.options.cursorStyle="bar";}var r=t%2==1;this._optionsService.options.cursorBlink=r;},t.prototype.setScrollRegion=function(e){var t,r=e.params[0]||1;(e.length<2||(t=e.params[1])>this._bufferService.rows||0===t)&&(t=this._bufferService.rows),t>r&&(this._bufferService.buffer.scrollTop=r-1,this._bufferService.buffer.scrollBottom=t-1,this._setCursor(0,0));},t.prototype.windowOptions=function(e){if(S(e.params[0],this._optionsService.options.windowOptions)){var t=e.length>1?e.params[1]:0;switch(e.params[0]){case 14:2!==t&&this._onRequestWindowsOptionsReport.fire(o.GET_WIN_SIZE_PIXELS);break;case 16:this._onRequestWindowsOptionsReport.fire(o.GET_CELL_SIZE_PIXELS);break;case 18:this._bufferService&&this._coreService.triggerDataEvent(s.C0.ESC+"[8;"+this._bufferService.rows+";"+this._bufferService.cols+"t");break;case 22:0!==t&&2!==t||(this._windowTitleStack.push(this._windowTitle),this._windowTitleStack.length>10&&this._windowTitleStack.shift()),0!==t&&1!==t||(this._iconNameStack.push(this._iconName),this._iconNameStack.length>10&&this._iconNameStack.shift());break;case 23:0!==t&&2!==t||this._windowTitleStack.length&&this.setTitle(this._windowTitleStack.pop()),0!==t&&1!==t||this._iconNameStack.length&&this.setIconName(this._iconNameStack.pop());}}},t.prototype.saveCursor=function(e){this._bufferService.buffer.savedX=this._bufferService.buffer.x,this._bufferService.buffer.savedY=this._bufferService.buffer.ybase+this._bufferService.buffer.y,this._bufferService.buffer.savedCurAttrData.fg=this._curAttrData.fg,this._bufferService.buffer.savedCurAttrData.bg=this._curAttrData.bg,this._bufferService.buffer.savedCharset=this._charsetService.charset;},t.prototype.restoreCursor=function(e){this._bufferService.buffer.x=this._bufferService.buffer.savedX||0,this._bufferService.buffer.y=Math.max(this._bufferService.buffer.savedY-this._bufferService.buffer.ybase,0),this._curAttrData.fg=this._bufferService.buffer.savedCurAttrData.fg,this._curAttrData.bg=this._bufferService.buffer.savedCurAttrData.bg,this._charsetService.charset=this._savedCharset,this._bufferService.buffer.savedCharset&&(this._charsetService.charset=this._bufferService.buffer.savedCharset),this._restrictCursor();},t.prototype.setTitle=function(e){this._windowTitle=e,this._onTitleChange.fire(e);},t.prototype.setIconName=function(e){this._iconName=e;},t.prototype.nextLine=function(){this._bufferService.buffer.x=0,this.index();},t.prototype.keypadApplicationMode=function(){this._logService.debug("Serial port requested application keypad."),this._coreService.decPrivateModes.applicationKeypad=!0,this._onRequestSyncScrollBar.fire();},t.prototype.keypadNumericMode=function(){this._logService.debug("Switching back to normal keypad."),this._coreService.decPrivateModes.applicationKeypad=!1,this._onRequestSyncScrollBar.fire();},t.prototype.selectDefaultCharset=function(){this._charsetService.setgLevel(0),this._charsetService.setgCharset(0,a.DEFAULT_CHARSET);},t.prototype.selectCharset=function(e){2===e.length?"/"!==e[0]&&this._charsetService.setgCharset(b[e[0]],a.CHARSETS[e[1]]||a.DEFAULT_CHARSET):this.selectDefaultCharset();},t.prototype.index=function(){this._restrictCursor();var e=this._bufferService.buffer;this._bufferService.buffer.y++,e.y===e.scrollBottom+1?(e.y--,this._onRequestScroll.fire(this._eraseAttrData())):e.y>=this._bufferService.rows&&(e.y=this._bufferService.rows-1),this._restrictCursor();},t.prototype.tabSet=function(){this._bufferService.buffer.tabs[this._bufferService.buffer.x]=!0;},t.prototype.reverseIndex=function(){this._restrictCursor();var e=this._bufferService.buffer;if(e.y===e.scrollTop){var t=e.scrollBottom-e.scrollTop;e.lines.shiftElements(e.ybase+e.y,t,1),e.lines.set(e.ybase+e.y,e.getBlankLine(this._eraseAttrData())),this._dirtyRowService.markRangeDirty(e.scrollTop,e.scrollBottom);}else e.y--,this._restrictCursor();},t.prototype.fullReset=function(){this._parser.reset(),this._onRequestReset.fire();},t.prototype.reset=function(){this._curAttrData=f.DEFAULT_ATTR_DATA.clone(),this._eraseAttrDataInternal=f.DEFAULT_ATTR_DATA.clone();},t.prototype._eraseAttrData=function(){return this._eraseAttrDataInternal.bg&=-67108864,this._eraseAttrDataInternal.bg|=67108863&this._curAttrData.bg,this._eraseAttrDataInternal},t.prototype.setgLevel=function(e){this._charsetService.setgLevel(e);},t.prototype.screenAlignmentPattern=function(){var e=new p.CellData;e.content=1<<22|"E".charCodeAt(0),e.fg=this._curAttrData.fg,e.bg=this._curAttrData.bg;var t=this._bufferService.buffer;this._setCursor(0,0);for(var r=0;r<this._bufferService.rows;++r){var i=t.ybase+t.y+r,n=t.lines.get(i);n&&(n.fill(e),n.isWrapped=!1);}this._dirtyRowService.markAllDirty(),this._setCursor(0,0);},t}(l.Disposable);t.InputHandler=C;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.DEFAULT_CHARSET=t.CHARSETS=void 0,t.CHARSETS={},t.DEFAULT_CHARSET=t.CHARSETS.B,t.CHARSETS[0]={"`":"",a:"",b:"",c:"",d:"",e:"",f:"",g:"",h:"",i:"",j:"",k:"",l:"",m:"",n:"",o:"",p:"",q:"",r:"",s:"",t:"",u:"",v:"",w:"",x:"",y:"",z:"","{":"","|":"","}":"","~":""},t.CHARSETS.A={"#":""},t.CHARSETS.B=void 0,t.CHARSETS[4]={"#":"","@":"","[":"ij","\\":"","]":"|","{":"","|":"f","}":"","~":""},t.CHARSETS.C=t.CHARSETS[5]={"[":"","\\":"","]":"","^":"","`":"","{":"","|":"","}":"","~":""},t.CHARSETS.R={"#":"","@":"","[":"","\\":"","]":"","{":"","|":"","}":"","~":""},t.CHARSETS.Q={"@":"","[":"","\\":"","]":"","^":"","`":"","{":"","|":"","}":"","~":""},t.CHARSETS.K={"@":"","[":"","\\":"","]":"","{":"","|":"","}":"","~":""},t.CHARSETS.Y={"#":"","@":"","[":"","\\":"","]":"","`":"","{":"","|":"","}":"","~":""},t.CHARSETS.E=t.CHARSETS[6]={"@":"","[":"","\\":"","]":"","^":"","`":"","{":"","|":"","}":"","~":""},t.CHARSETS.Z={"#":"","@":"","[":"","\\":"","]":"","{":"","|":"","}":""},t.CHARSETS.H=t.CHARSETS[7]={"@":"","[":"","\\":"","]":"","^":"","`":"","{":"","|":"","}":"","~":""},t.CHARSETS["="]={"#":"","@":"","[":"","\\":"","]":"","^":"",_:"","`":"","{":"","|":"","}":"","~":""};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.Params=void 0;var i=function(){function e(e,t){if(void 0===e&&(e=32),void 0===t&&(t=32),this.maxLength=e,this.maxSubParamsLength=t,t>256)throw new Error("maxSubParamsLength must not be greater than 256");this.params=new Int32Array(e),this.length=0,this._subParams=new Int32Array(t),this._subParamsLength=0,this._subParamsIdx=new Uint16Array(e),this._rejectDigits=!1,this._rejectSubDigits=!1,this._digitIsSub=!1;}return e.fromArray=function(t){var r=new e;if(!t.length)return r;for(var i=t[0]instanceof Array?1:0;i<t.length;++i){var n=t[i];if(n instanceof Array)for(var o=0;o<n.length;++o)r.addSubParam(n[o]);else r.addParam(n);}return r},e.prototype.clone=function(){var t=new e(this.maxLength,this.maxSubParamsLength);return t.params.set(this.params),t.length=this.length,t._subParams.set(this._subParams),t._subParamsLength=this._subParamsLength,t._subParamsIdx.set(this._subParamsIdx),t._rejectDigits=this._rejectDigits,t._rejectSubDigits=this._rejectSubDigits,t._digitIsSub=this._digitIsSub,t},e.prototype.toArray=function(){for(var e=[],t=0;t<this.length;++t){e.push(this.params[t]);var r=this._subParamsIdx[t]>>8,i=255&this._subParamsIdx[t];i-r>0&&e.push(Array.prototype.slice.call(this._subParams,r,i));}return e},e.prototype.reset=function(){this.length=0,this._subParamsLength=0,this._rejectDigits=!1,this._rejectSubDigits=!1,this._digitIsSub=!1;},e.prototype.addParam=function(e){if(this._digitIsSub=!1,this.length>=this.maxLength)this._rejectDigits=!0;else {if(e<-1)throw new Error("values lesser than -1 are not allowed");this._subParamsIdx[this.length]=this._subParamsLength<<8|this._subParamsLength,this.params[this.length++]=e>2147483647?2147483647:e;}},e.prototype.addSubParam=function(e){if(this._digitIsSub=!0,this.length)if(this._rejectDigits||this._subParamsLength>=this.maxSubParamsLength)this._rejectSubDigits=!0;else {if(e<-1)throw new Error("values lesser than -1 are not allowed");this._subParams[this._subParamsLength++]=e>2147483647?2147483647:e,this._subParamsIdx[this.length-1]++;}},e.prototype.hasSubParams=function(e){return (255&this._subParamsIdx[e])-(this._subParamsIdx[e]>>8)>0},e.prototype.getSubParams=function(e){var t=this._subParamsIdx[e]>>8,r=255&this._subParamsIdx[e];return r-t>0?this._subParams.subarray(t,r):null},e.prototype.getSubParamsAll=function(){for(var e={},t=0;t<this.length;++t){var r=this._subParamsIdx[t]>>8,i=255&this._subParamsIdx[t];i-r>0&&(e[t]=this._subParams.slice(r,i));}return e},e.prototype.addDigit=function(e){var t;if(!(this._rejectDigits||!(t=this._digitIsSub?this._subParamsLength:this.length)||this._digitIsSub&&this._rejectSubDigits)){var r=this._digitIsSub?this._subParams:this.params,i=r[t-1];r[t-1]=~i?Math.min(10*i+e,2147483647):e;}},e}();t.Params=i;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.OscHandler=t.OscParser=void 0;var i=r(22),n=r(8),o=function(){function e(){this._state=0,this._id=-1,this._handlers=Object.create(null),this._handlerFb=function(){};}return e.prototype.addHandler=function(e,t){void 0===this._handlers[e]&&(this._handlers[e]=[]);var r=this._handlers[e];return r.push(t),{dispose:function(){var e=r.indexOf(t);-1!==e&&r.splice(e,1);}}},e.prototype.setHandler=function(e,t){this._handlers[e]=[t];},e.prototype.clearHandler=function(e){this._handlers[e]&&delete this._handlers[e];},e.prototype.setHandlerFallback=function(e){this._handlerFb=e;},e.prototype.dispose=function(){this._handlers=Object.create(null),this._handlerFb=function(){};},e.prototype.reset=function(){2===this._state&&this.end(!1),this._id=-1,this._state=0;},e.prototype._start=function(){var e=this._handlers[this._id];if(e)for(var t=e.length-1;t>=0;t--)e[t].start();else this._handlerFb(this._id,"START");},e.prototype._put=function(e,t,r){var i=this._handlers[this._id];if(i)for(var o=i.length-1;o>=0;o--)i[o].put(e,t,r);else this._handlerFb(this._id,"PUT",n.utf32ToString(e,t,r));},e.prototype._end=function(e){var t=this._handlers[this._id];if(t){for(var r=t.length-1;r>=0&&!1===t[r].end(e);r--);for(r--;r>=0;r--)t[r].end(!1);}else this._handlerFb(this._id,"END",e);},e.prototype.start=function(){this.reset(),this._id=-1,this._state=1;},e.prototype.put=function(e,t,r){if(3!==this._state){if(1===this._state)for(;t<r;){var i=e[t++];if(59===i){this._state=2,this._start();break}if(i<48||57<i)return void(this._state=3);-1===this._id&&(this._id=0),this._id=10*this._id+i-48;}2===this._state&&r-t>0&&this._put(e,t,r);}},e.prototype.end=function(e){0!==this._state&&(3!==this._state&&(1===this._state&&this._start(),this._end(e)),this._id=-1,this._state=0);},e}();t.OscParser=o;var s=function(){function e(e){this._handler=e,this._data="",this._hitLimit=!1;}return e.prototype.start=function(){this._data="",this._hitLimit=!1;},e.prototype.put=function(e,t,r){this._hitLimit||(this._data+=n.utf32ToString(e,t,r),this._data.length>i.PAYLOAD_LIMIT&&(this._data="",this._hitLimit=!0));},e.prototype.end=function(e){var t;return this._hitLimit?t=!1:e&&(t=this._handler(this._data)),this._data="",this._hitLimit=!1,t},e}();t.OscHandler=s;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.PAYLOAD_LIMIT=void 0,t.PAYLOAD_LIMIT=1e7;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.DcsHandler=t.DcsParser=void 0;var i=r(8),n=r(20),o=r(22),s=[],a=function(){function e(){this._handlers=Object.create(null),this._active=s,this._ident=0,this._handlerFb=function(){};}return e.prototype.dispose=function(){this._handlers=Object.create(null),this._handlerFb=function(){};},e.prototype.addHandler=function(e,t){void 0===this._handlers[e]&&(this._handlers[e]=[]);var r=this._handlers[e];return r.push(t),{dispose:function(){var e=r.indexOf(t);-1!==e&&r.splice(e,1);}}},e.prototype.setHandler=function(e,t){this._handlers[e]=[t];},e.prototype.clearHandler=function(e){this._handlers[e]&&delete this._handlers[e];},e.prototype.setHandlerFallback=function(e){this._handlerFb=e;},e.prototype.reset=function(){this._active.length&&this.unhook(!1),this._active=s,this._ident=0;},e.prototype.hook=function(e,t){if(this.reset(),this._ident=e,this._active=this._handlers[e]||s,this._active.length)for(var r=this._active.length-1;r>=0;r--)this._active[r].hook(t);else this._handlerFb(this._ident,"HOOK",t);},e.prototype.put=function(e,t,r){if(this._active.length)for(var n=this._active.length-1;n>=0;n--)this._active[n].put(e,t,r);else this._handlerFb(this._ident,"PUT",i.utf32ToString(e,t,r));},e.prototype.unhook=function(e){if(this._active.length){for(var t=this._active.length-1;t>=0&&!1===this._active[t].unhook(e);t--);for(t--;t>=0;t--)this._active[t].unhook(!1);}else this._handlerFb(this._ident,"UNHOOK",e);this._active=s,this._ident=0;},e}();t.DcsParser=a;var c=function(){function e(e){this._handler=e,this._data="",this._hitLimit=!1;}return e.prototype.hook=function(e){this._params=e.clone(),this._data="",this._hitLimit=!1;},e.prototype.put=function(e,t,r){this._hitLimit||(this._data+=i.utf32ToString(e,t,r),this._data.length>o.PAYLOAD_LIMIT&&(this._data="",this._hitLimit=!0));},e.prototype.unhook=function(e){var t;return this._hitLimit?t=!1:e&&(t=this._handler(this._data,this._params?this._params:new n.Params)),this._params=void 0,this._data="",this._hitLimit=!1,t},e}();t.DcsHandler=c;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.removeTerminalFromCache=t.acquireCharAtlas=void 0;var i=r(25),n=r(42),o=[];t.acquireCharAtlas=function(e,t,r,s,a){for(var c=i.generateConfig(s,a,e,r),l=0;l<o.length;l++){var h=(u=o[l]).ownedBy.indexOf(t);if(h>=0){if(i.configEquals(u.config,c))return u.atlas;1===u.ownedBy.length?(u.atlas.dispose(),o.splice(l,1)):u.ownedBy.splice(h,1);break}}for(l=0;l<o.length;l++){var u=o[l];if(i.configEquals(u.config,c))return u.ownedBy.push(t),u.atlas}var f={atlas:new n.DynamicCharAtlas(document,c),config:c,ownedBy:[t]};return o.push(f),f.atlas},t.removeTerminalFromCache=function(e){for(var t=0;t<o.length;t++){var r=o[t].ownedBy.indexOf(e);if(-1!==r){1===o[t].ownedBy.length?(o[t].atlas.dispose(),o.splice(t,1)):o[t].ownedBy.splice(r,1);break}}};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.is256Color=t.configEquals=t.generateConfig=void 0;var i=r(3);t.generateConfig=function(e,t,r,i){var n={foreground:i.foreground,background:i.background,cursor:void 0,cursorAccent:void 0,selection:void 0,ansi:i.ansi.slice(0,16)};return {devicePixelRatio:window.devicePixelRatio,scaledCharWidth:e,scaledCharHeight:t,fontFamily:r.fontFamily,fontSize:r.fontSize,fontWeight:r.fontWeight,fontWeightBold:r.fontWeightBold,allowTransparency:r.allowTransparency,colors:n}},t.configEquals=function(e,t){for(var r=0;r<e.colors.ansi.length;r++)if(e.colors.ansi[r].rgba!==t.colors.ansi[r].rgba)return !1;return e.devicePixelRatio===t.devicePixelRatio&&e.fontFamily===t.fontFamily&&e.fontSize===t.fontSize&&e.fontWeight===t.fontWeight&&e.fontWeightBold===t.fontWeightBold&&e.allowTransparency===t.allowTransparency&&e.scaledCharWidth===t.scaledCharWidth&&e.scaledCharHeight===t.scaledCharHeight&&e.colors.foreground===t.colors.foreground&&e.colors.background===t.colors.background},t.is256Color=function(e){return e<i.DEFAULT_COLOR};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.ColorManager=t.DEFAULT_ANSI_COLORS=void 0;var i=r(10),n=r(44),o=i.css.toColor("#ffffff"),s=i.css.toColor("#000000"),a=i.css.toColor("#ffffff"),c=i.css.toColor("#000000"),l={css:"rgba(255, 255, 255, 0.3)",rgba:4294967117};t.DEFAULT_ANSI_COLORS=function(){for(var e=[i.css.toColor("#2e3436"),i.css.toColor("#cc0000"),i.css.toColor("#4e9a06"),i.css.toColor("#c4a000"),i.css.toColor("#3465a4"),i.css.toColor("#75507b"),i.css.toColor("#06989a"),i.css.toColor("#d3d7cf"),i.css.toColor("#555753"),i.css.toColor("#ef2929"),i.css.toColor("#8ae234"),i.css.toColor("#fce94f"),i.css.toColor("#729fcf"),i.css.toColor("#ad7fa8"),i.css.toColor("#34e2e2"),i.css.toColor("#eeeeec")],t=[0,95,135,175,215,255],r=0;r<216;r++){var n=t[r/36%6|0],o=t[r/6%6|0],s=t[r%6];e.push({css:i.channels.toCss(n,o,s),rgba:i.channels.toRgba(n,o,s)});}for(r=0;r<24;r++){var a=8+10*r;e.push({css:i.channels.toCss(a,a,a),rgba:i.channels.toRgba(a,a,a)});}return e}();var h=function(){function e(e,r){this.allowTransparency=r;var h=e.createElement("canvas");h.width=1,h.height=1;var u=h.getContext("2d");if(!u)throw new Error("Could not get rendering context");this._ctx=u,this._ctx.globalCompositeOperation="copy",this._litmusColor=this._ctx.createLinearGradient(0,0,1,1),this._contrastCache=new n.ColorContrastCache,this.colors={foreground:o,background:s,cursor:a,cursorAccent:c,selection:l,selectionOpaque:i.color.blend(s,l),ansi:t.DEFAULT_ANSI_COLORS.slice(),contrastCache:this._contrastCache};}return e.prototype.onOptionsChange=function(e){"minimumContrastRatio"===e&&this._contrastCache.clear();},e.prototype.setTheme=function(e){void 0===e&&(e={}),this.colors.foreground=this._parseColor(e.foreground,o),this.colors.background=this._parseColor(e.background,s),this.colors.cursor=this._parseColor(e.cursor,a,!0),this.colors.cursorAccent=this._parseColor(e.cursorAccent,c,!0),this.colors.selection=this._parseColor(e.selection,l,!0),this.colors.selectionOpaque=i.color.blend(this.colors.background,this.colors.selection),this.colors.ansi[0]=this._parseColor(e.black,t.DEFAULT_ANSI_COLORS[0]),this.colors.ansi[1]=this._parseColor(e.red,t.DEFAULT_ANSI_COLORS[1]),this.colors.ansi[2]=this._parseColor(e.green,t.DEFAULT_ANSI_COLORS[2]),this.colors.ansi[3]=this._parseColor(e.yellow,t.DEFAULT_ANSI_COLORS[3]),this.colors.ansi[4]=this._parseColor(e.blue,t.DEFAULT_ANSI_COLORS[4]),this.colors.ansi[5]=this._parseColor(e.magenta,t.DEFAULT_ANSI_COLORS[5]),this.colors.ansi[6]=this._parseColor(e.cyan,t.DEFAULT_ANSI_COLORS[6]),this.colors.ansi[7]=this._parseColor(e.white,t.DEFAULT_ANSI_COLORS[7]),this.colors.ansi[8]=this._parseColor(e.brightBlack,t.DEFAULT_ANSI_COLORS[8]),this.colors.ansi[9]=this._parseColor(e.brightRed,t.DEFAULT_ANSI_COLORS[9]),this.colors.ansi[10]=this._parseColor(e.brightGreen,t.DEFAULT_ANSI_COLORS[10]),this.colors.ansi[11]=this._parseColor(e.brightYellow,t.DEFAULT_ANSI_COLORS[11]),this.colors.ansi[12]=this._parseColor(e.brightBlue,t.DEFAULT_ANSI_COLORS[12]),this.colors.ansi[13]=this._parseColor(e.brightMagenta,t.DEFAULT_ANSI_COLORS[13]),this.colors.ansi[14]=this._parseColor(e.brightCyan,t.DEFAULT_ANSI_COLORS[14]),this.colors.ansi[15]=this._parseColor(e.brightWhite,t.DEFAULT_ANSI_COLORS[15]),this._contrastCache.clear();},e.prototype._parseColor=function(e,t,r){if(void 0===r&&(r=this.allowTransparency),void 0===e)return t;if(this._ctx.fillStyle=this._litmusColor,this._ctx.fillStyle=e,"string"!=typeof this._ctx.fillStyle)return console.warn("Color: "+e+" is invalid using fallback "+t.css),t;this._ctx.fillRect(0,0,1,1);var n=this._ctx.getImageData(0,0,1,1).data;if(255!==n[3]){if(!r)return console.warn("Color: "+e+" is using transparency, but allowTransparency is false. Using fallback "+t.css+"."),t;var o=this._ctx.fillStyle.substring(5,this._ctx.fillStyle.length-1).split(",").map((function(e){return Number(e)})),s=o[0],a=o[1],c=o[2],l=o[3],h=Math.round(255*l);return {rgba:i.channels.toRgba(s,a,c,h),css:e}}return {css:this._ctx.fillStyle,rgba:i.channels.toRgba(n[0],n[1],n[2],n[3])}},e}();t.ColorManager=h;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.throwIfFalsy=void 0,t.throwIfFalsy=function(e){if(!e)throw new Error("value must not be falsy");return e};},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.CharacterJoinerRegistry=t.JoinedCellData=void 0;var o=r(6),s=r(3),a=r(4),c=function(e){function t(t,r,i){var n=e.call(this)||this;return n.content=0,n.combinedData="",n.fg=t.fg,n.bg=t.bg,n.combinedData=r,n._width=i,n}return n(t,e),t.prototype.isCombined=function(){return 2097152},t.prototype.getWidth=function(){return this._width},t.prototype.getChars=function(){return this.combinedData},t.prototype.getCode=function(){return 2097151},t.prototype.setFromCharData=function(e){throw new Error("not implemented")},t.prototype.getAsCharData=function(){return [this.fg,this.getChars(),this.getWidth(),this.getCode()]},t}(o.AttributeData);t.JoinedCellData=c;var l=function(){function e(e){this._bufferService=e,this._characterJoiners=[],this._nextCharacterJoinerId=0,this._workCell=new a.CellData;}return e.prototype.registerCharacterJoiner=function(e){var t={id:this._nextCharacterJoinerId++,handler:e};return this._characterJoiners.push(t),t.id},e.prototype.deregisterCharacterJoiner=function(e){for(var t=0;t<this._characterJoiners.length;t++)if(this._characterJoiners[t].id===e)return this._characterJoiners.splice(t,1),!0;return !1},e.prototype.getJoinedCharacters=function(e){if(0===this._characterJoiners.length)return [];var t=this._bufferService.buffer.lines.get(e);if(!t||0===t.length)return [];for(var r=[],i=t.translateToString(!0),n=0,o=0,a=0,c=t.getFg(0),l=t.getBg(0),h=0;h<t.getTrimmedLength();h++)if(t.loadCell(h,this._workCell),0!==this._workCell.getWidth()){if(this._workCell.fg!==c||this._workCell.bg!==l){if(h-n>1)for(var u=this._getJoinedRanges(i,a,o,t,n),f=0;f<u.length;f++)r.push(u[f]);n=h,a=o,c=this._workCell.fg,l=this._workCell.bg;}o+=this._workCell.getChars().length||s.WHITESPACE_CELL_CHAR.length;}if(this._bufferService.cols-n>1)for(u=this._getJoinedRanges(i,a,o,t,n),f=0;f<u.length;f++)r.push(u[f]);return r},e.prototype._getJoinedRanges=function(t,r,i,n,o){for(var s=t.substring(r,i),a=this._characterJoiners[0].handler(s),c=1;c<this._characterJoiners.length;c++)for(var l=this._characterJoiners[c].handler(s),h=0;h<l.length;h++)e._mergeRanges(a,l[h]);return this._stringRangesToCellRanges(a,n,o),a},e.prototype._stringRangesToCellRanges=function(e,t,r){var i=0,n=!1,o=0,a=e[i];if(a){for(var c=r;c<this._bufferService.cols;c++){var l=t.getWidth(c),h=t.getString(c).length||s.WHITESPACE_CELL_CHAR.length;if(0!==l){if(!n&&a[0]<=o&&(a[0]=c,n=!0),a[1]<=o){if(a[1]=c,!(a=e[++i]))break;a[0]<=o?(a[0]=c,n=!0):n=!1;}o+=h;}}a&&(a[1]=this._bufferService.cols);}},e._mergeRanges=function(e,t){for(var r=!1,i=0;i<e.length;i++){var n=e[i];if(r){if(t[1]<=n[0])return e[i-1][1]=t[1],e;if(t[1]<=n[1])return e[i-1][1]=Math.max(t[1],n[1]),e.splice(i,1),e;e.splice(i,1),i--;}else {if(t[1]<=n[0])return e.splice(i,0,t),e;if(t[1]<=n[1])return n[0]=Math.min(t[0],n[0]),e;t[0]<n[1]&&(n[0]=Math.min(t[0],n[0]),r=!0);}}return r?e[e.length-1][1]=t[1]:e.push(t),e},e}();t.CharacterJoinerRegistry=l;},function(e,t,r){function i(e,t){var r=t.getBoundingClientRect();return [e.clientX-r.left,e.clientY-r.top]}Object.defineProperty(t,"__esModule",{value:!0}),t.getRawByteCoords=t.getCoords=t.getCoordsRelativeToElement=void 0,t.getCoordsRelativeToElement=i,t.getCoords=function(e,t,r,n,o,s,a,c){if(o){var l=i(e,t);if(l)return l[0]=Math.ceil((l[0]+(c?s/2:0))/s),l[1]=Math.ceil(l[1]/a),l[0]=Math.min(Math.max(l[0],1),r+(c?1:0)),l[1]=Math.min(Math.max(l[1],1),n),l}},t.getRawByteCoords=function(e){if(e)return {x:e[0]+32,y:e[1]+32}};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.RenderDebouncer=void 0;var i=function(){function e(e){this._renderCallback=e;}return e.prototype.dispose=function(){this._animationFrame&&(window.cancelAnimationFrame(this._animationFrame),this._animationFrame=void 0);},e.prototype.refresh=function(e,t,r){var i=this;this._rowCount=r,e=void 0!==e?e:0,t=void 0!==t?t:this._rowCount-1,this._rowStart=void 0!==this._rowStart?Math.min(this._rowStart,e):e,this._rowEnd=void 0!==this._rowEnd?Math.max(this._rowEnd,t):t,this._animationFrame||(this._animationFrame=window.requestAnimationFrame((function(){return i._innerRefresh()})));},e.prototype._innerRefresh=function(){if(void 0!==this._rowStart&&void 0!==this._rowEnd&&void 0!==this._rowCount){var e=Math.max(this._rowStart,0),t=Math.min(this._rowEnd,this._rowCount-1);this._rowStart=void 0,this._rowEnd=void 0,this._animationFrame=void 0,this._renderCallback(e,t);}},e}();t.RenderDebouncer=i;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.ScreenDprMonitor=void 0;var o=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t._currentDevicePixelRatio=window.devicePixelRatio,t}return n(t,e),t.prototype.setListener=function(e){var t=this;this._listener&&this.clearListener(),this._listener=e,this._outerListener=function(){t._listener&&(t._listener(window.devicePixelRatio,t._currentDevicePixelRatio),t._updateDpr());},this._updateDpr();},t.prototype.dispose=function(){e.prototype.dispose.call(this),this.clearListener();},t.prototype._updateDpr=function(){var e;this._outerListener&&(null===(e=this._resolutionMediaMatchList)||void 0===e||e.removeListener(this._outerListener),this._currentDevicePixelRatio=window.devicePixelRatio,this._resolutionMediaMatchList=window.matchMedia("screen and (resolution: "+window.devicePixelRatio+"dppx)"),this._resolutionMediaMatchList.addListener(this._outerListener));},t.prototype.clearListener=function(){this._resolutionMediaMatchList&&this._listener&&this._outerListener&&(this._resolutionMediaMatchList.removeListener(this._outerListener),this._resolutionMediaMatchList=void 0,this._listener=void 0,this._outerListener=void 0);},t}(r(2).Disposable);t.ScreenDprMonitor=o;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.clone=void 0,t.clone=function e(t,r){if(void 0===r&&(r=5),"object"!=typeof t)return t;var i=Array.isArray(t)?[]:{};for(var n in t)i[n]=r<=1?t[n]:t[n]?e(t[n],r-1):t[n];return i};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.Terminal=void 0;var i=r(4),n=r(34),o=r(17),s=r(0),a=r(82),c=function(){function e(e){this._core=new n.Terminal(e),this._addonManager=new a.AddonManager;}return e.prototype._checkProposedApi=function(){if(!this._core.optionsService.options.allowProposedApi)throw new Error("You must set the allowProposedApi option to true to use proposed API")},Object.defineProperty(e.prototype,"onCursorMove",{get:function(){return this._core.onCursorMove},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onLineFeed",{get:function(){return this._core.onLineFeed},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onSelectionChange",{get:function(){return this._core.onSelectionChange},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onData",{get:function(){return this._core.onData},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onBinary",{get:function(){return this._core.onBinary},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onTitleChange",{get:function(){return this._core.onTitleChange},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onScroll",{get:function(){return this._core.onScroll},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onKey",{get:function(){return this._core.onKey},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onRender",{get:function(){return this._core.onRender},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onResize",{get:function(){return this._core.onResize},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"element",{get:function(){return this._core.element},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"parser",{get:function(){return this._checkProposedApi(),this._parser||(this._parser=new f(this._core)),this._parser},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"unicode",{get:function(){return this._checkProposedApi(),new _(this._core)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"textarea",{get:function(){return this._core.textarea},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"rows",{get:function(){return this._core.rows},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"cols",{get:function(){return this._core.cols},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"buffer",{get:function(){return this._checkProposedApi(),new h(this._core.buffers)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"markers",{get:function(){return this._checkProposedApi(),this._core.markers},enumerable:!1,configurable:!0}),e.prototype.blur=function(){this._core.blur();},e.prototype.focus=function(){this._core.focus();},e.prototype.resize=function(e,t){this._verifyIntegers(e,t),this._core.resize(e,t);},e.prototype.open=function(e){this._core.open(e);},e.prototype.attachCustomKeyEventHandler=function(e){this._core.attachCustomKeyEventHandler(e);},e.prototype.registerLinkMatcher=function(e,t,r){return this._checkProposedApi(),this._core.registerLinkMatcher(e,t,r)},e.prototype.deregisterLinkMatcher=function(e){this._checkProposedApi(),this._core.deregisterLinkMatcher(e);},e.prototype.registerLinkProvider=function(e){return this._checkProposedApi(),this._core.registerLinkProvider(e)},e.prototype.registerCharacterJoiner=function(e){return this._checkProposedApi(),this._core.registerCharacterJoiner(e)},e.prototype.deregisterCharacterJoiner=function(e){this._checkProposedApi(),this._core.deregisterCharacterJoiner(e);},e.prototype.registerMarker=function(e){return this._checkProposedApi(),this._verifyIntegers(e),this._core.addMarker(e)},e.prototype.addMarker=function(e){return this.registerMarker(e)},e.prototype.hasSelection=function(){return this._core.hasSelection()},e.prototype.select=function(e,t,r){this._verifyIntegers(e,t,r),this._core.select(e,t,r);},e.prototype.getSelection=function(){return this._core.getSelection()},e.prototype.getSelectionPosition=function(){return this._core.getSelectionPosition()},e.prototype.clearSelection=function(){this._core.clearSelection();},e.prototype.selectAll=function(){this._core.selectAll();},e.prototype.selectLines=function(e,t){this._verifyIntegers(e,t),this._core.selectLines(e,t);},e.prototype.dispose=function(){this._addonManager.dispose(),this._core.dispose();},e.prototype.scrollLines=function(e){this._verifyIntegers(e),this._core.scrollLines(e);},e.prototype.scrollPages=function(e){this._verifyIntegers(e),this._core.scrollPages(e);},e.prototype.scrollToTop=function(){this._core.scrollToTop();},e.prototype.scrollToBottom=function(){this._core.scrollToBottom();},e.prototype.scrollToLine=function(e){this._verifyIntegers(e),this._core.scrollToLine(e);},e.prototype.clear=function(){this._core.clear();},e.prototype.write=function(e,t){this._core.write(e,t);},e.prototype.writeUtf8=function(e,t){this._core.write(e,t);},e.prototype.writeln=function(e,t){this._core.write(e),this._core.write("\r\n",t);},e.prototype.paste=function(e){this._core.paste(e);},e.prototype.getOption=function(e){return this._core.optionsService.getOption(e)},e.prototype.setOption=function(e,t){this._core.optionsService.setOption(e,t);},e.prototype.refresh=function(e,t){this._verifyIntegers(e,t),this._core.refresh(e,t);},e.prototype.reset=function(){this._core.reset();},e.prototype.loadAddon=function(e){return this._addonManager.loadAddon(this,e)},Object.defineProperty(e,"strings",{get:function(){return o},enumerable:!1,configurable:!0}),e.prototype._verifyIntegers=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];e.forEach((function(e){if(e===1/0||isNaN(e)||e%1!=0)throw new Error("This API only accepts integers")}));},e}();t.Terminal=c;var l=function(){function e(e,t){this._buffer=e,this.type=t;}return e.prototype.init=function(e){return this._buffer=e,this},Object.defineProperty(e.prototype,"cursorY",{get:function(){return this._buffer.y},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"cursorX",{get:function(){return this._buffer.x},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"viewportY",{get:function(){return this._buffer.ydisp},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"baseY",{get:function(){return this._buffer.ybase},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"length",{get:function(){return this._buffer.lines.length},enumerable:!1,configurable:!0}),e.prototype.getLine=function(e){var t=this._buffer.lines.get(e);if(t)return new u(t)},e.prototype.getNullCell=function(){return new i.CellData},e}(),h=function(){function e(e){var t=this;this._buffers=e,this._onBufferChange=new s.EventEmitter,this._normal=new l(this._buffers.normal,"normal"),this._alternate=new l(this._buffers.alt,"alternate"),this._buffers.onBufferActivate((function(){return t._onBufferChange.fire(t.active)}));}return Object.defineProperty(e.prototype,"onBufferChange",{get:function(){return this._onBufferChange.event},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"active",{get:function(){if(this._buffers.active===this._buffers.normal)return this.normal;if(this._buffers.active===this._buffers.alt)return this.alternate;throw new Error("Active buffer is neither normal nor alternate")},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"normal",{get:function(){return this._normal.init(this._buffers.normal)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"alternate",{get:function(){return this._alternate.init(this._buffers.alt)},enumerable:!1,configurable:!0}),e}(),u=function(){function e(e){this._line=e;}return Object.defineProperty(e.prototype,"isWrapped",{get:function(){return this._line.isWrapped},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"length",{get:function(){return this._line.length},enumerable:!1,configurable:!0}),e.prototype.getCell=function(e,t){if(!(e<0||e>=this._line.length))return t?(this._line.loadCell(e,t),t):this._line.loadCell(e,new i.CellData)},e.prototype.translateToString=function(e,t,r){return this._line.translateToString(e,t,r)},e}(),f=function(){function e(e){this._core=e;}return e.prototype.registerCsiHandler=function(e,t){return this._core.addCsiHandler(e,(function(e){return t(e.toArray())}))},e.prototype.addCsiHandler=function(e,t){return this.registerCsiHandler(e,t)},e.prototype.registerDcsHandler=function(e,t){return this._core.addDcsHandler(e,(function(e,r){return t(e,r.toArray())}))},e.prototype.addDcsHandler=function(e,t){return this.registerDcsHandler(e,t)},e.prototype.registerEscHandler=function(e,t){return this._core.addEscHandler(e,t)},e.prototype.addEscHandler=function(e,t){return this.registerEscHandler(e,t)},e.prototype.registerOscHandler=function(e,t){return this._core.addOscHandler(e,t)},e.prototype.addOscHandler=function(e,t){return this.registerOscHandler(e,t)},e}(),_=function(){function e(e){this._core=e;}return e.prototype.register=function(e){this._core.unicodeService.register(e);},Object.defineProperty(e.prototype,"versions",{get:function(){return this._core.unicodeService.versions},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"activeVersion",{get:function(){return this._core.unicodeService.activeVersion},set:function(e){this._core.unicodeService.activeVersion=e;},enumerable:!1,configurable:!0}),e}();},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.Terminal=void 0;var o=r(35),s=r(36),a=r(37),c=r(12),l=r(18),h=r(39),u=r(49),f=r(50),_=r(11),d=r(7),p=r(17),v=r(53),g=r(54),y=r(55),b=r(56),S=r(58),m=r(0),C=r(16),w=r(26),E=r(59),L=r(5),A=r(60),R=r(61),k=r(62),x=r(63),D=r(64),T="undefined"!=typeof window?window.document:null,O=function(e){function t(t){void 0===t&&(t={});var r=e.call(this,t)||this;return r.browser=_,r._keyDownHandled=!1,r._onCursorMove=new m.EventEmitter,r._onKey=new m.EventEmitter,r._onRender=new m.EventEmitter,r._onSelectionChange=new m.EventEmitter,r._onTitleChange=new m.EventEmitter,r._onFocus=new m.EventEmitter,r._onBlur=new m.EventEmitter,r._onA11yCharEmitter=new m.EventEmitter,r._onA11yTabEmitter=new m.EventEmitter,r._setup(),r.linkifier=r._instantiationService.createInstance(u.Linkifier),r.linkifier2=r.register(r._instantiationService.createInstance(k.Linkifier2)),r.register(r._inputHandler.onRequestBell((function(){return r.bell()}))),r.register(r._inputHandler.onRequestRefreshRows((function(e,t){return r.refresh(e,t)}))),r.register(r._inputHandler.onRequestReset((function(){return r.reset()}))),r.register(r._inputHandler.onRequestScroll((function(e,t){return r.scroll(e,t||void 0)}))),r.register(r._inputHandler.onRequestWindowsOptionsReport((function(e){return r._reportWindowsOptions(e)}))),r.register(m.forwardEvent(r._inputHandler.onCursorMove,r._onCursorMove)),r.register(m.forwardEvent(r._inputHandler.onTitleChange,r._onTitleChange)),r.register(m.forwardEvent(r._inputHandler.onA11yChar,r._onA11yCharEmitter)),r.register(m.forwardEvent(r._inputHandler.onA11yTab,r._onA11yTabEmitter)),r.register(r._bufferService.onResize((function(e){return r._afterResize(e.cols,e.rows)}))),r}return n(t,e),Object.defineProperty(t.prototype,"options",{get:function(){return this.optionsService.options},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onCursorMove",{get:function(){return this._onCursorMove.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onKey",{get:function(){return this._onKey.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRender",{get:function(){return this._onRender.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onSelectionChange",{get:function(){return this._onSelectionChange.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onTitleChange",{get:function(){return this._onTitleChange.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onFocus",{get:function(){return this._onFocus.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onBlur",{get:function(){return this._onBlur.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onA11yChar",{get:function(){return this._onA11yCharEmitter.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onA11yTab",{get:function(){return this._onA11yTabEmitter.event},enumerable:!1,configurable:!0}),t.prototype.dispose=function(){var t,r,i;this._isDisposed||(e.prototype.dispose.call(this),null===(t=this._renderService)||void 0===t||t.dispose(),this._customKeyEventHandler=void 0,this.write=function(){},null===(i=null===(r=this.element)||void 0===r?void 0:r.parentNode)||void 0===i||i.removeChild(this.element));},t.prototype._setup=function(){e.prototype._setup.call(this),this._customKeyEventHandler=void 0;},Object.defineProperty(t.prototype,"buffer",{get:function(){return this.buffers.active},enumerable:!1,configurable:!0}),t.prototype.focus=function(){this.textarea&&this.textarea.focus({preventScroll:!0});},t.prototype._updateOptions=function(t){var r,i,n,o;switch(e.prototype._updateOptions.call(this,t),t){case"fontFamily":case"fontSize":null===(r=this._renderService)||void 0===r||r.clear(),null===(i=this._charSizeService)||void 0===i||i.measure();break;case"cursorBlink":case"cursorStyle":this.refresh(this.buffer.y,this.buffer.y);break;case"drawBoldTextInBrightColors":case"letterSpacing":case"lineHeight":case"fontWeight":case"fontWeightBold":case"minimumContrastRatio":this._renderService&&(this._renderService.clear(),this._renderService.onResize(this.cols,this.rows),this.refresh(0,this.rows-1));break;case"rendererType":this._renderService&&(this._renderService.setRenderer(this._createRenderer()),this._renderService.onResize(this.cols,this.rows));break;case"scrollback":null===(n=this.viewport)||void 0===n||n.syncScrollArea();break;case"screenReaderMode":this.optionsService.options.screenReaderMode?!this._accessibilityManager&&this._renderService&&(this._accessibilityManager=new y.AccessibilityManager(this,this._renderService)):(null===(o=this._accessibilityManager)||void 0===o||o.dispose(),this._accessibilityManager=void 0);break;case"tabStopWidth":this.buffers.setupTabStops();break;case"theme":this._setTheme(this.optionsService.options.theme);}},t.prototype._onTextAreaFocus=function(e){this._coreService.decPrivateModes.sendFocus&&this._coreService.triggerDataEvent(c.C0.ESC+"[I"),this.updateCursorStyle(e),this.element.classList.add("focus"),this._showCursor(),this._onFocus.fire();},t.prototype.blur=function(){var e;return null===(e=this.textarea)||void 0===e?void 0:e.blur()},t.prototype._onTextAreaBlur=function(){this.textarea.value="",this.refresh(this.buffer.y,this.buffer.y),this._coreService.decPrivateModes.sendFocus&&this._coreService.triggerDataEvent(c.C0.ESC+"[O"),this.element.classList.remove("focus"),this._onBlur.fire();},t.prototype._initGlobal=function(){var e=this;this._bindKeys(),this.register(d.addDisposableDomListener(this.element,"copy",(function(t){e.hasSelection()&&a.copyHandler(t,e._selectionService);})));var t=function(t){return a.handlePasteEvent(t,e.textarea,e._coreService)};this.register(d.addDisposableDomListener(this.textarea,"paste",t)),this.register(d.addDisposableDomListener(this.element,"paste",t)),_.isFirefox?this.register(d.addDisposableDomListener(this.element,"mousedown",(function(t){2===t.button&&a.rightClickHandler(t,e.textarea,e.screenElement,e._selectionService,e.options.rightClickSelectsWord);}))):this.register(d.addDisposableDomListener(this.element,"contextmenu",(function(t){a.rightClickHandler(t,e.textarea,e.screenElement,e._selectionService,e.options.rightClickSelectsWord);}))),_.isLinux&&this.register(d.addDisposableDomListener(this.element,"auxclick",(function(t){1===t.button&&a.moveTextAreaUnderMouseCursor(t,e.textarea,e.screenElement);})));},t.prototype._bindKeys=function(){var e=this;this.register(d.addDisposableDomListener(this.textarea,"keyup",(function(t){return e._keyUp(t)}),!0)),this.register(d.addDisposableDomListener(this.textarea,"keydown",(function(t){return e._keyDown(t)}),!0)),this.register(d.addDisposableDomListener(this.textarea,"keypress",(function(t){return e._keyPress(t)}),!0)),this.register(d.addDisposableDomListener(this.textarea,"compositionstart",(function(){return e._compositionHelper.compositionstart()}))),this.register(d.addDisposableDomListener(this.textarea,"compositionupdate",(function(t){return e._compositionHelper.compositionupdate(t)}))),this.register(d.addDisposableDomListener(this.textarea,"compositionend",(function(){return e._compositionHelper.compositionend()}))),this.register(this.onRender((function(){return e._compositionHelper.updateCompositionElements()}))),this.register(this.onRender((function(t){return e._queueLinkification(t.start,t.end)})));},t.prototype.open=function(e){var t=this;if(!e)throw new Error("Terminal requires a parent element.");T.body.contains(e)||this._logService.debug("Terminal.open was called on an element that was not attached to the DOM"),this._document=e.ownerDocument,this.element=this._document.createElement("div"),this.element.dir="ltr",this.element.classList.add("terminal"),this.element.classList.add("xterm"),this.element.setAttribute("tabindex","0"),e.appendChild(this.element);var r=T.createDocumentFragment();this._viewportElement=T.createElement("div"),this._viewportElement.classList.add("xterm-viewport"),r.appendChild(this._viewportElement),this._viewportScrollArea=T.createElement("div"),this._viewportScrollArea.classList.add("xterm-scroll-area"),this._viewportElement.appendChild(this._viewportScrollArea),this.screenElement=T.createElement("div"),this.screenElement.classList.add("xterm-screen"),this._helperContainer=T.createElement("div"),this._helperContainer.classList.add("xterm-helpers"),this.screenElement.appendChild(this._helperContainer),r.appendChild(this.screenElement),this.textarea=T.createElement("textarea"),this.textarea.classList.add("xterm-helper-textarea"),this.textarea.setAttribute("aria-label",p.promptLabel),this.textarea.setAttribute("aria-multiline","false"),this.textarea.setAttribute("autocorrect","off"),this.textarea.setAttribute("autocapitalize","off"),this.textarea.setAttribute("spellcheck","false"),this.textarea.tabIndex=0,this.register(d.addDisposableDomListener(this.textarea,"focus",(function(e){return t._onTextAreaFocus(e)}))),this.register(d.addDisposableDomListener(this.textarea,"blur",(function(){return t._onTextAreaBlur()}))),this._helperContainer.appendChild(this.textarea);var i=this._instantiationService.createInstance(x.CoreBrowserService,this.textarea);this._instantiationService.setService(L.ICoreBrowserService,i),this._charSizeService=this._instantiationService.createInstance(A.CharSizeService,this._document,this._helperContainer),this._instantiationService.setService(L.ICharSizeService,this._charSizeService),this._compositionView=T.createElement("div"),this._compositionView.classList.add("composition-view"),this._compositionHelper=this._instantiationService.createInstance(o.CompositionHelper,this.textarea,this._compositionView),this._helperContainer.appendChild(this._compositionView),this.element.appendChild(r),this._theme=this.options.theme||this._theme,this._colorManager=new w.ColorManager(T,this.options.allowTransparency),this.register(this.optionsService.onOptionChange((function(e){return t._colorManager.onOptionsChange(e)}))),this._colorManager.setTheme(this._theme);var n=this._createRenderer();this._renderService=this.register(this._instantiationService.createInstance(E.RenderService,n,this.rows,this.screenElement)),this._instantiationService.setService(L.IRenderService,this._renderService),this.register(this._renderService.onRenderedBufferChange((function(e){return t._onRender.fire(e)}))),this.onResize((function(e){return t._renderService.resize(e.cols,e.rows)})),this._soundService=this._instantiationService.createInstance(v.SoundService),this._instantiationService.setService(L.ISoundService,this._soundService),this._mouseService=this._instantiationService.createInstance(R.MouseService),this._instantiationService.setService(L.IMouseService,this._mouseService),this.viewport=this._instantiationService.createInstance(s.Viewport,(function(e,r){return t.scrollLines(e,r)}),this._viewportElement,this._viewportScrollArea),this.viewport.onThemeChange(this._colorManager.colors),this.register(this._inputHandler.onRequestSyncScrollBar((function(){return t.viewport.syncScrollArea()}))),this.register(this.viewport),this.register(this.onCursorMove((function(){return t._renderService.onCursorMove()}))),this.register(this.onResize((function(){return t._renderService.onResize(t.cols,t.rows)}))),this.register(this.onBlur((function(){return t._renderService.onBlur()}))),this.register(this.onFocus((function(){return t._renderService.onFocus()}))),this.register(this._renderService.onDimensionsChange((function(){return t.viewport.syncScrollArea()}))),this._selectionService=this.register(this._instantiationService.createInstance(f.SelectionService,this.element,this.screenElement)),this._instantiationService.setService(L.ISelectionService,this._selectionService),this.register(this._selectionService.onRequestScrollLines((function(e){return t.scrollLines(e.amount,e.suppressScrollEvent)}))),this.register(this._selectionService.onSelectionChange((function(){return t._onSelectionChange.fire()}))),this.register(this._selectionService.onRequestRedraw((function(e){return t._renderService.onSelectionChanged(e.start,e.end,e.columnSelectMode)}))),this.register(this._selectionService.onLinuxMouseSelection((function(e){t.textarea.value=e,t.textarea.focus(),t.textarea.select();}))),this.register(this.onScroll((function(){t.viewport.syncScrollArea(),t._selectionService.refresh();}))),this.register(d.addDisposableDomListener(this._viewportElement,"scroll",(function(){return t._selectionService.refresh()}))),this._mouseZoneManager=this._instantiationService.createInstance(g.MouseZoneManager,this.element,this.screenElement),this.register(this._mouseZoneManager),this.register(this.onScroll((function(){return t._mouseZoneManager.clearAll()}))),this.linkifier.attachToDom(this.element,this._mouseZoneManager),this.linkifier2.attachToDom(this.element,this._mouseService,this._renderService),this.register(d.addDisposableDomListener(this.element,"mousedown",(function(e){return t._selectionService.onMouseDown(e)}))),this._coreMouseService.areMouseEventsActive?(this._selectionService.disable(),this.element.classList.add("enable-mouse-events")):this._selectionService.enable(),this.options.screenReaderMode&&(this._accessibilityManager=new y.AccessibilityManager(this,this._renderService)),this._charSizeService.measure(),this.refresh(0,this.rows-1),this._initGlobal(),this.bindMouse();},t.prototype._createRenderer=function(){switch(this.options.rendererType){case"canvas":return this._instantiationService.createInstance(h.Renderer,this._colorManager.colors,this.screenElement,this.linkifier,this.linkifier2);case"dom":return this._instantiationService.createInstance(b.DomRenderer,this._colorManager.colors,this.element,this.screenElement,this._viewportElement,this.linkifier,this.linkifier2);default:throw new Error('Unrecognized rendererType "'+this.options.rendererType+'"')}},t.prototype._setTheme=function(e){var t,r,i;this._theme=e,null===(t=this._colorManager)||void 0===t||t.setTheme(e),null===(r=this._renderService)||void 0===r||r.setColors(this._colorManager.colors),null===(i=this.viewport)||void 0===i||i.onThemeChange(this._colorManager.colors);},t.prototype.bindMouse=function(){var e=this,t=this,r=this.element;function i(e){var r,i,n=t._mouseService.getRawByteCoords(e,t.screenElement,t.cols,t.rows);if(!n)return !1;switch(e.overrideType||e.type){case"mousemove":i=32,void 0===e.buttons?(r=3,void 0!==e.button&&(r=e.button<3?e.button:3)):r=1&e.buttons?0:4&e.buttons?1:2&e.buttons?2:3;break;case"mouseup":i=0,r=e.button<3?e.button:3;break;case"mousedown":i=1,r=e.button<3?e.button:3;break;case"wheel":0!==e.deltaY&&(i=e.deltaY<0?0:1),r=4;break;default:return !1}return !(void 0===i||void 0===r||r>4)&&t._coreMouseService.triggerMouseEvent({col:n.x-33,row:n.y-33,button:r,action:i,ctrl:e.ctrlKey,alt:e.altKey,shift:e.shiftKey})}var n={mouseup:null,wheel:null,mousedrag:null,mousemove:null},o=function(t){return i(t),t.buttons||(e._document.removeEventListener("mouseup",n.mouseup),n.mousedrag&&e._document.removeEventListener("mousemove",n.mousedrag)),e.cancel(t)},s=function(t){return i(t),t.preventDefault(),e.cancel(t)},a=function(e){e.buttons&&i(e);},l=function(e){e.buttons||i(e);};this.register(this._coreMouseService.onProtocolChange((function(t){t?("debug"===e.optionsService.options.logLevel&&e._logService.debug("Binding to mouse events:",e._coreMouseService.explainEvents(t)),e.element.classList.add("enable-mouse-events"),e._selectionService.disable()):(e._logService.debug("Unbinding from mouse events."),e.element.classList.remove("enable-mouse-events"),e._selectionService.enable()),8&t?n.mousemove||(r.addEventListener("mousemove",l),n.mousemove=l):(r.removeEventListener("mousemove",n.mousemove),n.mousemove=null),16&t?n.wheel||(r.addEventListener("wheel",s),n.wheel=s):(r.removeEventListener("wheel",n.wheel),n.wheel=null),2&t?n.mouseup||(n.mouseup=o):(e._document.removeEventListener("mouseup",n.mouseup),n.mouseup=null),4&t?n.mousedrag||(n.mousedrag=a):(e._document.removeEventListener("mousemove",n.mousedrag),n.mousedrag=null);}))),this._coreMouseService.activeProtocol=this._coreMouseService.activeProtocol,this.register(d.addDisposableDomListener(r,"mousedown",(function(t){if(t.preventDefault(),e.focus(),e._coreMouseService.areMouseEventsActive&&!e._selectionService.shouldForceSelection(t))return i(t),n.mouseup&&e._document.addEventListener("mouseup",n.mouseup),n.mousedrag&&e._document.addEventListener("mousemove",n.mousedrag),e.cancel(t)}))),this.register(d.addDisposableDomListener(r,"wheel",(function(t){if(n.wheel);else if(!e.buffer.hasScrollback){var r=e.viewport.getLinesScrolled(t);if(0===r)return;for(var i=c.C0.ESC+(e._coreService.decPrivateModes.applicationCursorKeys?"O":"[")+(t.deltaY<0?"A":"B"),o="",s=0;s<Math.abs(r);s++)o+=i;e._coreService.triggerDataEvent(o,!0);}}))),this.register(d.addDisposableDomListener(r,"wheel",(function(t){if(!n.wheel)return e.viewport.onWheel(t)?void 0:e.cancel(t)}))),this.register(d.addDisposableDomListener(r,"touchstart",(function(t){if(!e._coreMouseService.areMouseEventsActive)return e.viewport.onTouchStart(t),e.cancel(t)}))),this.register(d.addDisposableDomListener(r,"touchmove",(function(t){if(!e._coreMouseService.areMouseEventsActive)return e.viewport.onTouchMove(t)?void 0:e.cancel(t)})));},t.prototype.refresh=function(e,t){var r;null===(r=this._renderService)||void 0===r||r.refreshRows(e,t);},t.prototype._queueLinkification=function(e,t){var r;null===(r=this.linkifier)||void 0===r||r.linkifyRows(e,t);},t.prototype.updateCursorStyle=function(e){this._selectionService&&this._selectionService.shouldColumnSelect(e)?this.element.classList.add("column-select"):this.element.classList.remove("column-select");},t.prototype._showCursor=function(){this._coreService.isCursorInitialized||(this._coreService.isCursorInitialized=!0,this.refresh(this.buffer.y,this.buffer.y));},t.prototype.scrollLines=function(t,r){e.prototype.scrollLines.call(this,t,r),this.refresh(0,this.rows-1);},t.prototype.paste=function(e){a.paste(e,this.textarea,this._coreService);},t.prototype.attachCustomKeyEventHandler=function(e){this._customKeyEventHandler=e;},t.prototype.registerLinkMatcher=function(e,t,r){var i=this.linkifier.registerLinkMatcher(e,t,r);return this.refresh(0,this.rows-1),i},t.prototype.deregisterLinkMatcher=function(e){this.linkifier.deregisterLinkMatcher(e)&&this.refresh(0,this.rows-1);},t.prototype.registerLinkProvider=function(e){return this.linkifier2.registerLinkProvider(e)},t.prototype.registerCharacterJoiner=function(e){var t=this._renderService.registerCharacterJoiner(e);return this.refresh(0,this.rows-1),t},t.prototype.deregisterCharacterJoiner=function(e){this._renderService.deregisterCharacterJoiner(e)&&this.refresh(0,this.rows-1);},Object.defineProperty(t.prototype,"markers",{get:function(){return this.buffer.markers},enumerable:!1,configurable:!0}),t.prototype.addMarker=function(e){if(this.buffer===this.buffers.normal)return this.buffer.addMarker(this.buffer.ybase+this.buffer.y+e)},t.prototype.hasSelection=function(){return !!this._selectionService&&this._selectionService.hasSelection},t.prototype.select=function(e,t,r){this._selectionService.setSelection(e,t,r);},t.prototype.getSelection=function(){return this._selectionService?this._selectionService.selectionText:""},t.prototype.getSelectionPosition=function(){if(this._selectionService&&this._selectionService.hasSelection)return {startColumn:this._selectionService.selectionStart[0],startRow:this._selectionService.selectionStart[1],endColumn:this._selectionService.selectionEnd[0],endRow:this._selectionService.selectionEnd[1]}},t.prototype.clearSelection=function(){var e;null===(e=this._selectionService)||void 0===e||e.clearSelection();},t.prototype.selectAll=function(){var e;null===(e=this._selectionService)||void 0===e||e.selectAll();},t.prototype.selectLines=function(e,t){var r;null===(r=this._selectionService)||void 0===r||r.selectLines(e,t);},t.prototype._keyDown=function(e){if(this._keyDownHandled=!1,this._customKeyEventHandler&&!1===this._customKeyEventHandler(e))return !1;if(!this._compositionHelper.keydown(e))return this.buffer.ybase!==this.buffer.ydisp&&this.scrollToBottom(),!1;var t=S.evaluateKeyboardEvent(e,this._coreService.decPrivateModes.applicationCursorKeys,this.browser.isMac,this.options.macOptionIsMeta);if(this.updateCursorStyle(e),3===t.type||2===t.type){var r=this.rows-1;return this.scrollLines(2===t.type?-r:r),this.cancel(e,!0)}return 1===t.type&&this.selectAll(),!!this._isThirdLevelShift(this.browser,e)||(t.cancel&&this.cancel(e,!0),!t.key||(t.key!==c.C0.ETX&&t.key!==c.C0.CR||(this.textarea.value=""),this._onKey.fire({key:t.key,domEvent:e}),this._showCursor(),this._coreService.triggerDataEvent(t.key,!0),this.optionsService.options.screenReaderMode?void(this._keyDownHandled=!0):this.cancel(e,!0)))},t.prototype._isThirdLevelShift=function(e,t){var r=e.isMac&&!this.options.macOptionIsMeta&&t.altKey&&!t.ctrlKey&&!t.metaKey||e.isWindows&&t.altKey&&t.ctrlKey&&!t.metaKey;return "keypress"===t.type?r:r&&(!t.keyCode||t.keyCode>47)},t.prototype._keyUp=function(e){this._customKeyEventHandler&&!1===this._customKeyEventHandler(e)||(function(e){return 16===e.keyCode||17===e.keyCode||18===e.keyCode}(e)||this.focus(),this.updateCursorStyle(e));},t.prototype._keyPress=function(e){var t;if(this._keyDownHandled)return !1;if(this._customKeyEventHandler&&!1===this._customKeyEventHandler(e))return !1;if(this.cancel(e),e.charCode)t=e.charCode;else if(null===e.which||void 0===e.which)t=e.keyCode;else {if(0===e.which||0===e.charCode)return !1;t=e.which;}return !(!t||(e.altKey||e.ctrlKey||e.metaKey)&&!this._isThirdLevelShift(this.browser,e))&&(t=String.fromCharCode(t),this._onKey.fire({key:t,domEvent:e}),this._showCursor(),this._coreService.triggerDataEvent(t,!0),!0)},t.prototype.bell=function(){this._soundBell()&&this._soundService.playBellSound();},t.prototype.resize=function(t,r){t!==this.cols||r!==this.rows?e.prototype.resize.call(this,t,r):this._charSizeService&&!this._charSizeService.hasValidSize&&this._charSizeService.measure();},t.prototype._afterResize=function(e,t){var r,i;null===(r=this._charSizeService)||void 0===r||r.measure(),null===(i=this.viewport)||void 0===i||i.syncScrollArea(!0);},t.prototype.clear=function(){if(0!==this.buffer.ybase||0!==this.buffer.y){this.buffer.lines.set(0,this.buffer.lines.get(this.buffer.ybase+this.buffer.y)),this.buffer.lines.length=1,this.buffer.ydisp=0,this.buffer.ybase=0,this.buffer.y=0;for(var e=1;e<this.rows;e++)this.buffer.lines.push(this.buffer.getBlankLine(C.DEFAULT_ATTR_DATA));this.refresh(0,this.rows-1),this._onScroll.fire(this.buffer.ydisp);}},t.prototype.reset=function(){var t,r;this.options.rows=this.rows,this.options.cols=this.cols;var i=this._customKeyEventHandler;this._setup(),e.prototype.reset.call(this),null===(t=this._selectionService)||void 0===t||t.reset(),this._customKeyEventHandler=i,this.refresh(0,this.rows-1),null===(r=this.viewport)||void 0===r||r.syncScrollArea();},t.prototype._reportWindowsOptions=function(e){if(this._renderService)switch(e){case l.WindowsOptionsReportType.GET_WIN_SIZE_PIXELS:var t=this._renderService.dimensions.scaledCanvasWidth.toFixed(0),r=this._renderService.dimensions.scaledCanvasHeight.toFixed(0);this._coreService.triggerDataEvent(c.C0.ESC+"[4;"+r+";"+t+"t");break;case l.WindowsOptionsReportType.GET_CELL_SIZE_PIXELS:var i=this._renderService.dimensions.scaledCellWidth.toFixed(0),n=this._renderService.dimensions.scaledCellHeight.toFixed(0);this._coreService.triggerDataEvent(c.C0.ESC+"[6;"+n+";"+i+"t");}},t.prototype.cancel=function(e,t){if(this.options.cancelEvents||t)return e.preventDefault(),e.stopPropagation(),!1},t.prototype._visualBell=function(){return !1},t.prototype._soundBell=function(){return "sound"===this.options.bellStyle},t}(D.CoreTerminal);t.Terminal=O;},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.CompositionHelper=void 0;var o=r(5),s=r(1),a=function(){function e(e,t,r,i,n,o){this._textarea=e,this._compositionView=t,this._bufferService=r,this._optionsService=i,this._charSizeService=n,this._coreService=o,this._isComposing=!1,this._isSendingComposition=!1,this._compositionPosition={start:0,end:0};}return e.prototype.compositionstart=function(){this._isComposing=!0,this._compositionPosition.start=this._textarea.value.length,this._compositionView.textContent="",this._compositionView.classList.add("active");},e.prototype.compositionupdate=function(e){var t=this;this._compositionView.textContent=e.data,this.updateCompositionElements(),setTimeout((function(){t._compositionPosition.end=t._textarea.value.length;}),0);},e.prototype.compositionend=function(){this._finalizeComposition(!0);},e.prototype.keydown=function(e){if(this._isComposing||this._isSendingComposition){if(229===e.keyCode)return !1;if(16===e.keyCode||17===e.keyCode||18===e.keyCode)return !1;this._finalizeComposition(!1);}return 229!==e.keyCode||(this._handleAnyTextareaChanges(),!1)},e.prototype._finalizeComposition=function(e){var t=this;if(this._compositionView.classList.remove("active"),this._isComposing=!1,this._clearTextareaPosition(),e){var r={start:this._compositionPosition.start,end:this._compositionPosition.end};this._isSendingComposition=!0,setTimeout((function(){if(t._isSendingComposition){t._isSendingComposition=!1;var e=void 0;e=t._isComposing?t._textarea.value.substring(r.start,r.end):t._textarea.value.substring(r.start),t._coreService.triggerDataEvent(e,!0);}}),0);}else {this._isSendingComposition=!1;var i=this._textarea.value.substring(this._compositionPosition.start,this._compositionPosition.end);this._coreService.triggerDataEvent(i,!0);}},e.prototype._handleAnyTextareaChanges=function(){var e=this,t=this._textarea.value;setTimeout((function(){if(!e._isComposing){var r=e._textarea.value.replace(t,"");r.length>0&&e._coreService.triggerDataEvent(r,!0);}}),0);},e.prototype.updateCompositionElements=function(e){var t=this;if(this._isComposing){if(this._bufferService.buffer.isCursorInViewport){var r=Math.ceil(this._charSizeService.height*this._optionsService.options.lineHeight),i=this._bufferService.buffer.y*r,n=this._bufferService.buffer.x*this._charSizeService.width;this._compositionView.style.left=n+"px",this._compositionView.style.top=i+"px",this._compositionView.style.height=r+"px",this._compositionView.style.lineHeight=r+"px",this._compositionView.style.fontFamily=this._optionsService.options.fontFamily,this._compositionView.style.fontSize=this._optionsService.options.fontSize+"px";var o=this._compositionView.getBoundingClientRect();this._textarea.style.left=n+"px",this._textarea.style.top=i+"px",this._textarea.style.width=o.width+"px",this._textarea.style.height=o.height+"px",this._textarea.style.lineHeight=o.height+"px";}e||setTimeout((function(){return t.updateCompositionElements(!0)}),0);}},e.prototype._clearTextareaPosition=function(){this._textarea.style.left="",this._textarea.style.top="";},e=i([n(2,s.IBufferService),n(3,s.IOptionsService),n(4,o.ICharSizeService),n(5,s.ICoreService)],e)}();t.CompositionHelper=a;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.Viewport=void 0;var a=r(2),c=r(7),l=r(5),h=r(1),u=function(e){function t(t,r,i,n,o,s,a){var l=e.call(this)||this;return l._scrollLines=t,l._viewportElement=r,l._scrollArea=i,l._bufferService=n,l._optionsService=o,l._charSizeService=s,l._renderService=a,l.scrollBarWidth=0,l._currentRowHeight=0,l._lastRecordedBufferLength=0,l._lastRecordedViewportHeight=0,l._lastRecordedBufferHeight=0,l._lastTouchY=0,l._lastScrollTop=0,l._wheelPartialScroll=0,l._refreshAnimationFrame=null,l._ignoreNextScrollEvent=!1,l.scrollBarWidth=l._viewportElement.offsetWidth-l._scrollArea.offsetWidth||15,l.register(c.addDisposableDomListener(l._viewportElement,"scroll",l._onScroll.bind(l))),setTimeout((function(){return l.syncScrollArea()}),0),l}return n(t,e),t.prototype.onThemeChange=function(e){this._viewportElement.style.backgroundColor=e.background.css;},t.prototype._refresh=function(e){var t=this;if(e)return this._innerRefresh(),void(null!==this._refreshAnimationFrame&&cancelAnimationFrame(this._refreshAnimationFrame));null===this._refreshAnimationFrame&&(this._refreshAnimationFrame=requestAnimationFrame((function(){return t._innerRefresh()})));},t.prototype._innerRefresh=function(){if(this._charSizeService.height>0){this._currentRowHeight=this._renderService.dimensions.scaledCellHeight/window.devicePixelRatio,this._lastRecordedViewportHeight=this._viewportElement.offsetHeight;var e=Math.round(this._currentRowHeight*this._lastRecordedBufferLength)+(this._lastRecordedViewportHeight-this._renderService.dimensions.canvasHeight);this._lastRecordedBufferHeight!==e&&(this._lastRecordedBufferHeight=e,this._scrollArea.style.height=this._lastRecordedBufferHeight+"px");}var t=this._bufferService.buffer.ydisp*this._currentRowHeight;this._viewportElement.scrollTop!==t&&(this._ignoreNextScrollEvent=!0,this._viewportElement.scrollTop=t),this._refreshAnimationFrame=null;},t.prototype.syncScrollArea=function(e){if(void 0===e&&(e=!1),this._lastRecordedBufferLength!==this._bufferService.buffer.lines.length)return this._lastRecordedBufferLength=this._bufferService.buffer.lines.length,void this._refresh(e);if(this._lastRecordedViewportHeight===this._renderService.dimensions.canvasHeight){var t=this._bufferService.buffer.ydisp*this._currentRowHeight;this._lastScrollTop===t&&this._lastScrollTop===this._viewportElement.scrollTop&&this._renderService.dimensions.scaledCellHeight/window.devicePixelRatio===this._currentRowHeight||this._refresh(e);}else this._refresh(e);},t.prototype._onScroll=function(e){if(this._lastScrollTop=this._viewportElement.scrollTop,this._viewportElement.offsetParent)if(this._ignoreNextScrollEvent)this._ignoreNextScrollEvent=!1;else {var t=Math.round(this._lastScrollTop/this._currentRowHeight)-this._bufferService.buffer.ydisp;this._scrollLines(t,!0);}},t.prototype._bubbleScroll=function(e,t){var r=this._viewportElement.scrollTop+this._lastRecordedViewportHeight;return !(t<0&&0!==this._viewportElement.scrollTop||t>0&&r<this._lastRecordedBufferHeight)||(e.cancelable&&e.preventDefault(),!1)},t.prototype.onWheel=function(e){var t=this._getPixelsScrolled(e);return 0!==t&&(this._viewportElement.scrollTop+=t,this._bubbleScroll(e,t))},t.prototype._getPixelsScrolled=function(e){if(0===e.deltaY)return 0;var t=this._applyScrollModifier(e.deltaY,e);return e.deltaMode===WheelEvent.DOM_DELTA_LINE?t*=this._currentRowHeight:e.deltaMode===WheelEvent.DOM_DELTA_PAGE&&(t*=this._currentRowHeight*this._bufferService.rows),t},t.prototype.getLinesScrolled=function(e){if(0===e.deltaY)return 0;var t=this._applyScrollModifier(e.deltaY,e);return e.deltaMode===WheelEvent.DOM_DELTA_PIXEL?(t/=this._currentRowHeight+0,this._wheelPartialScroll+=t,t=Math.floor(Math.abs(this._wheelPartialScroll))*(this._wheelPartialScroll>0?1:-1),this._wheelPartialScroll%=1):e.deltaMode===WheelEvent.DOM_DELTA_PAGE&&(t*=this._bufferService.rows),t},t.prototype._applyScrollModifier=function(e,t){var r=this._optionsService.options.fastScrollModifier;return "alt"===r&&t.altKey||"ctrl"===r&&t.ctrlKey||"shift"===r&&t.shiftKey?e*this._optionsService.options.fastScrollSensitivity*this._optionsService.options.scrollSensitivity:e*this._optionsService.options.scrollSensitivity},t.prototype.onTouchStart=function(e){this._lastTouchY=e.touches[0].pageY;},t.prototype.onTouchMove=function(e){var t=this._lastTouchY-e.touches[0].pageY;return this._lastTouchY=e.touches[0].pageY,0!==t&&(this._viewportElement.scrollTop+=t,this._bubbleScroll(e,t))},t=o([s(3,h.IBufferService),s(4,h.IOptionsService),s(5,l.ICharSizeService),s(6,l.IRenderService)],t)}(a.Disposable);t.Viewport=u;},function(e,t,r){function i(e){return e.replace(/\r?\n/g,"\r")}function n(e,t){return t?"[200~"+e+"[201~":e}function o(e,t,r){e=n(e=i(e),r.decPrivateModes.bracketedPasteMode),r.triggerDataEvent(e,!0),t.value="";}function s(e,t,r){var i=r.getBoundingClientRect(),n=e.clientX-i.left-10,o=e.clientY-i.top-10;t.style.position="absolute",t.style.width="20px",t.style.height="20px",t.style.left=n+"px",t.style.top=o+"px",t.style.zIndex="1000",t.focus(),setTimeout((function(){t.style.position="",t.style.width="",t.style.height="",t.style.left="",t.style.top="",t.style.zIndex="";}),200);}Object.defineProperty(t,"__esModule",{value:!0}),t.rightClickHandler=t.moveTextAreaUnderMouseCursor=t.paste=t.handlePasteEvent=t.copyHandler=t.bracketTextForPaste=t.prepareTextForTerminal=void 0,t.prepareTextForTerminal=i,t.bracketTextForPaste=n,t.copyHandler=function(e,t){e.clipboardData&&e.clipboardData.setData("text/plain",t.selectionText),e.preventDefault();},t.handlePasteEvent=function(e,t,r){e.stopPropagation(),e.clipboardData&&o(e.clipboardData.getData("text/plain"),t,r);},t.paste=o,t.moveTextAreaUnderMouseCursor=s,t.rightClickHandler=function(e,t,r,i,n){s(e,t,r),n&&!i.isClickInSelection(e)&&i.selectWordAtCursor(e),t.value=i.selectionText,t.select();};},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.EscapeSequenceParser=t.VT500_TRANSITION_TABLE=t.TransitionTable=void 0;var o=r(2),s=r(15),a=r(20),c=r(21),l=r(23),h=function(){function e(e){this.table=new Uint8Array(e);}return e.prototype.setDefault=function(e,t){s.fill(this.table,e<<4|t);},e.prototype.add=function(e,t,r,i){this.table[t<<8|e]=r<<4|i;},e.prototype.addMany=function(e,t,r,i){for(var n=0;n<e.length;n++)this.table[t<<8|e[n]]=r<<4|i;},e}();t.TransitionTable=h;t.VT500_TRANSITION_TABLE=function(){var e=new h(4095),t=Array.apply(null,Array(256)).map((function(e,t){return t})),r=function(e,r){return t.slice(e,r)},i=r(32,127),n=r(0,24);n.push(25),n.push.apply(n,r(28,32));var o,s=r(0,14);for(o in e.setDefault(1,0),e.addMany(i,0,2,0),s)e.addMany([24,26,153,154],o,3,0),e.addMany(r(128,144),o,3,0),e.addMany(r(144,152),o,3,0),e.add(156,o,0,0),e.add(27,o,11,1),e.add(157,o,4,8),e.addMany([152,158,159],o,0,7),e.add(155,o,11,3),e.add(144,o,11,9);return e.addMany(n,0,3,0),e.addMany(n,1,3,1),e.add(127,1,0,1),e.addMany(n,8,0,8),e.addMany(n,3,3,3),e.add(127,3,0,3),e.addMany(n,4,3,4),e.add(127,4,0,4),e.addMany(n,6,3,6),e.addMany(n,5,3,5),e.add(127,5,0,5),e.addMany(n,2,3,2),e.add(127,2,0,2),e.add(93,1,4,8),e.addMany(i,8,5,8),e.add(127,8,5,8),e.addMany([156,27,24,26,7],8,6,0),e.addMany(r(28,32),8,0,8),e.addMany([88,94,95],1,0,7),e.addMany(i,7,0,7),e.addMany(n,7,0,7),e.add(156,7,0,0),e.add(127,7,0,7),e.add(91,1,11,3),e.addMany(r(64,127),3,7,0),e.addMany(r(48,60),3,8,4),e.addMany([60,61,62,63],3,9,4),e.addMany(r(48,60),4,8,4),e.addMany(r(64,127),4,7,0),e.addMany([60,61,62,63],4,0,6),e.addMany(r(32,64),6,0,6),e.add(127,6,0,6),e.addMany(r(64,127),6,0,0),e.addMany(r(32,48),3,9,5),e.addMany(r(32,48),5,9,5),e.addMany(r(48,64),5,0,6),e.addMany(r(64,127),5,7,0),e.addMany(r(32,48),4,9,5),e.addMany(r(32,48),1,9,2),e.addMany(r(32,48),2,9,2),e.addMany(r(48,127),2,10,0),e.addMany(r(48,80),1,10,0),e.addMany(r(81,88),1,10,0),e.addMany([89,90,92],1,10,0),e.addMany(r(96,127),1,10,0),e.add(80,1,11,9),e.addMany(n,9,0,9),e.add(127,9,0,9),e.addMany(r(28,32),9,0,9),e.addMany(r(32,48),9,9,12),e.addMany(r(48,60),9,8,10),e.addMany([60,61,62,63],9,9,10),e.addMany(n,11,0,11),e.addMany(r(32,128),11,0,11),e.addMany(r(28,32),11,0,11),e.addMany(n,10,0,10),e.add(127,10,0,10),e.addMany(r(28,32),10,0,10),e.addMany(r(48,60),10,8,10),e.addMany([60,61,62,63],10,0,11),e.addMany(r(32,48),10,9,12),e.addMany(n,12,0,12),e.add(127,12,0,12),e.addMany(r(28,32),12,0,12),e.addMany(r(32,48),12,9,12),e.addMany(r(48,64),12,0,11),e.addMany(r(64,127),12,12,13),e.addMany(r(64,127),10,12,13),e.addMany(r(64,127),9,12,13),e.addMany(n,13,13,13),e.addMany(i,13,13,13),e.add(127,13,0,13),e.addMany([27,156,24,26],13,14,0),e.add(160,0,2,0),e.add(160,8,5,8),e.add(160,6,0,6),e.add(160,11,0,11),e.add(160,13,13,13),e}();var u=function(e){function r(r){void 0===r&&(r=t.VT500_TRANSITION_TABLE);var i=e.call(this)||this;return i._transitions=r,i.initialState=0,i.currentState=i.initialState,i._params=new a.Params,i._params.addParam(0),i._collect=0,i.precedingCodepoint=0,i._printHandlerFb=function(e,t,r){},i._executeHandlerFb=function(e){},i._csiHandlerFb=function(e,t){},i._escHandlerFb=function(e){},i._errorHandlerFb=function(e){return e},i._printHandler=i._printHandlerFb,i._executeHandlers=Object.create(null),i._csiHandlers=Object.create(null),i._escHandlers=Object.create(null),i._oscParser=new c.OscParser,i._dcsParser=new l.DcsParser,i._errorHandler=i._errorHandlerFb,i.setEscHandler({final:"\\"},(function(){})),i}return n(r,e),r.prototype._identifier=function(e,t){void 0===t&&(t=[64,126]);var r=0;if(e.prefix){if(e.prefix.length>1)throw new Error("only one byte as prefix supported");if((r=e.prefix.charCodeAt(0))&&60>r||r>63)throw new Error("prefix must be in range 0x3c .. 0x3f")}if(e.intermediates){if(e.intermediates.length>2)throw new Error("only two bytes as intermediates are supported");for(var i=0;i<e.intermediates.length;++i){var n=e.intermediates.charCodeAt(i);if(32>n||n>47)throw new Error("intermediate must be in range 0x20 .. 0x2f");r<<=8,r|=n;}}if(1!==e.final.length)throw new Error("final must be a single byte");var o=e.final.charCodeAt(0);if(t[0]>o||o>t[1])throw new Error("final must be in range "+t[0]+" .. "+t[1]);return r<<=8,r|=o},r.prototype.identToString=function(e){for(var t=[];e;)t.push(String.fromCharCode(255&e)),e>>=8;return t.reverse().join("")},r.prototype.dispose=function(){this._csiHandlers=Object.create(null),this._executeHandlers=Object.create(null),this._escHandlers=Object.create(null),this._oscParser.dispose(),this._dcsParser.dispose();},r.prototype.setPrintHandler=function(e){this._printHandler=e;},r.prototype.clearPrintHandler=function(){this._printHandler=this._printHandlerFb;},r.prototype.addEscHandler=function(e,t){var r=this._identifier(e,[48,126]);void 0===this._escHandlers[r]&&(this._escHandlers[r]=[]);var i=this._escHandlers[r];return i.push(t),{dispose:function(){var e=i.indexOf(t);-1!==e&&i.splice(e,1);}}},r.prototype.setEscHandler=function(e,t){this._escHandlers[this._identifier(e,[48,126])]=[t];},r.prototype.clearEscHandler=function(e){this._escHandlers[this._identifier(e,[48,126])]&&delete this._escHandlers[this._identifier(e,[48,126])];},r.prototype.setEscHandlerFallback=function(e){this._escHandlerFb=e;},r.prototype.setExecuteHandler=function(e,t){this._executeHandlers[e.charCodeAt(0)]=t;},r.prototype.clearExecuteHandler=function(e){this._executeHandlers[e.charCodeAt(0)]&&delete this._executeHandlers[e.charCodeAt(0)];},r.prototype.setExecuteHandlerFallback=function(e){this._executeHandlerFb=e;},r.prototype.addCsiHandler=function(e,t){var r=this._identifier(e);void 0===this._csiHandlers[r]&&(this._csiHandlers[r]=[]);var i=this._csiHandlers[r];return i.push(t),{dispose:function(){var e=i.indexOf(t);-1!==e&&i.splice(e,1);}}},r.prototype.setCsiHandler=function(e,t){this._csiHandlers[this._identifier(e)]=[t];},r.prototype.clearCsiHandler=function(e){this._csiHandlers[this._identifier(e)]&&delete this._csiHandlers[this._identifier(e)];},r.prototype.setCsiHandlerFallback=function(e){this._csiHandlerFb=e;},r.prototype.addDcsHandler=function(e,t){return this._dcsParser.addHandler(this._identifier(e),t)},r.prototype.setDcsHandler=function(e,t){this._dcsParser.setHandler(this._identifier(e),t);},r.prototype.clearDcsHandler=function(e){this._dcsParser.clearHandler(this._identifier(e));},r.prototype.setDcsHandlerFallback=function(e){this._dcsParser.setHandlerFallback(e);},r.prototype.addOscHandler=function(e,t){return this._oscParser.addHandler(e,t)},r.prototype.setOscHandler=function(e,t){this._oscParser.setHandler(e,t);},r.prototype.clearOscHandler=function(e){this._oscParser.clearHandler(e);},r.prototype.setOscHandlerFallback=function(e){this._oscParser.setHandlerFallback(e);},r.prototype.setErrorHandler=function(e){this._errorHandler=e;},r.prototype.clearErrorHandler=function(){this._errorHandler=this._errorHandlerFb;},r.prototype.reset=function(){this.currentState=this.initialState,this._oscParser.reset(),this._dcsParser.reset(),this._params.reset(),this._params.addParam(0),this._collect=0,this.precedingCodepoint=0;},r.prototype.parse=function(e,t){for(var r=0,i=0,n=this.currentState,o=this._oscParser,s=this._dcsParser,a=this._collect,c=this._params,l=this._transitions.table,h=0;h<t;++h){switch((i=l[n<<8|((r=e[h])<160?r:160)])>>4){case 2:for(var u=h+1;;++u){if(u>=t||(r=e[u])<32||r>126&&r<160){this._printHandler(e,h,u),h=u-1;break}if(++u>=t||(r=e[u])<32||r>126&&r<160){this._printHandler(e,h,u),h=u-1;break}if(++u>=t||(r=e[u])<32||r>126&&r<160){this._printHandler(e,h,u),h=u-1;break}if(++u>=t||(r=e[u])<32||r>126&&r<160){this._printHandler(e,h,u),h=u-1;break}}break;case 3:this._executeHandlers[r]?this._executeHandlers[r]():this._executeHandlerFb(r),this.precedingCodepoint=0;break;case 0:break;case 1:if(this._errorHandler({position:h,code:r,currentState:n,collect:a,params:c,abort:!1}).abort)return;break;case 7:for(var f=this._csiHandlers[a<<8|r],_=f?f.length-1:-1;_>=0&&!1===f[_](c);_--);_<0&&this._csiHandlerFb(a<<8|r,c),this.precedingCodepoint=0;break;case 8:do{switch(r){case 59:c.addParam(0);break;case 58:c.addSubParam(-1);break;default:c.addDigit(r-48);}}while(++h<t&&(r=e[h])>47&&r<60);h--;break;case 9:a<<=8,a|=r;break;case 10:for(var d=this._escHandlers[a<<8|r],p=d?d.length-1:-1;p>=0&&!1===d[p]();p--);p<0&&this._escHandlerFb(a<<8|r),this.precedingCodepoint=0;break;case 11:c.reset(),c.addParam(0),a=0;break;case 12:s.hook(a<<8|r,c);break;case 13:for(var v=h+1;;++v)if(v>=t||24===(r=e[v])||26===r||27===r||r>127&&r<160){s.put(e,h,v),h=v-1;break}break;case 14:s.unhook(24!==r&&26!==r),27===r&&(i|=1),c.reset(),c.addParam(0),a=0,this.precedingCodepoint=0;break;case 4:o.start();break;case 5:for(var g=h+1;;g++)if(g>=t||(r=e[g])<32||r>127&&r<=159){o.put(e,h,g),h=g-1;break}break;case 6:o.end(24!==r&&26!==r),27===r&&(i|=1),c.reset(),c.addParam(0),a=0,this.precedingCodepoint=0;}n=15&i;}this._collect=a,this.currentState=n;},r}(o.Disposable);t.EscapeSequenceParser=u;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.Renderer=void 0;var a=r(40),c=r(46),l=r(47),h=r(48),u=r(28),f=r(2),_=r(5),d=r(1),p=r(24),v=r(0),g=1,y=function(e){function t(t,r,i,n,o,s,f,_,d){var p=e.call(this)||this;p._colors=t,p._screenElement=r,p._bufferService=o,p._charSizeService=s,p._optionsService=f,p._id=g++,p._onRequestRedraw=new v.EventEmitter;var y=p._optionsService.options.allowTransparency;return p._characterJoinerRegistry=new u.CharacterJoinerRegistry(p._bufferService),p._renderLayers=[new a.TextRenderLayer(p._screenElement,0,p._colors,p._characterJoinerRegistry,y,p._id,p._bufferService,f),new c.SelectionRenderLayer(p._screenElement,1,p._colors,p._id,p._bufferService,f),new h.LinkRenderLayer(p._screenElement,2,p._colors,p._id,i,n,p._bufferService,f),new l.CursorRenderLayer(p._screenElement,3,p._colors,p._id,p._onRequestRedraw,p._bufferService,f,_,d)],p.dimensions={scaledCharWidth:0,scaledCharHeight:0,scaledCellWidth:0,scaledCellHeight:0,scaledCharLeft:0,scaledCharTop:0,scaledCanvasWidth:0,scaledCanvasHeight:0,canvasWidth:0,canvasHeight:0,actualCellWidth:0,actualCellHeight:0},p._devicePixelRatio=window.devicePixelRatio,p._updateDimensions(),p.onOptionsChanged(),p}return n(t,e),Object.defineProperty(t.prototype,"onRequestRedraw",{get:function(){return this._onRequestRedraw.event},enumerable:!1,configurable:!0}),t.prototype.dispose=function(){this._renderLayers.forEach((function(e){return e.dispose()})),e.prototype.dispose.call(this),p.removeTerminalFromCache(this._id);},t.prototype.onDevicePixelRatioChange=function(){this._devicePixelRatio!==window.devicePixelRatio&&(this._devicePixelRatio=window.devicePixelRatio,this.onResize(this._bufferService.cols,this._bufferService.rows));},t.prototype.setColors=function(e){var t=this;this._colors=e,this._renderLayers.forEach((function(e){e.setColors(t._colors),e.reset();}));},t.prototype.onResize=function(e,t){var r=this;this._updateDimensions(),this._renderLayers.forEach((function(e){return e.resize(r.dimensions)})),this._screenElement.style.width=this.dimensions.canvasWidth+"px",this._screenElement.style.height=this.dimensions.canvasHeight+"px";},t.prototype.onCharSizeChanged=function(){this.onResize(this._bufferService.cols,this._bufferService.rows);},t.prototype.onBlur=function(){this._runOperation((function(e){return e.onBlur()}));},t.prototype.onFocus=function(){this._runOperation((function(e){return e.onFocus()}));},t.prototype.onSelectionChanged=function(e,t,r){void 0===r&&(r=!1),this._runOperation((function(i){return i.onSelectionChanged(e,t,r)}));},t.prototype.onCursorMove=function(){this._runOperation((function(e){return e.onCursorMove()}));},t.prototype.onOptionsChanged=function(){this._runOperation((function(e){return e.onOptionsChanged()}));},t.prototype.clear=function(){this._runOperation((function(e){return e.reset()}));},t.prototype._runOperation=function(e){this._renderLayers.forEach((function(t){return e(t)}));},t.prototype.renderRows=function(e,t){this._renderLayers.forEach((function(r){return r.onGridChanged(e,t)}));},t.prototype._updateDimensions=function(){this._charSizeService.hasValidSize&&(this.dimensions.scaledCharWidth=Math.floor(this._charSizeService.width*window.devicePixelRatio),this.dimensions.scaledCharHeight=Math.ceil(this._charSizeService.height*window.devicePixelRatio),this.dimensions.scaledCellHeight=Math.floor(this.dimensions.scaledCharHeight*this._optionsService.options.lineHeight),this.dimensions.scaledCharTop=1===this._optionsService.options.lineHeight?0:Math.round((this.dimensions.scaledCellHeight-this.dimensions.scaledCharHeight)/2),this.dimensions.scaledCellWidth=this.dimensions.scaledCharWidth+Math.round(this._optionsService.options.letterSpacing),this.dimensions.scaledCharLeft=Math.floor(this._optionsService.options.letterSpacing/2),this.dimensions.scaledCanvasHeight=this._bufferService.rows*this.dimensions.scaledCellHeight,this.dimensions.scaledCanvasWidth=this._bufferService.cols*this.dimensions.scaledCellWidth,this.dimensions.canvasHeight=Math.round(this.dimensions.scaledCanvasHeight/window.devicePixelRatio),this.dimensions.canvasWidth=Math.round(this.dimensions.scaledCanvasWidth/window.devicePixelRatio),this.dimensions.actualCellHeight=this.dimensions.canvasHeight/this._bufferService.rows,this.dimensions.actualCellWidth=this.dimensions.canvasWidth/this._bufferService.cols);},t.prototype.registerCharacterJoiner=function(e){return this._characterJoinerRegistry.registerCharacterJoiner(e)},t.prototype.deregisterCharacterJoiner=function(e){return this._characterJoinerRegistry.deregisterCharacterJoiner(e)},t=o([s(4,d.IBufferService),s(5,_.ICharSizeService),s(6,d.IOptionsService),s(7,d.ICoreService),s(8,_.ICoreBrowserService)],t)}(f.Disposable);t.Renderer=y;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.TextRenderLayer=void 0;var o=r(41),s=r(13),a=r(6),c=r(3),l=r(28),h=r(4),u=function(e){function t(t,r,i,n,s,a,c,l){var u=e.call(this,t,"text",r,s,i,a,c,l)||this;return u._characterWidth=0,u._characterFont="",u._characterOverlapCache={},u._workCell=new h.CellData,u._state=new o.GridCache,u._characterJoinerRegistry=n,u}return n(t,e),t.prototype.resize=function(t){e.prototype.resize.call(this,t);var r=this._getFont(!1,!1);this._characterWidth===t.scaledCharWidth&&this._characterFont===r||(this._characterWidth=t.scaledCharWidth,this._characterFont=r,this._characterOverlapCache={}),this._state.clear(),this._state.resize(this._bufferService.cols,this._bufferService.rows);},t.prototype.reset=function(){this._state.clear(),this._clearAll();},t.prototype._forEachCell=function(e,t,r,i){for(var n=e;n<=t;n++)for(var o=n+this._bufferService.buffer.ydisp,s=this._bufferService.buffer.lines.get(o),a=r?r.getJoinedCharacters(o):[],h=0;h<this._bufferService.cols;h++){s.loadCell(h,this._workCell);var u=this._workCell,f=!1,_=h;if(0!==u.getWidth()){if(a.length>0&&h===a[0][0]){f=!0;var d=a.shift();u=new l.JoinedCellData(this._workCell,s.translateToString(!0,d[0],d[1]),d[1]-d[0]),_=d[1]-1;}!f&&this._isOverlapping(u)&&_<s.length-1&&s.getCodePoint(_+1)===c.NULL_CELL_CODE&&(u.content&=-12582913,u.content|=2<<22),i(u,h,n),h=_;}}},t.prototype._drawBackground=function(e,t){var r=this,i=this._ctx,n=this._bufferService.cols,o=0,s=0,c=null;i.save(),this._forEachCell(e,t,null,(function(e,t,l){var h=null;e.isInverse()?h=e.isFgDefault()?r._colors.foreground.css:e.isFgRGB()?"rgb("+a.AttributeData.toColorRGB(e.getFgColor()).join(",")+")":r._colors.ansi[e.getFgColor()].css:e.isBgRGB()?h="rgb("+a.AttributeData.toColorRGB(e.getBgColor()).join(",")+")":e.isBgPalette()&&(h=r._colors.ansi[e.getBgColor()].css),null===c&&(o=t,s=l),l!==s?(i.fillStyle=c||"",r._fillCells(o,s,n-o,1),o=t,s=l):c!==h&&(i.fillStyle=c||"",r._fillCells(o,s,t-o,1),o=t,s=l),c=h;})),null!==c&&(i.fillStyle=c,this._fillCells(o,s,n-o,1)),i.restore();},t.prototype._drawForeground=function(e,t){var r=this;this._forEachCell(e,t,this._characterJoinerRegistry,(function(e,t,i){if(!e.isInvisible()&&(r._drawChars(e,t,i),e.isUnderline())){if(r._ctx.save(),e.isInverse())if(e.isBgDefault())r._ctx.fillStyle=r._colors.background.css;else if(e.isBgRGB())r._ctx.fillStyle="rgb("+a.AttributeData.toColorRGB(e.getBgColor()).join(",")+")";else {var n=e.getBgColor();r._optionsService.options.drawBoldTextInBrightColors&&e.isBold()&&n<8&&(n+=8),r._ctx.fillStyle=r._colors.ansi[n].css;}else if(e.isFgDefault())r._ctx.fillStyle=r._colors.foreground.css;else if(e.isFgRGB())r._ctx.fillStyle="rgb("+a.AttributeData.toColorRGB(e.getFgColor()).join(",")+")";else {var o=e.getFgColor();r._optionsService.options.drawBoldTextInBrightColors&&e.isBold()&&o<8&&(o+=8),r._ctx.fillStyle=r._colors.ansi[o].css;}r._fillBottomLineAtCells(t,i,e.getWidth()),r._ctx.restore();}}));},t.prototype.onGridChanged=function(e,t){0!==this._state.cache.length&&(this._charAtlas&&this._charAtlas.beginFrame(),this._clearCells(0,e,this._bufferService.cols,t-e+1),this._drawBackground(e,t),this._drawForeground(e,t));},t.prototype.onOptionsChanged=function(){this._setTransparency(this._optionsService.options.allowTransparency);},t.prototype._isOverlapping=function(e){if(1!==e.getWidth())return !1;if(e.getCode()<256)return !1;var t=e.getChars();if(this._characterOverlapCache.hasOwnProperty(t))return this._characterOverlapCache[t];this._ctx.save(),this._ctx.font=this._characterFont;var r=Math.floor(this._ctx.measureText(t).width)>this._characterWidth;return this._ctx.restore(),this._characterOverlapCache[t]=r,r},t}(s.BaseRenderLayer);t.TextRenderLayer=u;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.GridCache=void 0;var i=function(){function e(){this.cache=[];}return e.prototype.resize=function(e,t){for(var r=0;r<e;r++){this.cache.length<=r&&this.cache.push([]);for(var i=this.cache[r].length;i<t;i++)this.cache[r].push(void 0);this.cache[r].length=t;}this.cache.length=e;},e.prototype.clear=function(){for(var e=0;e<this.cache.length;e++)for(var t=0;t<this.cache[e].length;t++)this.cache[e][t]=void 0;},e}();t.GridCache=i;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.NoneCharAtlas=t.DynamicCharAtlas=t.getGlyphCacheKey=void 0;var o=r(9),s=r(43),a=r(26),c=r(45),l=r(11),h=r(27),u=r(10),f={css:"rgba(0, 0, 0, 0)",rgba:0};function _(e){return e.code<<21|e.bg<<12|e.fg<<3|(e.bold?0:4)+(e.dim?0:2)+(e.italic?0:1)}t.getGlyphCacheKey=_;var d=function(e){function t(t,r){var i=e.call(this)||this;i._config=r,i._drawToCacheCount=0,i._glyphsWaitingOnBitmap=[],i._bitmapCommitTimeout=null,i._bitmap=null,i._cacheCanvas=t.createElement("canvas"),i._cacheCanvas.width=1024,i._cacheCanvas.height=1024,i._cacheCtx=h.throwIfFalsy(i._cacheCanvas.getContext("2d",{alpha:!0}));var n=t.createElement("canvas");n.width=i._config.scaledCharWidth,n.height=i._config.scaledCharHeight,i._tmpCtx=h.throwIfFalsy(n.getContext("2d",{alpha:i._config.allowTransparency})),i._width=Math.floor(1024/i._config.scaledCharWidth),i._height=Math.floor(1024/i._config.scaledCharHeight);var o=i._width*i._height;return i._cacheMap=new c.LRUMap(o),i._cacheMap.prealloc(o),i}return n(t,e),t.prototype.dispose=function(){null!==this._bitmapCommitTimeout&&(window.clearTimeout(this._bitmapCommitTimeout),this._bitmapCommitTimeout=null);},t.prototype.beginFrame=function(){this._drawToCacheCount=0;},t.prototype.draw=function(e,t,r,i){if(32===t.code)return !0;if(!this._canCache(t))return !1;var n=_(t),o=this._cacheMap.get(n);if(null!=o)return this._drawFromCache(e,o,r,i),!0;if(this._drawToCacheCount<100){var s=void 0;s=this._cacheMap.size<this._cacheMap.capacity?this._cacheMap.size:this._cacheMap.peek().index;var a=this._drawToCache(t,s);return this._cacheMap.set(n,a),this._drawFromCache(e,a,r,i),!0}return !1},t.prototype._canCache=function(e){return e.code<256},t.prototype._toCoordinateX=function(e){return e%this._width*this._config.scaledCharWidth},t.prototype._toCoordinateY=function(e){return Math.floor(e/this._width)*this._config.scaledCharHeight},t.prototype._drawFromCache=function(e,t,r,i){if(!t.isEmpty){var n=this._toCoordinateX(t.index),o=this._toCoordinateY(t.index);e.drawImage(t.inBitmap?this._bitmap:this._cacheCanvas,n,o,this._config.scaledCharWidth,this._config.scaledCharHeight,r,i,this._config.scaledCharWidth,this._config.scaledCharHeight);}},t.prototype._getColorFromAnsiIndex=function(e){return e<this._config.colors.ansi.length?this._config.colors.ansi[e]:a.DEFAULT_ANSI_COLORS[e]},t.prototype._getBackgroundColor=function(e){return this._config.allowTransparency?f:e.bg===o.INVERTED_DEFAULT_COLOR?this._config.colors.foreground:e.bg<256?this._getColorFromAnsiIndex(e.bg):this._config.colors.background},t.prototype._getForegroundColor=function(e){return e.fg===o.INVERTED_DEFAULT_COLOR?u.color.opaque(this._config.colors.background):e.fg<256?this._getColorFromAnsiIndex(e.fg):this._config.colors.foreground},t.prototype._drawToCache=function(e,t){this._drawToCacheCount++,this._tmpCtx.save();var r=this._getBackgroundColor(e);this._tmpCtx.globalCompositeOperation="copy",this._tmpCtx.fillStyle=r.css,this._tmpCtx.fillRect(0,0,this._config.scaledCharWidth,this._config.scaledCharHeight),this._tmpCtx.globalCompositeOperation="source-over";var i=e.bold?this._config.fontWeightBold:this._config.fontWeight,n=e.italic?"italic":"";this._tmpCtx.font=n+" "+i+" "+this._config.fontSize*this._config.devicePixelRatio+"px "+this._config.fontFamily,this._tmpCtx.textBaseline="middle",this._tmpCtx.fillStyle=this._getForegroundColor(e).css,e.dim&&(this._tmpCtx.globalAlpha=o.DIM_OPACITY),this._tmpCtx.fillText(e.chars,0,this._config.scaledCharHeight/2),this._tmpCtx.restore();var s=this._tmpCtx.getImageData(0,0,this._config.scaledCharWidth,this._config.scaledCharHeight),a=!1;this._config.allowTransparency||(a=function(e,t){for(var r=!0,i=t.rgba>>>24,n=t.rgba>>>16&255,o=t.rgba>>>8&255,s=0;s<e.data.length;s+=4)e.data[s]===i&&e.data[s+1]===n&&e.data[s+2]===o?e.data[s+3]=0:r=!1;return r}(s,r));var c=this._toCoordinateX(t),l=this._toCoordinateY(t);this._cacheCtx.putImageData(s,c,l);var h={index:t,isEmpty:a,inBitmap:!1};return this._addGlyphToBitmap(h),h},t.prototype._addGlyphToBitmap=function(e){var t=this;!("createImageBitmap"in window)||l.isFirefox||l.isSafari||(this._glyphsWaitingOnBitmap.push(e),null===this._bitmapCommitTimeout&&(this._bitmapCommitTimeout=window.setTimeout((function(){return t._generateBitmap()}),100)));},t.prototype._generateBitmap=function(){var e=this,t=this._glyphsWaitingOnBitmap;this._glyphsWaitingOnBitmap=[],window.createImageBitmap(this._cacheCanvas).then((function(r){e._bitmap=r;for(var i=0;i<t.length;i++){t[i].inBitmap=!0;}})),this._bitmapCommitTimeout=null;},t}(s.BaseCharAtlas);t.DynamicCharAtlas=d;var p=function(e){function t(t,r){return e.call(this)||this}return n(t,e),t.prototype.draw=function(e,t,r,i){return !1},t}(s.BaseCharAtlas);t.NoneCharAtlas=p;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.BaseCharAtlas=void 0;var i=function(){function e(){this._didWarmUp=!1;}return e.prototype.dispose=function(){},e.prototype.warmUp=function(){this._didWarmUp||(this._doWarmUp(),this._didWarmUp=!0);},e.prototype._doWarmUp=function(){},e.prototype.beginFrame=function(){},e}();t.BaseCharAtlas=i;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.ColorContrastCache=void 0;var i=function(){function e(){this._color={},this._rgba={};}return e.prototype.clear=function(){this._color={},this._rgba={};},e.prototype.setCss=function(e,t,r){this._rgba[e]||(this._rgba[e]={}),this._rgba[e][t]=r;},e.prototype.getCss=function(e,t){return this._rgba[e]?this._rgba[e][t]:void 0},e.prototype.setColor=function(e,t,r){this._color[e]||(this._color[e]={}),this._color[e][t]=r;},e.prototype.getColor=function(e,t){return this._color[e]?this._color[e][t]:void 0},e}();t.ColorContrastCache=i;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.LRUMap=void 0;var i=function(){function e(e){this.capacity=e,this._map={},this._head=null,this._tail=null,this._nodePool=[],this.size=0;}return e.prototype._unlinkNode=function(e){var t=e.prev,r=e.next;e===this._head&&(this._head=r),e===this._tail&&(this._tail=t),null!==t&&(t.next=r),null!==r&&(r.prev=t);},e.prototype._appendNode=function(e){var t=this._tail;null!==t&&(t.next=e),e.prev=t,e.next=null,this._tail=e,null===this._head&&(this._head=e);},e.prototype.prealloc=function(e){for(var t=this._nodePool,r=0;r<e;r++)t.push({prev:null,next:null,key:null,value:null});},e.prototype.get=function(e){var t=this._map[e];return void 0!==t?(this._unlinkNode(t),this._appendNode(t),t.value):null},e.prototype.peekValue=function(e){var t=this._map[e];return void 0!==t?t.value:null},e.prototype.peek=function(){var e=this._head;return null===e?null:e.value},e.prototype.set=function(e,t){var r=this._map[e];if(void 0!==r)r=this._map[e],this._unlinkNode(r),r.value=t;else if(this.size>=this.capacity)r=this._head,this._unlinkNode(r),delete this._map[r.key],r.key=e,r.value=t,this._map[e]=r;else {var i=this._nodePool;i.length>0?((r=i.pop()).key=e,r.value=t):r={prev:null,next:null,key:e,value:t},this._map[e]=r,this.size++;}this._appendNode(r);},e}();t.LRUMap=i;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.SelectionRenderLayer=void 0;var o=function(e){function t(t,r,i,n,o,s){var a=e.call(this,t,"selection",r,!0,i,n,o,s)||this;return a._clearState(),a}return n(t,e),t.prototype._clearState=function(){this._state={start:void 0,end:void 0,columnSelectMode:void 0,ydisp:void 0};},t.prototype.resize=function(t){e.prototype.resize.call(this,t),this._clearState();},t.prototype.reset=function(){this._state.start&&this._state.end&&(this._clearState(),this._clearAll());},t.prototype.onSelectionChanged=function(e,t,r){if(this._didStateChange(e,t,r,this._bufferService.buffer.ydisp))if(this._clearAll(),e&&t){var i=e[1]-this._bufferService.buffer.ydisp,n=t[1]-this._bufferService.buffer.ydisp,o=Math.max(i,0),s=Math.min(n,this._bufferService.rows-1);if(!(o>=this._bufferService.rows||s<0)){if(this._ctx.fillStyle=this._colors.selection.css,r){var a=e[0],c=t[0]-a,l=s-o+1;this._fillCells(a,o,c,l);}else {a=i===o?e[0]:0;var h=o===s?t[0]:this._bufferService.cols;this._fillCells(a,o,h-a,1);var u=Math.max(s-o-1,0);if(this._fillCells(0,o+1,this._bufferService.cols,u),o!==s){var f=n===s?t[0]:this._bufferService.cols;this._fillCells(0,s,f,1);}}this._state.start=[e[0],e[1]],this._state.end=[t[0],t[1]],this._state.columnSelectMode=r,this._state.ydisp=this._bufferService.buffer.ydisp;}}else this._clearState();},t.prototype._didStateChange=function(e,t,r,i){return !this._areCoordinatesEqual(e,this._state.start)||!this._areCoordinatesEqual(t,this._state.end)||r!==this._state.columnSelectMode||i!==this._state.ydisp},t.prototype._areCoordinatesEqual=function(e,t){return !(!e||!t)&&(e[0]===t[0]&&e[1]===t[1])},t}(r(13).BaseRenderLayer);t.SelectionRenderLayer=o;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.CursorRenderLayer=void 0;var o=r(13),s=r(4),a=function(e){function t(t,r,i,n,o,a,c,l,h){var u=e.call(this,t,"cursor",r,!0,i,n,a,c)||this;return u._onRequestRedraw=o,u._coreService=l,u._coreBrowserService=h,u._cell=new s.CellData,u._state={x:0,y:0,isFocused:!1,style:"",width:0},u._cursorRenderers={bar:u._renderBarCursor.bind(u),block:u._renderBlockCursor.bind(u),underline:u._renderUnderlineCursor.bind(u)},u}return n(t,e),t.prototype.resize=function(t){e.prototype.resize.call(this,t),this._state={x:0,y:0,isFocused:!1,style:"",width:0};},t.prototype.reset=function(){this._clearCursor(),this._cursorBlinkStateManager&&(this._cursorBlinkStateManager.dispose(),this._cursorBlinkStateManager=void 0,this.onOptionsChanged());},t.prototype.onBlur=function(){this._cursorBlinkStateManager&&this._cursorBlinkStateManager.pause(),this._onRequestRedraw.fire({start:this._bufferService.buffer.y,end:this._bufferService.buffer.y});},t.prototype.onFocus=function(){this._cursorBlinkStateManager?this._cursorBlinkStateManager.resume():this._onRequestRedraw.fire({start:this._bufferService.buffer.y,end:this._bufferService.buffer.y});},t.prototype.onOptionsChanged=function(){var e,t=this;this._optionsService.options.cursorBlink?this._cursorBlinkStateManager||(this._cursorBlinkStateManager=new c(this._coreBrowserService.isFocused,(function(){t._render(!0);}))):(null===(e=this._cursorBlinkStateManager)||void 0===e||e.dispose(),this._cursorBlinkStateManager=void 0),this._onRequestRedraw.fire({start:this._bufferService.buffer.y,end:this._bufferService.buffer.y});},t.prototype.onCursorMove=function(){this._cursorBlinkStateManager&&this._cursorBlinkStateManager.restartBlinkAnimation();},t.prototype.onGridChanged=function(e,t){!this._cursorBlinkStateManager||this._cursorBlinkStateManager.isPaused?this._render(!1):this._cursorBlinkStateManager.restartBlinkAnimation();},t.prototype._render=function(e){if(this._coreService.isCursorInitialized&&!this._coreService.isCursorHidden){var t=this._bufferService.buffer.ybase+this._bufferService.buffer.y,r=t-this._bufferService.buffer.ydisp;if(r<0||r>=this._bufferService.rows)this._clearCursor();else {var i=Math.min(this._bufferService.buffer.x,this._bufferService.cols-1);if(this._bufferService.buffer.lines.get(t).loadCell(i,this._cell),void 0!==this._cell.content){if(!this._coreBrowserService.isFocused){this._clearCursor(),this._ctx.save(),this._ctx.fillStyle=this._colors.cursor.css;var n=this._optionsService.options.cursorStyle;return n&&"block"!==n?this._cursorRenderers[n](i,r,this._cell):this._renderBlurCursor(i,r,this._cell),this._ctx.restore(),this._state.x=i,this._state.y=r,this._state.isFocused=!1,this._state.style=n,void(this._state.width=this._cell.getWidth())}if(!this._cursorBlinkStateManager||this._cursorBlinkStateManager.isCursorVisible){if(this._state){if(this._state.x===i&&this._state.y===r&&this._state.isFocused===this._coreBrowserService.isFocused&&this._state.style===this._optionsService.options.cursorStyle&&this._state.width===this._cell.getWidth())return;this._clearCursor();}this._ctx.save(),this._cursorRenderers[this._optionsService.options.cursorStyle||"block"](i,r,this._cell),this._ctx.restore(),this._state.x=i,this._state.y=r,this._state.isFocused=!1,this._state.style=this._optionsService.options.cursorStyle,this._state.width=this._cell.getWidth();}else this._clearCursor();}}}else this._clearCursor();},t.prototype._clearCursor=function(){this._state&&(this._clearCells(this._state.x,this._state.y,this._state.width,1),this._state={x:0,y:0,isFocused:!1,style:"",width:0});},t.prototype._renderBarCursor=function(e,t,r){this._ctx.save(),this._ctx.fillStyle=this._colors.cursor.css,this._fillLeftLineAtCell(e,t,this._optionsService.options.cursorWidth),this._ctx.restore();},t.prototype._renderBlockCursor=function(e,t,r){this._ctx.save(),this._ctx.fillStyle=this._colors.cursor.css,this._fillCells(e,t,r.getWidth(),1),this._ctx.fillStyle=this._colors.cursorAccent.css,this._fillCharTrueColor(r,e,t),this._ctx.restore();},t.prototype._renderUnderlineCursor=function(e,t,r){this._ctx.save(),this._ctx.fillStyle=this._colors.cursor.css,this._fillBottomLineAtCells(e,t),this._ctx.restore();},t.prototype._renderBlurCursor=function(e,t,r){this._ctx.save(),this._ctx.strokeStyle=this._colors.cursor.css,this._strokeRectAtCell(e,t,r.getWidth(),1),this._ctx.restore();},t}(o.BaseRenderLayer);t.CursorRenderLayer=a;var c=function(){function e(e,t){this._renderCallback=t,this.isCursorVisible=!0,e&&this._restartInterval();}return Object.defineProperty(e.prototype,"isPaused",{get:function(){return !(this._blinkStartTimeout||this._blinkInterval)},enumerable:!1,configurable:!0}),e.prototype.dispose=function(){this._blinkInterval&&(window.clearInterval(this._blinkInterval),this._blinkInterval=void 0),this._blinkStartTimeout&&(window.clearTimeout(this._blinkStartTimeout),this._blinkStartTimeout=void 0),this._animationFrame&&(window.cancelAnimationFrame(this._animationFrame),this._animationFrame=void 0);},e.prototype.restartBlinkAnimation=function(){var e=this;this.isPaused||(this._animationTimeRestarted=Date.now(),this.isCursorVisible=!0,this._animationFrame||(this._animationFrame=window.requestAnimationFrame((function(){e._renderCallback(),e._animationFrame=void 0;}))));},e.prototype._restartInterval=function(e){var t=this;void 0===e&&(e=600),this._blinkInterval&&window.clearInterval(this._blinkInterval),this._blinkStartTimeout=window.setTimeout((function(){if(t._animationTimeRestarted){var e=600-(Date.now()-t._animationTimeRestarted);if(t._animationTimeRestarted=void 0,e>0)return void t._restartInterval(e)}t.isCursorVisible=!1,t._animationFrame=window.requestAnimationFrame((function(){t._renderCallback(),t._animationFrame=void 0;})),t._blinkInterval=window.setInterval((function(){if(t._animationTimeRestarted){var e=600-(Date.now()-t._animationTimeRestarted);return t._animationTimeRestarted=void 0,void t._restartInterval(e)}t.isCursorVisible=!t.isCursorVisible,t._animationFrame=window.requestAnimationFrame((function(){t._renderCallback(),t._animationFrame=void 0;}));}),600);}),e);},e.prototype.pause=function(){this.isCursorVisible=!0,this._blinkInterval&&(window.clearInterval(this._blinkInterval),this._blinkInterval=void 0),this._blinkStartTimeout&&(window.clearTimeout(this._blinkStartTimeout),this._blinkStartTimeout=void 0),this._animationFrame&&(window.cancelAnimationFrame(this._animationFrame),this._animationFrame=void 0);},e.prototype.resume=function(){this.pause(),this._animationTimeRestarted=void 0,this._restartInterval(),this.restartBlinkAnimation();},e}();},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.LinkRenderLayer=void 0;var o=r(13),s=r(9),a=r(25),c=function(e){function t(t,r,i,n,o,s,a,c){var l=e.call(this,t,"link",r,!0,i,n,a,c)||this;return o.onShowLinkUnderline((function(e){return l._onShowLinkUnderline(e)})),o.onHideLinkUnderline((function(e){return l._onHideLinkUnderline(e)})),s.onShowLinkUnderline((function(e){return l._onShowLinkUnderline(e)})),s.onHideLinkUnderline((function(e){return l._onHideLinkUnderline(e)})),l}return n(t,e),t.prototype.resize=function(t){e.prototype.resize.call(this,t),this._state=void 0;},t.prototype.reset=function(){this._clearCurrentLink();},t.prototype._clearCurrentLink=function(){if(this._state){this._clearCells(this._state.x1,this._state.y1,this._state.cols-this._state.x1,1);var e=this._state.y2-this._state.y1-1;e>0&&this._clearCells(0,this._state.y1+1,this._state.cols,e),this._clearCells(0,this._state.y2,this._state.x2,1),this._state=void 0;}},t.prototype._onShowLinkUnderline=function(e){if(e.fg===s.INVERTED_DEFAULT_COLOR?this._ctx.fillStyle=this._colors.background.css:e.fg&&a.is256Color(e.fg)?this._ctx.fillStyle=this._colors.ansi[e.fg].css:this._ctx.fillStyle=this._colors.foreground.css,e.y1===e.y2)this._fillBottomLineAtCells(e.x1,e.y1,e.x2-e.x1);else {this._fillBottomLineAtCells(e.x1,e.y1,e.cols-e.x1);for(var t=e.y1+1;t<e.y2;t++)this._fillBottomLineAtCells(0,t,e.cols);this._fillBottomLineAtCells(0,e.y2,e.x2);}this._state=e;},t.prototype._onHideLinkUnderline=function(e){this._clearCurrentLink();},t}(o.BaseRenderLayer);t.LinkRenderLayer=c;},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.MouseZone=t.Linkifier=void 0;var o=r(0),s=r(1),a=function(){function e(e,t,r){this._bufferService=e,this._logService=t,this._unicodeService=r,this._linkMatchers=[],this._nextLinkMatcherId=0,this._onShowLinkUnderline=new o.EventEmitter,this._onHideLinkUnderline=new o.EventEmitter,this._onLinkTooltip=new o.EventEmitter,this._rowsToLinkify={start:void 0,end:void 0};}return Object.defineProperty(e.prototype,"onShowLinkUnderline",{get:function(){return this._onShowLinkUnderline.event},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onHideLinkUnderline",{get:function(){return this._onHideLinkUnderline.event},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onLinkTooltip",{get:function(){return this._onLinkTooltip.event},enumerable:!1,configurable:!0}),e.prototype.attachToDom=function(e,t){this._element=e,this._mouseZoneManager=t;},e.prototype.linkifyRows=function(t,r){var i=this;this._mouseZoneManager&&(void 0===this._rowsToLinkify.start||void 0===this._rowsToLinkify.end?(this._rowsToLinkify.start=t,this._rowsToLinkify.end=r):(this._rowsToLinkify.start=Math.min(this._rowsToLinkify.start,t),this._rowsToLinkify.end=Math.max(this._rowsToLinkify.end,r)),this._mouseZoneManager.clearAll(t,r),this._rowsTimeoutId&&clearTimeout(this._rowsTimeoutId),this._rowsTimeoutId=setTimeout((function(){return i._linkifyRows()}),e._timeBeforeLatency));},e.prototype._linkifyRows=function(){this._rowsTimeoutId=void 0;var e=this._bufferService.buffer;if(void 0!==this._rowsToLinkify.start&&void 0!==this._rowsToLinkify.end){var t=e.ydisp+this._rowsToLinkify.start;if(!(t>=e.lines.length)){for(var r=e.ydisp+Math.min(this._rowsToLinkify.end,this._bufferService.rows)+1,i=Math.ceil(2e3/this._bufferService.cols),n=this._bufferService.buffer.iterator(!1,t,r,i,i);n.hasNext();)for(var o=n.next(),s=0;s<this._linkMatchers.length;s++)this._doLinkifyRow(o.range.first,o.content,this._linkMatchers[s]);this._rowsToLinkify.start=void 0,this._rowsToLinkify.end=void 0;}}else this._logService.debug("_rowToLinkify was unset before _linkifyRows was called");},e.prototype.registerLinkMatcher=function(e,t,r){if(void 0===r&&(r={}),!t)throw new Error("handler must be defined");var i={id:this._nextLinkMatcherId++,regex:e,handler:t,matchIndex:r.matchIndex,validationCallback:r.validationCallback,hoverTooltipCallback:r.tooltipCallback,hoverLeaveCallback:r.leaveCallback,willLinkActivate:r.willLinkActivate,priority:r.priority||0};return this._addLinkMatcherToList(i),i.id},e.prototype._addLinkMatcherToList=function(e){if(0!==this._linkMatchers.length){for(var t=this._linkMatchers.length-1;t>=0;t--)if(e.priority<=this._linkMatchers[t].priority)return void this._linkMatchers.splice(t+1,0,e);this._linkMatchers.splice(0,0,e);}else this._linkMatchers.push(e);},e.prototype.deregisterLinkMatcher=function(e){for(var t=0;t<this._linkMatchers.length;t++)if(this._linkMatchers[t].id===e)return this._linkMatchers.splice(t,1),!0;return !1},e.prototype._doLinkifyRow=function(e,t,r){for(var i,n=this,o=new RegExp(r.regex.source,(r.regex.flags||"")+"g"),s=-1,a=function(){var a=i["number"!=typeof r.matchIndex?0:r.matchIndex];if(!a)return c._logService.debug("match found without corresponding matchIndex",i,r),"break";if(s=t.indexOf(a,s+1),o.lastIndex=s+a.length,s<0)return "break";var l=c._bufferService.buffer.stringIndexToBufferIndex(e,s);if(l[0]<0)return "break";var h=c._bufferService.buffer.lines.get(l[0]);if(!h)return "break";var u=h.getFg(l[1]),f=u?u>>9&511:void 0;r.validationCallback?r.validationCallback(a,(function(e){n._rowsTimeoutId||e&&n._addLink(l[1],l[0]-n._bufferService.buffer.ydisp,a,r,f);})):c._addLink(l[1],l[0]-c._bufferService.buffer.ydisp,a,r,f);},c=this;null!==(i=o.exec(t));){if("break"===a())break}},e.prototype._addLink=function(e,t,r,i,n){var o=this;if(this._mouseZoneManager&&this._element){var s=this._unicodeService.getStringCellWidth(r),a=e%this._bufferService.cols,l=t+Math.floor(e/this._bufferService.cols),h=(a+s)%this._bufferService.cols,u=l+Math.floor((a+s)/this._bufferService.cols);0===h&&(h=this._bufferService.cols,u--),this._mouseZoneManager.add(new c(a+1,l+1,h+1,u+1,(function(e){if(i.handler)return i.handler(e,r);var t=window.open();t?(t.opener=null,t.location.href=r):console.warn("Opening link blocked as opener could not be cleared");}),(function(){o._onShowLinkUnderline.fire(o._createLinkHoverEvent(a,l,h,u,n)),o._element.classList.add("xterm-cursor-pointer");}),(function(e){o._onLinkTooltip.fire(o._createLinkHoverEvent(a,l,h,u,n)),i.hoverTooltipCallback&&i.hoverTooltipCallback(e,r,{start:{x:a,y:l},end:{x:h,y:u}});}),(function(){o._onHideLinkUnderline.fire(o._createLinkHoverEvent(a,l,h,u,n)),o._element.classList.remove("xterm-cursor-pointer"),i.hoverLeaveCallback&&i.hoverLeaveCallback();}),(function(e){return !i.willLinkActivate||i.willLinkActivate(e,r)})));}},e.prototype._createLinkHoverEvent=function(e,t,r,i,n){return {x1:e,y1:t,x2:r,y2:i,cols:this._bufferService.cols,fg:n}},e._timeBeforeLatency=200,e=i([n(0,s.IBufferService),n(1,s.ILogService),n(2,s.IUnicodeService)],e)}();t.Linkifier=a;var c=function(e,t,r,i,n,o,s,a,c){this.x1=e,this.y1=t,this.x2=r,this.y2=i,this.clickCallback=n,this.hoverCallback=o,this.tooltipCallback=s,this.leaveCallback=a,this.willLinkActivate=c;};t.MouseZone=c;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.SelectionService=void 0;var a=r(11),c=r(51),l=r(4),h=r(0),u=r(5),f=r(1),_=r(29),d=r(52),p=r(2),v=String.fromCharCode(160),g=new RegExp(v,"g"),y=function(e){function t(t,r,i,n,o,s,a){var u=e.call(this)||this;return u._element=t,u._screenElement=r,u._bufferService=i,u._coreService=n,u._mouseService=o,u._optionsService=s,u._renderService=a,u._dragScrollAmount=0,u._enabled=!0,u._workCell=new l.CellData,u._mouseDownTimeStamp=0,u._onLinuxMouseSelection=u.register(new h.EventEmitter),u._onRedrawRequest=u.register(new h.EventEmitter),u._onSelectionChange=u.register(new h.EventEmitter),u._onRequestScrollLines=u.register(new h.EventEmitter),u._mouseMoveListener=function(e){return u._onMouseMove(e)},u._mouseUpListener=function(e){return u._onMouseUp(e)},u._coreService.onUserInput((function(){u.hasSelection&&u.clearSelection();})),u._trimListener=u._bufferService.buffer.lines.onTrim((function(e){return u._onTrim(e)})),u.register(u._bufferService.buffers.onBufferActivate((function(e){return u._onBufferActivate(e)}))),u.enable(),u._model=new c.SelectionModel(u._bufferService),u._activeSelectionMode=0,u}return n(t,e),Object.defineProperty(t.prototype,"onLinuxMouseSelection",{get:function(){return this._onLinuxMouseSelection.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRequestRedraw",{get:function(){return this._onRedrawRequest.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onSelectionChange",{get:function(){return this._onSelectionChange.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRequestScrollLines",{get:function(){return this._onRequestScrollLines.event},enumerable:!1,configurable:!0}),t.prototype.dispose=function(){this._removeMouseDownListeners();},t.prototype.reset=function(){this.clearSelection();},t.prototype.disable=function(){this.clearSelection(),this._enabled=!1;},t.prototype.enable=function(){this._enabled=!0;},Object.defineProperty(t.prototype,"selectionStart",{get:function(){return this._model.finalSelectionStart},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"selectionEnd",{get:function(){return this._model.finalSelectionEnd},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"hasSelection",{get:function(){var e=this._model.finalSelectionStart,t=this._model.finalSelectionEnd;return !(!e||!t)&&(e[0]!==t[0]||e[1]!==t[1])},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"selectionText",{get:function(){var e=this._model.finalSelectionStart,t=this._model.finalSelectionEnd;if(!e||!t)return "";var r=this._bufferService.buffer,i=[];if(3===this._activeSelectionMode){if(e[0]===t[0])return "";for(var n=e[1];n<=t[1];n++){var o=r.translateBufferLineToString(n,!0,e[0],t[0]);i.push(o);}}else {var s=e[1]===t[1]?t[0]:void 0;i.push(r.translateBufferLineToString(e[1],!0,e[0],s));for(n=e[1]+1;n<=t[1]-1;n++){var c=r.lines.get(n);o=r.translateBufferLineToString(n,!0);c&&c.isWrapped?i[i.length-1]+=o:i.push(o);}if(e[1]!==t[1]){c=r.lines.get(t[1]),o=r.translateBufferLineToString(t[1],!0,0,t[0]);c&&c.isWrapped?i[i.length-1]+=o:i.push(o);}}return i.map((function(e){return e.replace(g," ")})).join(a.isWindows?"\r\n":"\n")},enumerable:!1,configurable:!0}),t.prototype.clearSelection=function(){this._model.clearSelection(),this._removeMouseDownListeners(),this.refresh(),this._onSelectionChange.fire();},t.prototype.refresh=function(e){var t=this;(this._refreshAnimationFrame||(this._refreshAnimationFrame=window.requestAnimationFrame((function(){return t._refresh()}))),a.isLinux&&e)&&(this.selectionText.length&&this._onLinuxMouseSelection.fire(this.selectionText));},t.prototype._refresh=function(){this._refreshAnimationFrame=void 0,this._onRedrawRequest.fire({start:this._model.finalSelectionStart,end:this._model.finalSelectionEnd,columnSelectMode:3===this._activeSelectionMode});},t.prototype.isClickInSelection=function(e){var t=this._getMouseBufferCoords(e),r=this._model.finalSelectionStart,i=this._model.finalSelectionEnd;return !!(r&&i&&t)&&this._areCoordsInSelection(t,r,i)},t.prototype._areCoordsInSelection=function(e,t,r){return e[1]>t[1]&&e[1]<r[1]||t[1]===r[1]&&e[1]===t[1]&&e[0]>=t[0]&&e[0]<r[0]||t[1]<r[1]&&e[1]===r[1]&&e[0]<r[0]||t[1]<r[1]&&e[1]===t[1]&&e[0]>=t[0]},t.prototype.selectWordAtCursor=function(e){var t=this._getMouseBufferCoords(e);t&&(this._selectWordAt(t,!1),this._model.selectionEnd=void 0,this.refresh(!0));},t.prototype.selectAll=function(){this._model.isSelectAllActive=!0,this.refresh(),this._onSelectionChange.fire();},t.prototype.selectLines=function(e,t){this._model.clearSelection(),e=Math.max(e,0),t=Math.min(t,this._bufferService.buffer.lines.length-1),this._model.selectionStart=[0,e],this._model.selectionEnd=[this._bufferService.cols,t],this.refresh(),this._onSelectionChange.fire();},t.prototype._onTrim=function(e){this._model.onTrim(e)&&this.refresh();},t.prototype._getMouseBufferCoords=function(e){var t=this._mouseService.getCoords(e,this._screenElement,this._bufferService.cols,this._bufferService.rows,!0);if(t)return t[0]--,t[1]--,t[1]+=this._bufferService.buffer.ydisp,t},t.prototype._getMouseEventScrollAmount=function(e){var t=_.getCoordsRelativeToElement(e,this._screenElement)[1],r=this._renderService.dimensions.canvasHeight;return t>=0&&t<=r?0:(t>r&&(t-=r),t=Math.min(Math.max(t,-50),50),(t/=50)/Math.abs(t)+Math.round(14*t))},t.prototype.shouldForceSelection=function(e){return a.isMac?e.altKey&&this._optionsService.options.macOptionClickForcesSelection:e.shiftKey},t.prototype.onMouseDown=function(e){if(this._mouseDownTimeStamp=e.timeStamp,(2!==e.button||!this.hasSelection)&&0===e.button){if(!this._enabled){if(!this.shouldForceSelection(e))return;e.stopPropagation();}e.preventDefault(),this._dragScrollAmount=0,this._enabled&&e.shiftKey?this._onIncrementalClick(e):1===e.detail?this._onSingleClick(e):2===e.detail?this._onDoubleClick(e):3===e.detail&&this._onTripleClick(e),this._addMouseDownListeners(),this.refresh(!0);}},t.prototype._addMouseDownListeners=function(){var e=this;this._screenElement.ownerDocument&&(this._screenElement.ownerDocument.addEventListener("mousemove",this._mouseMoveListener),this._screenElement.ownerDocument.addEventListener("mouseup",this._mouseUpListener)),this._dragScrollIntervalTimer=window.setInterval((function(){return e._dragScroll()}),50);},t.prototype._removeMouseDownListeners=function(){this._screenElement.ownerDocument&&(this._screenElement.ownerDocument.removeEventListener("mousemove",this._mouseMoveListener),this._screenElement.ownerDocument.removeEventListener("mouseup",this._mouseUpListener)),clearInterval(this._dragScrollIntervalTimer),this._dragScrollIntervalTimer=void 0;},t.prototype._onIncrementalClick=function(e){this._model.selectionStart&&(this._model.selectionEnd=this._getMouseBufferCoords(e));},t.prototype._onSingleClick=function(e){if(this._model.selectionStartLength=0,this._model.isSelectAllActive=!1,this._activeSelectionMode=this.shouldColumnSelect(e)?3:0,this._model.selectionStart=this._getMouseBufferCoords(e),this._model.selectionStart){this._model.selectionEnd=void 0;var t=this._bufferService.buffer.lines.get(this._model.selectionStart[1]);t&&t.length!==this._model.selectionStart[0]&&0===t.hasWidth(this._model.selectionStart[0])&&this._model.selectionStart[0]++;}},t.prototype._onDoubleClick=function(e){var t=this._getMouseBufferCoords(e);t&&(this._activeSelectionMode=1,this._selectWordAt(t,!0));},t.prototype._onTripleClick=function(e){var t=this._getMouseBufferCoords(e);t&&(this._activeSelectionMode=2,this._selectLineAt(t[1]));},t.prototype.shouldColumnSelect=function(e){return e.altKey&&!(a.isMac&&this._optionsService.options.macOptionClickForcesSelection)},t.prototype._onMouseMove=function(e){if(e.stopImmediatePropagation(),this._model.selectionStart){var t=this._model.selectionEnd?[this._model.selectionEnd[0],this._model.selectionEnd[1]]:null;if(this._model.selectionEnd=this._getMouseBufferCoords(e),this._model.selectionEnd){2===this._activeSelectionMode?this._model.selectionEnd[1]<this._model.selectionStart[1]?this._model.selectionEnd[0]=0:this._model.selectionEnd[0]=this._bufferService.cols:1===this._activeSelectionMode&&this._selectToWordAt(this._model.selectionEnd),this._dragScrollAmount=this._getMouseEventScrollAmount(e),3!==this._activeSelectionMode&&(this._dragScrollAmount>0?this._model.selectionEnd[0]=this._bufferService.cols:this._dragScrollAmount<0&&(this._model.selectionEnd[0]=0));var r=this._bufferService.buffer;if(this._model.selectionEnd[1]<r.lines.length){var i=r.lines.get(this._model.selectionEnd[1]);i&&0===i.hasWidth(this._model.selectionEnd[0])&&this._model.selectionEnd[0]++;}t&&t[0]===this._model.selectionEnd[0]&&t[1]===this._model.selectionEnd[1]||this.refresh(!0);}else this.refresh(!0);}},t.prototype._dragScroll=function(){if(this._model.selectionEnd&&this._model.selectionStart&&this._dragScrollAmount){this._onRequestScrollLines.fire({amount:this._dragScrollAmount,suppressScrollEvent:!1});var e=this._bufferService.buffer;this._dragScrollAmount>0?(3!==this._activeSelectionMode&&(this._model.selectionEnd[0]=this._bufferService.cols),this._model.selectionEnd[1]=Math.min(e.ydisp+this._bufferService.rows,e.lines.length-1)):(3!==this._activeSelectionMode&&(this._model.selectionEnd[0]=0),this._model.selectionEnd[1]=e.ydisp),this.refresh();}},t.prototype._onMouseUp=function(e){var t=e.timeStamp-this._mouseDownTimeStamp;if(this._removeMouseDownListeners(),this.selectionText.length<=1&&t<500){if(e.altKey&&this._bufferService.buffer.ybase===this._bufferService.buffer.ydisp){var r=this._mouseService.getCoords(e,this._element,this._bufferService.cols,this._bufferService.rows,!1);if(r&&void 0!==r[0]&&void 0!==r[1]){var i=d.moveToCellSequence(r[0]-1,r[1]-1,this._bufferService,this._coreService.decPrivateModes.applicationCursorKeys);this._coreService.triggerDataEvent(i,!0);}}}else this.hasSelection&&this._onSelectionChange.fire();},t.prototype._onBufferActivate=function(e){var t=this;this.clearSelection(),this._trimListener.dispose(),this._trimListener=e.activeBuffer.lines.onTrim((function(e){return t._onTrim(e)}));},t.prototype._convertViewportColToCharacterIndex=function(e,t){for(var r=t[0],i=0;t[0]>=i;i++){var n=e.loadCell(i,this._workCell).getChars().length;0===this._workCell.getWidth()?r--:n>1&&t[0]!==i&&(r+=n-1);}return r},t.prototype.setSelection=function(e,t,r){this._model.clearSelection(),this._removeMouseDownListeners(),this._model.selectionStart=[e,t],this._model.selectionStartLength=r,this.refresh();},t.prototype._getWordAt=function(e,t,r,i){if(void 0===r&&(r=!0),void 0===i&&(i=!0),!(e[0]>=this._bufferService.cols)){var n=this._bufferService.buffer,o=n.lines.get(e[1]);if(o){var s=n.translateBufferLineToString(e[1],!1),a=this._convertViewportColToCharacterIndex(o,e),c=a,l=e[0]-a,h=0,u=0,f=0,_=0;if(" "===s.charAt(a)){for(;a>0&&" "===s.charAt(a-1);)a--;for(;c<s.length&&" "===s.charAt(c+1);)c++;}else {var d=e[0],p=e[0];0===o.getWidth(d)&&(h++,d--),2===o.getWidth(p)&&(u++,p++);var v=o.getString(p).length;for(v>1&&(_+=v-1,c+=v-1);d>0&&a>0&&!this._isCharWordSeparator(o.loadCell(d-1,this._workCell));){o.loadCell(d-1,this._workCell);var g=this._workCell.getChars().length;0===this._workCell.getWidth()?(h++,d--):g>1&&(f+=g-1,a-=g-1),a--,d--;}for(;p<o.length&&c+1<s.length&&!this._isCharWordSeparator(o.loadCell(p+1,this._workCell));){o.loadCell(p+1,this._workCell);var y=this._workCell.getChars().length;2===this._workCell.getWidth()?(u++,p++):y>1&&(_+=y-1,c+=y-1),c++,p++;}}c++;var b=a+l-h+f,S=Math.min(this._bufferService.cols,c-a+h+u-f-_);if(t||""!==s.slice(a,c).trim()){if(r&&0===b&&32!==o.getCodePoint(0)){var m=n.lines.get(e[1]-1);if(m&&o.isWrapped&&32!==m.getCodePoint(this._bufferService.cols-1)){var C=this._getWordAt([this._bufferService.cols-1,e[1]-1],!1,!0,!1);if(C){var w=this._bufferService.cols-C.start;b-=w,S+=w;}}}if(i&&b+S===this._bufferService.cols&&32!==o.getCodePoint(this._bufferService.cols-1)){var E=n.lines.get(e[1]+1);if(E&&E.isWrapped&&32!==E.getCodePoint(0)){var L=this._getWordAt([0,e[1]+1],!1,!1,!0);L&&(S+=L.length);}}return {start:b,length:S}}}}},t.prototype._selectWordAt=function(e,t){var r=this._getWordAt(e,t);if(r){for(;r.start<0;)r.start+=this._bufferService.cols,e[1]--;this._model.selectionStart=[r.start,e[1]],this._model.selectionStartLength=r.length;}},t.prototype._selectToWordAt=function(e){var t=this._getWordAt(e,!0);if(t){for(var r=e[1];t.start<0;)t.start+=this._bufferService.cols,r--;if(!this._model.areSelectionValuesReversed())for(;t.start+t.length>this._bufferService.cols;)t.length-=this._bufferService.cols,r++;this._model.selectionEnd=[this._model.areSelectionValuesReversed()?t.start:t.start+t.length,r];}},t.prototype._isCharWordSeparator=function(e){return 0!==e.getWidth()&&this._optionsService.options.wordSeparator.indexOf(e.getChars())>=0},t.prototype._selectLineAt=function(e){var t=this._bufferService.buffer.getWrappedRangeForLine(e);this._model.selectionStart=[0,t.first],this._model.selectionEnd=[this._bufferService.cols,t.last],this._model.selectionStartLength=0;},t=o([s(2,f.IBufferService),s(3,f.ICoreService),s(4,u.IMouseService),s(5,f.IOptionsService),s(6,u.IRenderService)],t)}(p.Disposable);t.SelectionService=y;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.SelectionModel=void 0;var i=function(){function e(e){this._bufferService=e,this.isSelectAllActive=!1,this.selectionStartLength=0;}return e.prototype.clearSelection=function(){this.selectionStart=void 0,this.selectionEnd=void 0,this.isSelectAllActive=!1,this.selectionStartLength=0;},Object.defineProperty(e.prototype,"finalSelectionStart",{get:function(){return this.isSelectAllActive?[0,0]:this.selectionEnd&&this.selectionStart&&this.areSelectionValuesReversed()?this.selectionEnd:this.selectionStart},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"finalSelectionEnd",{get:function(){if(this.isSelectAllActive)return [this._bufferService.cols,this._bufferService.buffer.ybase+this._bufferService.rows-1];if(this.selectionStart){if(!this.selectionEnd||this.areSelectionValuesReversed()){var e=this.selectionStart[0]+this.selectionStartLength;return e>this._bufferService.cols?[e%this._bufferService.cols,this.selectionStart[1]+Math.floor(e/this._bufferService.cols)]:[e,this.selectionStart[1]]}return this.selectionStartLength&&this.selectionEnd[1]===this.selectionStart[1]?[Math.max(this.selectionStart[0]+this.selectionStartLength,this.selectionEnd[0]),this.selectionEnd[1]]:this.selectionEnd}},enumerable:!1,configurable:!0}),e.prototype.areSelectionValuesReversed=function(){var e=this.selectionStart,t=this.selectionEnd;return !(!e||!t)&&(e[1]>t[1]||e[1]===t[1]&&e[0]>t[0])},e.prototype.onTrim=function(e){return this.selectionStart&&(this.selectionStart[1]-=e),this.selectionEnd&&(this.selectionEnd[1]-=e),this.selectionEnd&&this.selectionEnd[1]<0?(this.clearSelection(),!0):(this.selectionStart&&this.selectionStart[1]<0&&(this.selectionStart[1]=0),!1)},e}();t.SelectionModel=i;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.moveToCellSequence=void 0;var i=r(12);function n(e,t,r,i){var n=e-o(r,e),a=t-o(r,t);return l(Math.abs(n-a)-function(e,t,r){for(var i=0,n=e-o(r,e),a=t-o(r,t),c=0;c<Math.abs(n-a);c++){var l="A"===s(e,t)?-1:1,h=r.buffer.lines.get(n+l*c);h&&h.isWrapped&&i++;}return i}(e,t,r),c(s(e,t),i))}function o(e,t){for(var r=0,i=e.buffer.lines.get(t),n=i&&i.isWrapped;n&&t>=0&&t<e.rows;)r++,n=(i=e.buffer.lines.get(--t))&&i.isWrapped;return r}function s(e,t){return e>t?"A":"B"}function a(e,t,r,i,n,o){for(var s=e,a=t,c="";s!==r||a!==i;)s+=n?1:-1,n&&s>o.cols-1?(c+=o.buffer.translateBufferLineToString(a,!1,e,s),s=0,e=0,a++):!n&&s<0&&(c+=o.buffer.translateBufferLineToString(a,!1,0,e+1),e=s=o.cols-1,a--);return c+o.buffer.translateBufferLineToString(a,!1,e,s)}function c(e,t){var r=t?"O":"[";return i.C0.ESC+r+e}function l(e,t){e=Math.floor(e);for(var r="",i=0;i<e;i++)r+=t;return r}t.moveToCellSequence=function(e,t,r,i){var s,h=r.buffer.x,u=r.buffer.y;if(!r.buffer.hasScrollback)return function(e,t,r,i,s,h){if(0===n(t,i,s,h).length)return "";return l(a(e,t,e,t-o(s,t),!1,s).length,c("D",h))}(h,u,0,t,r,i)+n(u,t,r,i)+function(e,t,r,i,s,h){var u;u=n(t,i,s,h).length>0?i-o(s,i):t;var f=i,_=function(e,t,r,i,s,a){var c;c=n(r,i,s,a).length>0?i-o(s,i):t;if(e<r&&c<=i||e>=r&&c<i)return "C";return "D"}(e,t,r,i,s,h);return l(a(e,u,r,f,"C"===_,s).length,c(_,h))}(h,u,e,t,r,i);if(u===t)return s=h>e?"D":"C",l(Math.abs(h-e),c(s,i));s=u>t?"D":"C";var f=Math.abs(u-t);return l(function(e,t){return t.cols-e}(u>t?e:h,r)+(f-1)*r.cols+1+((u>t?h:e)-1),c(s,i))};},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.SoundService=void 0;var o=r(1),s=function(){function e(e){this._optionsService=e;}return Object.defineProperty(e,"audioContext",{get:function(){if(!e._audioContext){var t=window.AudioContext||window.webkitAudioContext;if(!t)return console.warn("Web Audio API is not supported by this browser. Consider upgrading to the latest version"),null;e._audioContext=new t;}return e._audioContext},enumerable:!1,configurable:!0}),e.prototype.playBellSound=function(){var t=e.audioContext;if(t){var r=t.createBufferSource();t.decodeAudioData(this._base64ToArrayBuffer(this._removeMimeType(this._optionsService.options.bellSound)),(function(e){r.buffer=e,r.connect(t.destination),r.start(0);}));}},e.prototype._base64ToArrayBuffer=function(e){for(var t=window.atob(e),r=t.length,i=new Uint8Array(r),n=0;n<r;n++)i[n]=t.charCodeAt(n);return i.buffer},e.prototype._removeMimeType=function(e){return e.split(",")[1]},e=i([n(0,o.IOptionsService)],e)}();t.SoundService=s;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.MouseZoneManager=void 0;var a=r(2),c=r(7),l=r(5),h=r(1),u=function(e){function t(t,r,i,n,o,s){var a=e.call(this)||this;return a._element=t,a._screenElement=r,a._bufferService=i,a._mouseService=n,a._selectionService=o,a._optionsService=s,a._zones=[],a._areZonesActive=!1,a._lastHoverCoords=[void 0,void 0],a._initialSelectionLength=0,a.register(c.addDisposableDomListener(a._element,"mousedown",(function(e){return a._onMouseDown(e)}))),a._mouseMoveListener=function(e){return a._onMouseMove(e)},a._mouseLeaveListener=function(e){return a._onMouseLeave(e)},a._clickListener=function(e){return a._onClick(e)},a}return n(t,e),t.prototype.dispose=function(){e.prototype.dispose.call(this),this._deactivate();},t.prototype.add=function(e){this._zones.push(e),1===this._zones.length&&this._activate();},t.prototype.clearAll=function(e,t){if(0!==this._zones.length){e&&t||(e=0,t=this._bufferService.rows-1);for(var r=0;r<this._zones.length;r++){var i=this._zones[r];(i.y1>e&&i.y1<=t+1||i.y2>e&&i.y2<=t+1||i.y1<e&&i.y2>t+1)&&(this._currentZone&&this._currentZone===i&&(this._currentZone.leaveCallback(),this._currentZone=void 0),this._zones.splice(r--,1));}0===this._zones.length&&this._deactivate();}},t.prototype._activate=function(){this._areZonesActive||(this._areZonesActive=!0,this._element.addEventListener("mousemove",this._mouseMoveListener),this._element.addEventListener("mouseleave",this._mouseLeaveListener),this._element.addEventListener("click",this._clickListener));},t.prototype._deactivate=function(){this._areZonesActive&&(this._areZonesActive=!1,this._element.removeEventListener("mousemove",this._mouseMoveListener),this._element.removeEventListener("mouseleave",this._mouseLeaveListener),this._element.removeEventListener("click",this._clickListener));},t.prototype._onMouseMove=function(e){this._lastHoverCoords[0]===e.pageX&&this._lastHoverCoords[1]===e.pageY||(this._onHover(e),this._lastHoverCoords=[e.pageX,e.pageY]);},t.prototype._onHover=function(e){var t=this,r=this._findZoneEventAt(e);r!==this._currentZone&&(this._currentZone&&(this._currentZone.leaveCallback(),this._currentZone=void 0,this._tooltipTimeout&&clearTimeout(this._tooltipTimeout)),r&&(this._currentZone=r,r.hoverCallback&&r.hoverCallback(e),this._tooltipTimeout=window.setTimeout((function(){return t._onTooltip(e)}),this._optionsService.options.linkTooltipHoverDuration)));},t.prototype._onTooltip=function(e){this._tooltipTimeout=void 0;var t=this._findZoneEventAt(e);t&&t.tooltipCallback&&t.tooltipCallback(e);},t.prototype._onMouseDown=function(e){if(this._initialSelectionLength=this._getSelectionLength(),this._areZonesActive){var t=this._findZoneEventAt(e);(null==t?void 0:t.willLinkActivate(e))&&(e.preventDefault(),e.stopImmediatePropagation());}},t.prototype._onMouseLeave=function(e){this._currentZone&&(this._currentZone.leaveCallback(),this._currentZone=void 0,this._tooltipTimeout&&clearTimeout(this._tooltipTimeout));},t.prototype._onClick=function(e){var t=this._findZoneEventAt(e),r=this._getSelectionLength();t&&r===this._initialSelectionLength&&(t.clickCallback(e),e.preventDefault(),e.stopImmediatePropagation());},t.prototype._getSelectionLength=function(){var e=this._selectionService.selectionText;return e?e.length:0},t.prototype._findZoneEventAt=function(e){var t=this._mouseService.getCoords(e,this._screenElement,this._bufferService.cols,this._bufferService.rows);if(t)for(var r=t[0],i=t[1],n=0;n<this._zones.length;n++){var o=this._zones[n];if(o.y1===o.y2){if(i===o.y1&&r>=o.x1&&r<o.x2)return o}else if(i===o.y1&&r>=o.x1||i===o.y2&&r<o.x2||i>o.y1&&i<o.y2)return o}},t=o([s(2,h.IBufferService),s(3,l.IMouseService),s(4,l.ISelectionService),s(5,h.IOptionsService)],t)}(a.Disposable);t.MouseZoneManager=u;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.AccessibilityManager=void 0;var o=r(17),s=r(11),a=r(30),c=r(7),l=r(2),h=r(31),u=function(e){function t(t,r){var i=e.call(this)||this;i._terminal=t,i._renderService=r,i._liveRegionLineCount=0,i._charsToConsume=[],i._charsToAnnounce="",i._accessibilityTreeRoot=document.createElement("div"),i._accessibilityTreeRoot.classList.add("xterm-accessibility"),i._rowContainer=document.createElement("div"),i._rowContainer.classList.add("xterm-accessibility-tree"),i._rowContainer.setAttribute("role","list"),i._rowElements=[];for(var n=0;n<i._terminal.rows;n++)i._rowElements[n]=i._createAccessibilityTreeNode(),i._rowContainer.appendChild(i._rowElements[n]);if(i._topBoundaryFocusListener=function(e){return i._onBoundaryFocus(e,0)},i._bottomBoundaryFocusListener=function(e){return i._onBoundaryFocus(e,1)},i._rowElements[0].addEventListener("focus",i._topBoundaryFocusListener),i._rowElements[i._rowElements.length-1].addEventListener("focus",i._bottomBoundaryFocusListener),i._refreshRowsDimensions(),i._accessibilityTreeRoot.appendChild(i._rowContainer),i._renderRowsDebouncer=new a.RenderDebouncer(i._renderRows.bind(i)),i._refreshRows(),i._liveRegion=document.createElement("div"),i._liveRegion.classList.add("live-region"),i._liveRegion.setAttribute("aria-live","assertive"),i._accessibilityTreeRoot.appendChild(i._liveRegion),!i._terminal.element)throw new Error("Cannot enable accessibility before Terminal.open");return i._terminal.element.insertAdjacentElement("afterbegin",i._accessibilityTreeRoot),i.register(i._renderRowsDebouncer),i.register(i._terminal.onResize((function(e){return i._onResize(e.rows)}))),i.register(i._terminal.onRender((function(e){return i._refreshRows(e.start,e.end)}))),i.register(i._terminal.onScroll((function(){return i._refreshRows()}))),i.register(i._terminal.onA11yChar((function(e){return i._onChar(e)}))),i.register(i._terminal.onLineFeed((function(){return i._onChar("\n")}))),i.register(i._terminal.onA11yTab((function(e){return i._onTab(e)}))),i.register(i._terminal.onKey((function(e){return i._onKey(e.key)}))),i.register(i._terminal.onBlur((function(){return i._clearLiveRegion()}))),i.register(i._renderService.onDimensionsChange((function(){return i._refreshRowsDimensions()}))),i._screenDprMonitor=new h.ScreenDprMonitor,i.register(i._screenDprMonitor),i._screenDprMonitor.setListener((function(){return i._refreshRowsDimensions()})),i.register(c.addDisposableDomListener(window,"resize",(function(){return i._refreshRowsDimensions()}))),i}return n(t,e),t.prototype.dispose=function(){var t;e.prototype.dispose.call(this),null===(t=this._terminal.element)||void 0===t||t.removeChild(this._accessibilityTreeRoot),this._rowElements.length=0;},t.prototype._onBoundaryFocus=function(e,t){var r=e.target,i=this._rowElements[0===t?1:this._rowElements.length-2];if(r.getAttribute("aria-posinset")!==(0===t?"1":""+this._terminal.buffer.lines.length)&&e.relatedTarget===i){var n,o;if(0===t?(n=r,o=this._rowElements.pop(),this._rowContainer.removeChild(o)):(n=this._rowElements.shift(),o=r,this._rowContainer.removeChild(n)),n.removeEventListener("focus",this._topBoundaryFocusListener),o.removeEventListener("focus",this._bottomBoundaryFocusListener),0===t){var s=this._createAccessibilityTreeNode();this._rowElements.unshift(s),this._rowContainer.insertAdjacentElement("afterbegin",s);}else {s=this._createAccessibilityTreeNode();this._rowElements.push(s),this._rowContainer.appendChild(s);}this._rowElements[0].addEventListener("focus",this._topBoundaryFocusListener),this._rowElements[this._rowElements.length-1].addEventListener("focus",this._bottomBoundaryFocusListener),this._terminal.scrollLines(0===t?-1:1),this._rowElements[0===t?1:this._rowElements.length-2].focus(),e.preventDefault(),e.stopImmediatePropagation();}},t.prototype._onResize=function(e){this._rowElements[this._rowElements.length-1].removeEventListener("focus",this._bottomBoundaryFocusListener);for(var t=this._rowContainer.children.length;t<this._terminal.rows;t++)this._rowElements[t]=this._createAccessibilityTreeNode(),this._rowContainer.appendChild(this._rowElements[t]);for(;this._rowElements.length>e;)this._rowContainer.removeChild(this._rowElements.pop());this._rowElements[this._rowElements.length-1].addEventListener("focus",this._bottomBoundaryFocusListener),this._refreshRowsDimensions();},t.prototype._createAccessibilityTreeNode=function(){var e=document.createElement("div");return e.setAttribute("role","listitem"),e.tabIndex=-1,this._refreshRowDimensions(e),e},t.prototype._onTab=function(e){for(var t=0;t<e;t++)this._onChar(" ");},t.prototype._onChar=function(e){var t=this;if(this._liveRegionLineCount<21){if(this._charsToConsume.length>0)this._charsToConsume.shift()!==e&&(this._charsToAnnounce+=e);else this._charsToAnnounce+=e;"\n"===e&&(this._liveRegionLineCount++,21===this._liveRegionLineCount&&(this._liveRegion.textContent+=o.tooMuchOutput)),s.isMac&&this._liveRegion.textContent&&this._liveRegion.textContent.length>0&&!this._liveRegion.parentNode&&setTimeout((function(){t._accessibilityTreeRoot.appendChild(t._liveRegion);}),0);}},t.prototype._clearLiveRegion=function(){this._liveRegion.textContent="",this._liveRegionLineCount=0,s.isMac&&this._liveRegion.parentNode&&this._accessibilityTreeRoot.removeChild(this._liveRegion);},t.prototype._onKey=function(e){this._clearLiveRegion(),this._charsToConsume.push(e);},t.prototype._refreshRows=function(e,t){this._renderRowsDebouncer.refresh(e,t,this._terminal.rows);},t.prototype._renderRows=function(e,t){for(var r=this._terminal.buffer,i=r.lines.length.toString(),n=e;n<=t;n++){var o=r.translateBufferLineToString(r.ydisp+n,!0),s=(r.ydisp+n+1).toString(),a=this._rowElements[n];a&&(0===o.length?a.innerHTML="&nbsp;":a.textContent=o,a.setAttribute("aria-posinset",s),a.setAttribute("aria-setsize",i));}this._announceCharacters();},t.prototype._refreshRowsDimensions=function(){if(this._renderService.dimensions.actualCellHeight){this._rowElements.length!==this._terminal.rows&&this._onResize(this._terminal.rows);for(var e=0;e<this._terminal.rows;e++)this._refreshRowDimensions(this._rowElements[e]);}},t.prototype._refreshRowDimensions=function(e){e.style.height=this._renderService.dimensions.actualCellHeight+"px";},t.prototype._announceCharacters=function(){0!==this._charsToAnnounce.length&&(this._liveRegion.textContent+=this._charsToAnnounce,this._charsToAnnounce="");},t}(l.Disposable);t.AccessibilityManager=u;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.DomRenderer=void 0;var a=r(57),c=r(9),l=r(2),h=r(5),u=r(1),f=r(0),_=r(10),d=1,p=function(e){function t(t,r,i,n,o,s,c,l,h){var u=e.call(this)||this;return u._colors=t,u._element=r,u._screenElement=i,u._viewportElement=n,u._linkifier=o,u._linkifier2=s,u._charSizeService=c,u._optionsService=l,u._bufferService=h,u._terminalClass=d++,u._rowElements=[],u._rowContainer=document.createElement("div"),u._rowContainer.classList.add("xterm-rows"),u._rowContainer.style.lineHeight="normal",u._rowContainer.setAttribute("aria-hidden","true"),u._refreshRowElements(u._bufferService.cols,u._bufferService.rows),u._selectionContainer=document.createElement("div"),u._selectionContainer.classList.add("xterm-selection"),u._selectionContainer.setAttribute("aria-hidden","true"),u.dimensions={scaledCharWidth:0,scaledCharHeight:0,scaledCellWidth:0,scaledCellHeight:0,scaledCharLeft:0,scaledCharTop:0,scaledCanvasWidth:0,scaledCanvasHeight:0,canvasWidth:0,canvasHeight:0,actualCellWidth:0,actualCellHeight:0},u._updateDimensions(),u._injectCss(),u._rowFactory=new a.DomRendererRowFactory(document,u._optionsService,u._colors),u._element.classList.add("xterm-dom-renderer-owner-"+u._terminalClass),u._screenElement.appendChild(u._rowContainer),u._screenElement.appendChild(u._selectionContainer),u._linkifier.onShowLinkUnderline((function(e){return u._onLinkHover(e)})),u._linkifier.onHideLinkUnderline((function(e){return u._onLinkLeave(e)})),u._linkifier2.onShowLinkUnderline((function(e){return u._onLinkHover(e)})),u._linkifier2.onHideLinkUnderline((function(e){return u._onLinkLeave(e)})),u}return n(t,e),Object.defineProperty(t.prototype,"onRequestRedraw",{get:function(){return (new f.EventEmitter).event},enumerable:!1,configurable:!0}),t.prototype.dispose=function(){this._element.classList.remove("xterm-dom-renderer-owner-"+this._terminalClass),this._screenElement.removeChild(this._rowContainer),this._screenElement.removeChild(this._selectionContainer),this._screenElement.removeChild(this._themeStyleElement),this._screenElement.removeChild(this._dimensionsStyleElement),e.prototype.dispose.call(this);},t.prototype._updateDimensions=function(){var e=this;this.dimensions.scaledCharWidth=this._charSizeService.width*window.devicePixelRatio,this.dimensions.scaledCharHeight=Math.ceil(this._charSizeService.height*window.devicePixelRatio),this.dimensions.scaledCellWidth=this.dimensions.scaledCharWidth+Math.round(this._optionsService.options.letterSpacing),this.dimensions.scaledCellHeight=Math.floor(this.dimensions.scaledCharHeight*this._optionsService.options.lineHeight),this.dimensions.scaledCharLeft=0,this.dimensions.scaledCharTop=0,this.dimensions.scaledCanvasWidth=this.dimensions.scaledCellWidth*this._bufferService.cols,this.dimensions.scaledCanvasHeight=this.dimensions.scaledCellHeight*this._bufferService.rows,this.dimensions.canvasWidth=Math.round(this.dimensions.scaledCanvasWidth/window.devicePixelRatio),this.dimensions.canvasHeight=Math.round(this.dimensions.scaledCanvasHeight/window.devicePixelRatio),this.dimensions.actualCellWidth=this.dimensions.canvasWidth/this._bufferService.cols,this.dimensions.actualCellHeight=this.dimensions.canvasHeight/this._bufferService.rows,this._rowElements.forEach((function(t){t.style.width=e.dimensions.canvasWidth+"px",t.style.height=e.dimensions.actualCellHeight+"px",t.style.lineHeight=e.dimensions.actualCellHeight+"px",t.style.overflow="hidden";})),this._dimensionsStyleElement||(this._dimensionsStyleElement=document.createElement("style"),this._screenElement.appendChild(this._dimensionsStyleElement));var t=this._terminalSelector+" .xterm-rows span { display: inline-block; height: 100%; vertical-align: top; width: "+this.dimensions.actualCellWidth+"px}";this._dimensionsStyleElement.innerHTML=t,this._selectionContainer.style.height=this._viewportElement.style.height,this._screenElement.style.width=this.dimensions.canvasWidth+"px",this._screenElement.style.height=this.dimensions.canvasHeight+"px";},t.prototype.setColors=function(e){this._colors=e,this._injectCss();},t.prototype._injectCss=function(){var e=this;this._themeStyleElement||(this._themeStyleElement=document.createElement("style"),this._screenElement.appendChild(this._themeStyleElement));var t=this._terminalSelector+" .xterm-rows { color: "+this._colors.foreground.css+"; font-family: "+this._optionsService.options.fontFamily+"; font-size: "+this._optionsService.options.fontSize+"px;}";t+=this._terminalSelector+" span:not(."+a.BOLD_CLASS+") { font-weight: "+this._optionsService.options.fontWeight+";}"+this._terminalSelector+" span."+a.BOLD_CLASS+" { font-weight: "+this._optionsService.options.fontWeightBold+";}"+this._terminalSelector+" span."+a.ITALIC_CLASS+" { font-style: italic;}",t+="@keyframes blink_box_shadow_"+this._terminalClass+" { 50% {  box-shadow: none; }}",t+="@keyframes blink_block_"+this._terminalClass+" { 0% {  background-color: "+this._colors.cursor.css+";  color: "+this._colors.cursorAccent.css+"; } 50% {  background-color: "+this._colors.cursorAccent.css+";  color: "+this._colors.cursor.css+"; }}",t+=this._terminalSelector+" .xterm-rows:not(.xterm-focus) ."+a.CURSOR_CLASS+"."+a.CURSOR_STYLE_BLOCK_CLASS+" { outline: 1px solid "+this._colors.cursor.css+"; outline-offset: -1px;}"+this._terminalSelector+" .xterm-rows.xterm-focus ."+a.CURSOR_CLASS+"."+a.CURSOR_BLINK_CLASS+":not(."+a.CURSOR_STYLE_BLOCK_CLASS+") { animation: blink_box_shadow_"+this._terminalClass+" 1s step-end infinite;}"+this._terminalSelector+" .xterm-rows.xterm-focus ."+a.CURSOR_CLASS+"."+a.CURSOR_BLINK_CLASS+"."+a.CURSOR_STYLE_BLOCK_CLASS+" { animation: blink_block_"+this._terminalClass+" 1s step-end infinite;}"+this._terminalSelector+" .xterm-rows.xterm-focus ."+a.CURSOR_CLASS+"."+a.CURSOR_STYLE_BLOCK_CLASS+" { background-color: "+this._colors.cursor.css+"; color: "+this._colors.cursorAccent.css+";}"+this._terminalSelector+" .xterm-rows ."+a.CURSOR_CLASS+"."+a.CURSOR_STYLE_BAR_CLASS+" { box-shadow: "+this._optionsService.options.cursorWidth+"px 0 0 "+this._colors.cursor.css+" inset;}"+this._terminalSelector+" .xterm-rows ."+a.CURSOR_CLASS+"."+a.CURSOR_STYLE_UNDERLINE_CLASS+" { box-shadow: 0 -1px 0 "+this._colors.cursor.css+" inset;}",t+=this._terminalSelector+" .xterm-selection { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none;}"+this._terminalSelector+" .xterm-selection div { position: absolute; background-color: "+this._colors.selection.css+";}",this._colors.ansi.forEach((function(r,i){t+=e._terminalSelector+" .xterm-fg-"+i+" { color: "+r.css+"; }"+e._terminalSelector+" .xterm-bg-"+i+" { background-color: "+r.css+"; }";})),t+=this._terminalSelector+" .xterm-fg-"+c.INVERTED_DEFAULT_COLOR+" { color: "+_.color.opaque(this._colors.background).css+"; }"+this._terminalSelector+" .xterm-bg-"+c.INVERTED_DEFAULT_COLOR+" { background-color: "+this._colors.foreground.css+"; }",this._themeStyleElement.innerHTML=t;},t.prototype.onDevicePixelRatioChange=function(){this._updateDimensions();},t.prototype._refreshRowElements=function(e,t){for(var r=this._rowElements.length;r<=t;r++){var i=document.createElement("div");this._rowContainer.appendChild(i),this._rowElements.push(i);}for(;this._rowElements.length>t;)this._rowContainer.removeChild(this._rowElements.pop());},t.prototype.onResize=function(e,t){this._refreshRowElements(e,t),this._updateDimensions();},t.prototype.onCharSizeChanged=function(){this._updateDimensions();},t.prototype.onBlur=function(){this._rowContainer.classList.remove("xterm-focus");},t.prototype.onFocus=function(){this._rowContainer.classList.add("xterm-focus");},t.prototype.onSelectionChanged=function(e,t,r){for(;this._selectionContainer.children.length;)this._selectionContainer.removeChild(this._selectionContainer.children[0]);if(e&&t){var i=e[1]-this._bufferService.buffer.ydisp,n=t[1]-this._bufferService.buffer.ydisp,o=Math.max(i,0),s=Math.min(n,this._bufferService.rows-1);if(!(o>=this._bufferService.rows||s<0)){var a=document.createDocumentFragment();if(r)a.appendChild(this._createSelectionElement(o,e[0],t[0],s-o+1));else {var c=i===o?e[0]:0,l=o===s?t[0]:this._bufferService.cols;a.appendChild(this._createSelectionElement(o,c,l));var h=s-o-1;if(a.appendChild(this._createSelectionElement(o+1,0,this._bufferService.cols,h)),o!==s){var u=n===s?t[0]:this._bufferService.cols;a.appendChild(this._createSelectionElement(s,0,u));}}this._selectionContainer.appendChild(a);}}},t.prototype._createSelectionElement=function(e,t,r,i){void 0===i&&(i=1);var n=document.createElement("div");return n.style.height=i*this.dimensions.actualCellHeight+"px",n.style.top=e*this.dimensions.actualCellHeight+"px",n.style.left=t*this.dimensions.actualCellWidth+"px",n.style.width=this.dimensions.actualCellWidth*(r-t)+"px",n},t.prototype.onCursorMove=function(){},t.prototype.onOptionsChanged=function(){this._updateDimensions(),this._injectCss();},t.prototype.clear=function(){this._rowElements.forEach((function(e){return e.innerHTML=""}));},t.prototype.renderRows=function(e,t){for(var r=this._bufferService.buffer.ybase+this._bufferService.buffer.y,i=Math.min(this._bufferService.buffer.x,this._bufferService.cols-1),n=this._optionsService.options.cursorBlink,o=e;o<=t;o++){var s=this._rowElements[o];s.innerHTML="";var a=o+this._bufferService.buffer.ydisp,c=this._bufferService.buffer.lines.get(a),l=this._optionsService.options.cursorStyle;s.appendChild(this._rowFactory.createRow(c,a===r,l,i,n,this.dimensions.actualCellWidth,this._bufferService.cols));}},Object.defineProperty(t.prototype,"_terminalSelector",{get:function(){return ".xterm-dom-renderer-owner-"+this._terminalClass},enumerable:!1,configurable:!0}),t.prototype.registerCharacterJoiner=function(e){return -1},t.prototype.deregisterCharacterJoiner=function(e){return !1},t.prototype._onLinkHover=function(e){this._setCellUnderline(e.x1,e.x2,e.y1,e.y2,e.cols,!0);},t.prototype._onLinkLeave=function(e){this._setCellUnderline(e.x1,e.x2,e.y1,e.y2,e.cols,!1);},t.prototype._setCellUnderline=function(e,t,r,i,n,o){for(;e!==t||r!==i;){var s=this._rowElements[r];if(!s)return;var a=s.children[e];a&&(a.style.textDecoration=o?"underline":"none"),++e>=n&&(e=0,r++);}},t=o([s(6,h.ICharSizeService),s(7,u.IOptionsService),s(8,u.IBufferService)],t)}(l.Disposable);t.DomRenderer=p;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.DomRendererRowFactory=t.CURSOR_STYLE_UNDERLINE_CLASS=t.CURSOR_STYLE_BAR_CLASS=t.CURSOR_STYLE_BLOCK_CLASS=t.CURSOR_BLINK_CLASS=t.CURSOR_CLASS=t.UNDERLINE_CLASS=t.ITALIC_CLASS=t.DIM_CLASS=t.BOLD_CLASS=void 0;var i=r(9),n=r(3),o=r(4),s=r(10);t.BOLD_CLASS="xterm-bold",t.DIM_CLASS="xterm-dim",t.ITALIC_CLASS="xterm-italic",t.UNDERLINE_CLASS="xterm-underline",t.CURSOR_CLASS="xterm-cursor",t.CURSOR_BLINK_CLASS="xterm-cursor-blink",t.CURSOR_STYLE_BLOCK_CLASS="xterm-cursor-block",t.CURSOR_STYLE_BAR_CLASS="xterm-cursor-bar",t.CURSOR_STYLE_UNDERLINE_CLASS="xterm-cursor-underline";var a=function(){function e(e,t,r){this._document=e,this._optionsService=t,this._colors=r,this._workCell=new o.CellData;}return e.prototype.setColors=function(e){this._colors=e;},e.prototype.createRow=function(e,r,o,a,l,h,u){for(var f=this._document.createDocumentFragment(),_=0,d=Math.min(e.length,u)-1;d>=0;d--)if(e.loadCell(d,this._workCell).getCode()!==n.NULL_CELL_CODE||r&&d===a){_=d+1;break}for(d=0;d<_;d++){e.loadCell(d,this._workCell);var p=this._workCell.getWidth();if(0!==p){var v=this._document.createElement("span");if(p>1&&(v.style.width=h*p+"px"),r&&d===a)switch(v.classList.add(t.CURSOR_CLASS),l&&v.classList.add(t.CURSOR_BLINK_CLASS),o){case"bar":v.classList.add(t.CURSOR_STYLE_BAR_CLASS);break;case"underline":v.classList.add(t.CURSOR_STYLE_UNDERLINE_CLASS);break;default:v.classList.add(t.CURSOR_STYLE_BLOCK_CLASS);}this._workCell.isBold()&&v.classList.add(t.BOLD_CLASS),this._workCell.isItalic()&&v.classList.add(t.ITALIC_CLASS),this._workCell.isDim()&&v.classList.add(t.DIM_CLASS),this._workCell.isUnderline()&&v.classList.add(t.UNDERLINE_CLASS),this._workCell.isInvisible()?v.textContent=n.WHITESPACE_CELL_CHAR:v.textContent=this._workCell.getChars()||n.WHITESPACE_CELL_CHAR;var g=this._workCell.getFgColor(),y=this._workCell.getFgColorMode(),b=this._workCell.getBgColor(),S=this._workCell.getBgColorMode(),m=!!this._workCell.isInverse();if(m){var C=g;g=b,b=C;var w=y;y=S,S=w;}switch(y){case 16777216:case 33554432:this._workCell.isBold()&&g<8&&this._optionsService.options.drawBoldTextInBrightColors&&(g+=8),this._applyMinimumContrast(v,this._colors.background,this._colors.ansi[g])||v.classList.add("xterm-fg-"+g);break;case 50331648:var E=s.rgba.toColor(g>>16&255,g>>8&255,255&g);this._applyMinimumContrast(v,this._colors.background,E)||this._addStyle(v,"color:#"+c(g.toString(16),"0",6));break;case 0:default:this._applyMinimumContrast(v,this._colors.background,this._colors.foreground)||m&&v.classList.add("xterm-fg-"+i.INVERTED_DEFAULT_COLOR);}switch(S){case 16777216:case 33554432:v.classList.add("xterm-bg-"+b);break;case 50331648:this._addStyle(v,"background-color:#"+c(b.toString(16),"0",6));break;case 0:default:m&&v.classList.add("xterm-bg-"+i.INVERTED_DEFAULT_COLOR);}f.appendChild(v);}}return f},e.prototype._applyMinimumContrast=function(e,t,r){if(1===this._optionsService.options.minimumContrastRatio)return !1;var i=this._colors.contrastCache.getColor(this._workCell.bg,this._workCell.fg);return void 0===i&&(i=s.color.ensureContrastRatio(t,r,this._optionsService.options.minimumContrastRatio),this._colors.contrastCache.setColor(this._workCell.bg,this._workCell.fg,null!=i?i:null)),!!i&&(this._addStyle(e,"color:"+i.css),!0)},e.prototype._addStyle=function(e,t){e.setAttribute("style",""+(e.getAttribute("style")||"")+t+";");},e}();function c(e,t,r){for(;e.length<r;)e=t+e;return e}t.DomRendererRowFactory=a;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.evaluateKeyboardEvent=void 0;var i=r(12),n={48:["0",")"],49:["1","!"],50:["2","@"],51:["3","#"],52:["4","$"],53:["5","%"],54:["6","^"],55:["7","&"],56:["8","*"],57:["9","("],186:[";",":"],187:["=","+"],188:[",","<"],189:["-","_"],190:[".",">"],191:["/","?"],192:["`","~"],219:["[","{"],220:["\\","|"],221:["]","}"],222:["'",'"']};t.evaluateKeyboardEvent=function(e,t,r,o){var s={type:0,cancel:!1,key:void 0},a=(e.shiftKey?1:0)|(e.altKey?2:0)|(e.ctrlKey?4:0)|(e.metaKey?8:0);switch(e.keyCode){case 0:"UIKeyInputUpArrow"===e.key?s.key=t?i.C0.ESC+"OA":i.C0.ESC+"[A":"UIKeyInputLeftArrow"===e.key?s.key=t?i.C0.ESC+"OD":i.C0.ESC+"[D":"UIKeyInputRightArrow"===e.key?s.key=t?i.C0.ESC+"OC":i.C0.ESC+"[C":"UIKeyInputDownArrow"===e.key&&(s.key=t?i.C0.ESC+"OB":i.C0.ESC+"[B");break;case 8:if(e.shiftKey){s.key=i.C0.BS;break}if(e.altKey){s.key=i.C0.ESC+i.C0.DEL;break}s.key=i.C0.DEL;break;case 9:if(e.shiftKey){s.key=i.C0.ESC+"[Z";break}s.key=i.C0.HT,s.cancel=!0;break;case 13:s.key=e.altKey?i.C0.ESC+i.C0.CR:i.C0.CR,s.cancel=!0;break;case 27:s.key=i.C0.ESC,e.altKey&&(s.key=i.C0.ESC+i.C0.ESC),s.cancel=!0;break;case 37:if(e.metaKey)break;a?(s.key=i.C0.ESC+"[1;"+(a+1)+"D",s.key===i.C0.ESC+"[1;3D"&&(s.key=i.C0.ESC+(r?"b":"[1;5D"))):s.key=t?i.C0.ESC+"OD":i.C0.ESC+"[D";break;case 39:if(e.metaKey)break;a?(s.key=i.C0.ESC+"[1;"+(a+1)+"C",s.key===i.C0.ESC+"[1;3C"&&(s.key=i.C0.ESC+(r?"f":"[1;5C"))):s.key=t?i.C0.ESC+"OC":i.C0.ESC+"[C";break;case 38:if(e.metaKey)break;a?(s.key=i.C0.ESC+"[1;"+(a+1)+"A",r||s.key!==i.C0.ESC+"[1;3A"||(s.key=i.C0.ESC+"[1;5A")):s.key=t?i.C0.ESC+"OA":i.C0.ESC+"[A";break;case 40:if(e.metaKey)break;a?(s.key=i.C0.ESC+"[1;"+(a+1)+"B",r||s.key!==i.C0.ESC+"[1;3B"||(s.key=i.C0.ESC+"[1;5B")):s.key=t?i.C0.ESC+"OB":i.C0.ESC+"[B";break;case 45:e.shiftKey||e.ctrlKey||(s.key=i.C0.ESC+"[2~");break;case 46:s.key=a?i.C0.ESC+"[3;"+(a+1)+"~":i.C0.ESC+"[3~";break;case 36:s.key=a?i.C0.ESC+"[1;"+(a+1)+"H":t?i.C0.ESC+"OH":i.C0.ESC+"[H";break;case 35:s.key=a?i.C0.ESC+"[1;"+(a+1)+"F":t?i.C0.ESC+"OF":i.C0.ESC+"[F";break;case 33:e.shiftKey?s.type=2:s.key=i.C0.ESC+"[5~";break;case 34:e.shiftKey?s.type=3:s.key=i.C0.ESC+"[6~";break;case 112:s.key=a?i.C0.ESC+"[1;"+(a+1)+"P":i.C0.ESC+"OP";break;case 113:s.key=a?i.C0.ESC+"[1;"+(a+1)+"Q":i.C0.ESC+"OQ";break;case 114:s.key=a?i.C0.ESC+"[1;"+(a+1)+"R":i.C0.ESC+"OR";break;case 115:s.key=a?i.C0.ESC+"[1;"+(a+1)+"S":i.C0.ESC+"OS";break;case 116:s.key=a?i.C0.ESC+"[15;"+(a+1)+"~":i.C0.ESC+"[15~";break;case 117:s.key=a?i.C0.ESC+"[17;"+(a+1)+"~":i.C0.ESC+"[17~";break;case 118:s.key=a?i.C0.ESC+"[18;"+(a+1)+"~":i.C0.ESC+"[18~";break;case 119:s.key=a?i.C0.ESC+"[19;"+(a+1)+"~":i.C0.ESC+"[19~";break;case 120:s.key=a?i.C0.ESC+"[20;"+(a+1)+"~":i.C0.ESC+"[20~";break;case 121:s.key=a?i.C0.ESC+"[21;"+(a+1)+"~":i.C0.ESC+"[21~";break;case 122:s.key=a?i.C0.ESC+"[23;"+(a+1)+"~":i.C0.ESC+"[23~";break;case 123:s.key=a?i.C0.ESC+"[24;"+(a+1)+"~":i.C0.ESC+"[24~";break;default:if(!e.ctrlKey||e.shiftKey||e.altKey||e.metaKey)if(r&&!o||!e.altKey||e.metaKey)r&&!e.altKey&&!e.ctrlKey&&e.metaKey?65===e.keyCode&&(s.type=1):e.key&&!e.ctrlKey&&!e.altKey&&!e.metaKey&&e.keyCode>=48&&1===e.key.length?s.key=e.key:e.key&&e.ctrlKey&&"_"===e.key&&(s.key=i.C0.US);else {var c=n[e.keyCode],l=c&&c[e.shiftKey?1:0];if(l)s.key=i.C0.ESC+l;else if(e.keyCode>=65&&e.keyCode<=90){var h=e.ctrlKey?e.keyCode-64:e.keyCode+32;s.key=i.C0.ESC+String.fromCharCode(h);}}else e.keyCode>=65&&e.keyCode<=90?s.key=String.fromCharCode(e.keyCode-64):32===e.keyCode?s.key=i.C0.NUL:e.keyCode>=51&&e.keyCode<=55?s.key=String.fromCharCode(e.keyCode-51+27):56===e.keyCode?s.key=i.C0.DEL:219===e.keyCode?s.key=i.C0.ESC:220===e.keyCode?s.key=i.C0.FS:221===e.keyCode&&(s.key=i.C0.GS);}return s};},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.RenderService=void 0;var a=r(30),c=r(0),l=r(2),h=r(31),u=r(7),f=r(1),_=r(5),d=function(e){function t(t,r,i,n,o,s){var l=e.call(this)||this;if(l._renderer=t,l._rowCount=r,l._isPaused=!1,l._needsFullRefresh=!1,l._isNextRenderRedrawOnly=!0,l._needsSelectionRefresh=!1,l._canvasWidth=0,l._canvasHeight=0,l._selectionState={start:void 0,end:void 0,columnSelectMode:!1},l._onDimensionsChange=new c.EventEmitter,l._onRender=new c.EventEmitter,l._onRefreshRequest=new c.EventEmitter,l._renderDebouncer=new a.RenderDebouncer((function(e,t){return l._renderRows(e,t)})),l.register(l._renderDebouncer),l._screenDprMonitor=new h.ScreenDprMonitor,l._screenDprMonitor.setListener((function(){return l.onDevicePixelRatioChange()})),l.register(l._screenDprMonitor),l.register(s.onResize((function(e){return l._fullRefresh()}))),l.register(n.onOptionChange((function(){return l._renderer.onOptionsChanged()}))),l.register(o.onCharSizeChange((function(){return l.onCharSizeChanged()}))),l._renderer.onRequestRedraw((function(e){return l.refreshRows(e.start,e.end,!0)})),l.register(u.addDisposableDomListener(window,"resize",(function(){return l.onDevicePixelRatioChange()}))),"IntersectionObserver"in window){var f=new IntersectionObserver((function(e){return l._onIntersectionChange(e[e.length-1])}),{threshold:0});f.observe(i),l.register({dispose:function(){return f.disconnect()}});}return l}return n(t,e),Object.defineProperty(t.prototype,"onDimensionsChange",{get:function(){return this._onDimensionsChange.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRenderedBufferChange",{get:function(){return this._onRender.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onRefreshRequest",{get:function(){return this._onRefreshRequest.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"dimensions",{get:function(){return this._renderer.dimensions},enumerable:!1,configurable:!0}),t.prototype._onIntersectionChange=function(e){this._isPaused=0===e.intersectionRatio,!this._isPaused&&this._needsFullRefresh&&(this.refreshRows(0,this._rowCount-1),this._needsFullRefresh=!1);},t.prototype.refreshRows=function(e,t,r){void 0===r&&(r=!1),this._isPaused?this._needsFullRefresh=!0:(r||(this._isNextRenderRedrawOnly=!1),this._renderDebouncer.refresh(e,t,this._rowCount));},t.prototype._renderRows=function(e,t){this._renderer.renderRows(e,t),this._needsSelectionRefresh&&(this._renderer.onSelectionChanged(this._selectionState.start,this._selectionState.end,this._selectionState.columnSelectMode),this._needsSelectionRefresh=!1),this._isNextRenderRedrawOnly||this._onRender.fire({start:e,end:t}),this._isNextRenderRedrawOnly=!0;},t.prototype.resize=function(e,t){this._rowCount=t,this._fireOnCanvasResize();},t.prototype.changeOptions=function(){this._renderer.onOptionsChanged(),this.refreshRows(0,this._rowCount-1),this._fireOnCanvasResize();},t.prototype._fireOnCanvasResize=function(){this._renderer.dimensions.canvasWidth===this._canvasWidth&&this._renderer.dimensions.canvasHeight===this._canvasHeight||this._onDimensionsChange.fire(this._renderer.dimensions);},t.prototype.dispose=function(){this._renderer.dispose(),e.prototype.dispose.call(this);},t.prototype.setRenderer=function(e){var t=this;this._renderer.dispose(),this._renderer=e,this._renderer.onRequestRedraw((function(e){return t.refreshRows(e.start,e.end,!0)})),this._needsSelectionRefresh=!0,this._fullRefresh();},t.prototype._fullRefresh=function(){this._isPaused?this._needsFullRefresh=!0:this.refreshRows(0,this._rowCount-1);},t.prototype.setColors=function(e){this._renderer.setColors(e),this._fullRefresh();},t.prototype.onDevicePixelRatioChange=function(){this._renderer.onDevicePixelRatioChange(),this.refreshRows(0,this._rowCount-1);},t.prototype.onResize=function(e,t){this._renderer.onResize(e,t),this._fullRefresh();},t.prototype.onCharSizeChanged=function(){this._renderer.onCharSizeChanged();},t.prototype.onBlur=function(){this._renderer.onBlur();},t.prototype.onFocus=function(){this._renderer.onFocus();},t.prototype.onSelectionChanged=function(e,t,r){this._selectionState.start=e,this._selectionState.end=t,this._selectionState.columnSelectMode=r,this._renderer.onSelectionChanged(e,t,r);},t.prototype.onCursorMove=function(){this._renderer.onCursorMove();},t.prototype.clear=function(){this._renderer.clear();},t.prototype.registerCharacterJoiner=function(e){return this._renderer.registerCharacterJoiner(e)},t.prototype.deregisterCharacterJoiner=function(e){return this._renderer.deregisterCharacterJoiner(e)},t=o([s(3,f.IOptionsService),s(4,_.ICharSizeService),s(5,f.IBufferService)],t)}(l.Disposable);t.RenderService=d;},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.CharSizeService=void 0;var o=r(1),s=r(0),a=function(){function e(e,t,r){this._optionsService=r,this.width=0,this.height=0,this._onCharSizeChange=new s.EventEmitter,this._measureStrategy=new c(e,t,this._optionsService);}return Object.defineProperty(e.prototype,"hasValidSize",{get:function(){return this.width>0&&this.height>0},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onCharSizeChange",{get:function(){return this._onCharSizeChange.event},enumerable:!1,configurable:!0}),e.prototype.measure=function(){var e=this._measureStrategy.measure();e.width===this.width&&e.height===this.height||(this.width=e.width,this.height=e.height,this._onCharSizeChange.fire());},e=i([n(2,o.IOptionsService)],e)}();t.CharSizeService=a;var c=function(){function e(e,t,r){this._document=e,this._parentElement=t,this._optionsService=r,this._result={width:0,height:0},this._measureElement=this._document.createElement("span"),this._measureElement.classList.add("xterm-char-measure-element"),this._measureElement.textContent="W",this._measureElement.setAttribute("aria-hidden","true"),this._parentElement.appendChild(this._measureElement);}return e.prototype.measure=function(){this._measureElement.style.fontFamily=this._optionsService.options.fontFamily,this._measureElement.style.fontSize=this._optionsService.options.fontSize+"px";var e=this._measureElement.getBoundingClientRect();return 0!==e.width&&0!==e.height&&(this._result.width=e.width,this._result.height=Math.ceil(e.height)),this._result},e}();},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.MouseService=void 0;var o=r(5),s=r(29),a=function(){function e(e,t){this._renderService=e,this._charSizeService=t;}return e.prototype.getCoords=function(e,t,r,i,n){return s.getCoords(e,t,r,i,this._charSizeService.hasValidSize,this._renderService.dimensions.actualCellWidth,this._renderService.dimensions.actualCellHeight,n)},e.prototype.getRawByteCoords=function(e,t,r,i){var n=this.getCoords(e,t,r,i);return s.getRawByteCoords(n)},e=i([n(0,o.IRenderService),n(1,o.ICharSizeService)],e)}();t.MouseService=a;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.Linkifier2=void 0;var a=r(1),c=r(0),l=r(2),h=r(7),u=function(e){function t(t){var r=e.call(this)||this;return r._bufferService=t,r._linkProviders=[],r._linkCacheDisposables=[],r._isMouseOut=!0,r._activeLine=-1,r._onShowLinkUnderline=r.register(new c.EventEmitter),r._onHideLinkUnderline=r.register(new c.EventEmitter),r.register(l.getDisposeArrayDisposable(r._linkCacheDisposables)),r}return n(t,e),Object.defineProperty(t.prototype,"onShowLinkUnderline",{get:function(){return this._onShowLinkUnderline.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onHideLinkUnderline",{get:function(){return this._onHideLinkUnderline.event},enumerable:!1,configurable:!0}),t.prototype.registerLinkProvider=function(e){var t=this;return this._linkProviders.push(e),{dispose:function(){var r=t._linkProviders.indexOf(e);-1!==r&&t._linkProviders.splice(r,1);}}},t.prototype.attachToDom=function(e,t,r){var i=this;this._element=e,this._mouseService=t,this._renderService=r,this.register(h.addDisposableDomListener(this._element,"mouseleave",(function(){i._isMouseOut=!0,i._clearCurrentLink();}))),this.register(h.addDisposableDomListener(this._element,"mousemove",this._onMouseMove.bind(this))),this.register(h.addDisposableDomListener(this._element,"click",this._onClick.bind(this)));},t.prototype._onMouseMove=function(e){if(this._lastMouseEvent=e,this._element&&this._mouseService){var t=this._positionFromMouseEvent(e,this._element,this._mouseService);if(t){this._isMouseOut=!1;for(var r=e.composedPath(),i=0;i<r.length;i++){var n=r[i];if(n.classList.contains("xterm"))break;if(n.classList.contains("xterm-hover"))return}this._lastBufferCell&&t.x===this._lastBufferCell.x&&t.y===this._lastBufferCell.y||(this._onHover(t),this._lastBufferCell=t);}}},t.prototype._onHover=function(e){if(this._activeLine!==e.y)return this._clearCurrentLink(),void this._askForLink(e,!1);this._currentLink&&this._linkAtPosition(this._currentLink.link,e)||(this._clearCurrentLink(),this._askForLink(e,!0));},t.prototype._askForLink=function(e,t){var r=this;this._activeProviderReplies&&t||(this._activeProviderReplies=new Map,this._activeLine=e.y);var i=!1;this._linkProviders.forEach((function(n,o){var s;t?(null===(s=r._activeProviderReplies)||void 0===s?void 0:s.get(o))&&(i=r._checkLinkProviderResult(o,e,i)):n.provideLinks(e.y,(function(t){var n,s;if(!r._isMouseOut){var a=null==t?void 0:t.map((function(e){return {link:e}}));null===(n=r._activeProviderReplies)||void 0===n||n.set(o,a),i=r._checkLinkProviderResult(o,e,i),(null===(s=r._activeProviderReplies)||void 0===s?void 0:s.size)===r._linkProviders.length&&r._removeIntersectingLinks(e.y,r._activeProviderReplies);}}));}));},t.prototype._removeIntersectingLinks=function(e,t){for(var r=new Set,i=0;i<t.size;i++){var n=t.get(i);if(n)for(var o=0;o<n.length;o++)for(var s=n[o],a=s.link.range.start.y<e?0:s.link.range.start.x,c=s.link.range.end.y>e?this._bufferService.cols:s.link.range.end.x,l=a;l<=c;l++){if(r.has(l)){n.splice(o--,1);break}r.add(l);}}},t.prototype._checkLinkProviderResult=function(e,t,r){var i,n=this;if(!this._activeProviderReplies)return r;for(var o=this._activeProviderReplies.get(e),s=!1,a=0;a<e;a++)this._activeProviderReplies.has(a)&&!this._activeProviderReplies.get(a)||(s=!0);if(!s&&o){var c=o.find((function(e){return n._linkAtPosition(e.link,t)}));c&&(r=!0,this._handleNewLink(c));}if(this._activeProviderReplies.size===this._linkProviders.length&&!r)for(a=0;a<this._activeProviderReplies.size;a++){var l=null===(i=this._activeProviderReplies.get(a))||void 0===i?void 0:i.find((function(e){return n._linkAtPosition(e.link,t)}));if(l){r=!0,this._handleNewLink(l);break}}return r},t.prototype._onClick=function(e){if(this._element&&this._mouseService&&this._currentLink){var t=this._positionFromMouseEvent(e,this._element,this._mouseService);t&&this._linkAtPosition(this._currentLink.link,t)&&this._currentLink.link.activate(e,this._currentLink.link.text);}},t.prototype._clearCurrentLink=function(e,t){this._element&&this._currentLink&&this._lastMouseEvent&&(!e||!t||this._currentLink.link.range.start.y>=e&&this._currentLink.link.range.end.y<=t)&&(this._linkLeave(this._element,this._currentLink.link,this._lastMouseEvent),this._currentLink=void 0,l.disposeArray(this._linkCacheDisposables));},t.prototype._handleNewLink=function(e){var t=this;if(this._element&&this._lastMouseEvent&&this._mouseService){var r=this._positionFromMouseEvent(this._lastMouseEvent,this._element,this._mouseService);r&&this._linkAtPosition(e.link,r)&&(this._currentLink=e,this._currentLink.state={decorations:{underline:void 0===e.link.decorations||e.link.decorations.underline,pointerCursor:void 0===e.link.decorations||e.link.decorations.pointerCursor},isHovered:!0},this._linkHover(this._element,e.link,this._lastMouseEvent),e.link.decorations={},Object.defineProperties(e.link.decorations,{pointerCursor:{get:function(){var e,r;return null===(r=null===(e=t._currentLink)||void 0===e?void 0:e.state)||void 0===r?void 0:r.decorations.pointerCursor},set:function(e){var r,i;(null===(r=t._currentLink)||void 0===r?void 0:r.state)&&t._currentLink.state.decorations.pointerCursor!==e&&(t._currentLink.state.decorations.pointerCursor=e,t._currentLink.state.isHovered&&(null===(i=t._element)||void 0===i||i.classList.toggle("xterm-cursor-pointer",e)));}},underline:{get:function(){var e,r;return null===(r=null===(e=t._currentLink)||void 0===e?void 0:e.state)||void 0===r?void 0:r.decorations.underline},set:function(r){var i,n,o;(null===(i=t._currentLink)||void 0===i?void 0:i.state)&&(null===(o=null===(n=t._currentLink)||void 0===n?void 0:n.state)||void 0===o?void 0:o.decorations.underline)!==r&&(t._currentLink.state.decorations.underline=r,t._currentLink.state.isHovered&&t._fireUnderlineEvent(e.link,r));}}}),this._renderService&&this._linkCacheDisposables.push(this._renderService.onRenderedBufferChange((function(e){var r=0===e.start?0:e.start+1+t._bufferService.buffer.ydisp;t._clearCurrentLink(r,e.end+1+t._bufferService.buffer.ydisp);}))));}},t.prototype._linkHover=function(e,t,r){var i;(null===(i=this._currentLink)||void 0===i?void 0:i.state)&&(this._currentLink.state.isHovered=!0,this._currentLink.state.decorations.underline&&this._fireUnderlineEvent(t,!0),this._currentLink.state.decorations.pointerCursor&&e.classList.add("xterm-cursor-pointer")),t.hover&&t.hover(r,t.text);},t.prototype._fireUnderlineEvent=function(e,t){var r=e.range,i=this._bufferService.buffer.ydisp,n=this._createLinkUnderlineEvent(r.start.x-1,r.start.y-i-1,r.end.x,r.end.y-i-1,void 0);(t?this._onShowLinkUnderline:this._onHideLinkUnderline).fire(n);},t.prototype._linkLeave=function(e,t,r){var i;(null===(i=this._currentLink)||void 0===i?void 0:i.state)&&(this._currentLink.state.isHovered=!1,this._currentLink.state.decorations.underline&&this._fireUnderlineEvent(t,!1),this._currentLink.state.decorations.pointerCursor&&e.classList.remove("xterm-cursor-pointer")),t.leave&&t.leave(r,t.text);},t.prototype._linkAtPosition=function(e,t){var r=e.range.start.y===e.range.end.y,i=e.range.start.y<t.y,n=e.range.end.y>t.y;return (r&&e.range.start.x<=t.x&&e.range.end.x>=t.x||i&&e.range.end.x>=t.x||n&&e.range.start.x<=t.x||i&&n)&&e.range.start.y<=t.y&&e.range.end.y>=t.y},t.prototype._positionFromMouseEvent=function(e,t,r){var i=r.getCoords(e,t,this._bufferService.cols,this._bufferService.rows);if(i)return {x:i[0],y:i[1]+this._bufferService.buffer.ydisp}},t.prototype._createLinkUnderlineEvent=function(e,t,r,i,n){return {x1:e,y1:t,x2:r,y2:i,cols:this._bufferService.cols,fg:n}},t=o([s(0,a.IBufferService)],t)}(l.Disposable);t.Linkifier2=u;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.CoreBrowserService=void 0;var i=function(){function e(e){this._textarea=e;}return Object.defineProperty(e.prototype,"isFocused",{get:function(){return document.activeElement===this._textarea&&document.hasFocus()},enumerable:!1,configurable:!0}),e}();t.CoreBrowserService=i;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.CoreTerminal=void 0;var o=r(2),s=r(1),a=r(65),c=r(66),l=r(67),h=r(73),u=r(74),f=r(0),_=r(75),d=r(76),p=r(77),v=r(79),g=r(80),y=r(18),b=r(81),S=function(e){function t(t){var r=e.call(this)||this;return r._onBinary=new f.EventEmitter,r._onData=new f.EventEmitter,r._onLineFeed=new f.EventEmitter,r._onResize=new f.EventEmitter,r._onScroll=new f.EventEmitter,r._instantiationService=new a.InstantiationService,r.optionsService=new h.OptionsService(t),r._instantiationService.setService(s.IOptionsService,r.optionsService),r._bufferService=r.register(r._instantiationService.createInstance(l.BufferService)),r._instantiationService.setService(s.IBufferService,r._bufferService),r._logService=r._instantiationService.createInstance(c.LogService),r._instantiationService.setService(s.ILogService,r._logService),r._coreService=r.register(r._instantiationService.createInstance(u.CoreService,(function(){return r.scrollToBottom()}))),r._instantiationService.setService(s.ICoreService,r._coreService),r._coreMouseService=r._instantiationService.createInstance(_.CoreMouseService),r._instantiationService.setService(s.ICoreMouseService,r._coreMouseService),r._dirtyRowService=r._instantiationService.createInstance(d.DirtyRowService),r._instantiationService.setService(s.IDirtyRowService,r._dirtyRowService),r.unicodeService=r._instantiationService.createInstance(p.UnicodeService),r._instantiationService.setService(s.IUnicodeService,r.unicodeService),r._charsetService=r._instantiationService.createInstance(v.CharsetService),r._instantiationService.setService(s.ICharsetService,r._charsetService),r._inputHandler=new y.InputHandler(r._bufferService,r._charsetService,r._coreService,r._dirtyRowService,r._logService,r.optionsService,r._coreMouseService,r.unicodeService),r.register(f.forwardEvent(r._inputHandler.onLineFeed,r._onLineFeed)),r.register(r._inputHandler),r.register(f.forwardEvent(r._bufferService.onResize,r._onResize)),r.register(f.forwardEvent(r._coreService.onData,r._onData)),r.register(f.forwardEvent(r._coreService.onBinary,r._onBinary)),r.register(r.optionsService.onOptionChange((function(e){return r._updateOptions(e)}))),r._writeBuffer=new b.WriteBuffer((function(e){return r._inputHandler.parse(e)})),r}return n(t,e),Object.defineProperty(t.prototype,"onBinary",{get:function(){return this._onBinary.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onData",{get:function(){return this._onData.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onLineFeed",{get:function(){return this._onLineFeed.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onResize",{get:function(){return this._onResize.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onScroll",{get:function(){return this._onScroll.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"cols",{get:function(){return this._bufferService.cols},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"rows",{get:function(){return this._bufferService.rows},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"buffers",{get:function(){return this._bufferService.buffers},enumerable:!1,configurable:!0}),t.prototype.dispose=function(){var t;this._isDisposed||(e.prototype.dispose.call(this),null===(t=this._windowsMode)||void 0===t||t.dispose(),this._windowsMode=void 0);},t.prototype.write=function(e,t){this._writeBuffer.write(e,t);},t.prototype.writeSync=function(e){this._writeBuffer.writeSync(e);},t.prototype.resize=function(e,t){isNaN(e)||isNaN(t)||(e=Math.max(e,l.MINIMUM_COLS),t=Math.max(t,l.MINIMUM_ROWS),this._bufferService.resize(e,t));},t.prototype.scroll=function(e,t){void 0===t&&(t=!1);var r,i=this._bufferService.buffer;(r=this._cachedBlankLine)&&r.length===this.cols&&r.getFg(0)===e.fg&&r.getBg(0)===e.bg||(r=i.getBlankLine(e,t),this._cachedBlankLine=r),r.isWrapped=t;var n=i.ybase+i.scrollTop,o=i.ybase+i.scrollBottom;if(0===i.scrollTop){var s=i.lines.isFull;o===i.lines.length-1?s?i.lines.recycle().copyFrom(r):i.lines.push(r.clone()):i.lines.splice(o+1,0,r.clone()),s?this._bufferService.isUserScrolling&&(i.ydisp=Math.max(i.ydisp-1,0)):(i.ybase++,this._bufferService.isUserScrolling||i.ydisp++);}else {var a=o-n+1;i.lines.shiftElements(n+1,a-1,-1),i.lines.set(o,r.clone());}this._bufferService.isUserScrolling||(i.ydisp=i.ybase),this._dirtyRowService.markRangeDirty(i.scrollTop,i.scrollBottom),this._onScroll.fire(i.ydisp);},t.prototype.scrollLines=function(e,t){var r=this._bufferService.buffer;if(e<0){if(0===r.ydisp)return;this._bufferService.isUserScrolling=!0;}else e+r.ydisp>=r.ybase&&(this._bufferService.isUserScrolling=!1);var i=r.ydisp;r.ydisp=Math.max(Math.min(r.ydisp+e,r.ybase),0),i!==r.ydisp&&(t||this._onScroll.fire(r.ydisp));},t.prototype.scrollPages=function(e){this.scrollLines(e*(this.rows-1));},t.prototype.scrollToTop=function(){this.scrollLines(-this._bufferService.buffer.ydisp);},t.prototype.scrollToBottom=function(){this.scrollLines(this._bufferService.buffer.ybase-this._bufferService.buffer.ydisp);},t.prototype.scrollToLine=function(e){var t=e-this._bufferService.buffer.ydisp;0!==t&&this.scrollLines(t);},t.prototype.addEscHandler=function(e,t){return this._inputHandler.addEscHandler(e,t)},t.prototype.addDcsHandler=function(e,t){return this._inputHandler.addDcsHandler(e,t)},t.prototype.addCsiHandler=function(e,t){return this._inputHandler.addCsiHandler(e,t)},t.prototype.addOscHandler=function(e,t){return this._inputHandler.addOscHandler(e,t)},t.prototype._setup=function(){this.optionsService.options.windowsMode&&this._enableWindowsMode();},t.prototype.reset=function(){this._inputHandler.reset(),this._bufferService.reset(),this._charsetService.reset(),this._coreService.reset(),this._coreMouseService.reset();},t.prototype._updateOptions=function(e){var t;switch(e){case"scrollback":this.buffers.resize(this.cols,this.rows);break;case"windowsMode":this.optionsService.options.windowsMode?this._enableWindowsMode():(null===(t=this._windowsMode)||void 0===t||t.dispose(),this._windowsMode=void 0);}},t.prototype._enableWindowsMode=function(){var e=this;if(!this._windowsMode){var t=[];t.push(this.onLineFeed(g.updateWindowsModeWrappedState.bind(null,this._bufferService))),t.push(this.addCsiHandler({final:"H"},(function(){return g.updateWindowsModeWrappedState(e._bufferService),!1}))),this._windowsMode={dispose:function(){t.forEach((function(e){return e.dispose()}));}};}},t}(o.Disposable);t.CoreTerminal=S;},function(e,t,r){var i=this&&this.__spreadArrays||function(){for(var e=0,t=0,r=arguments.length;t<r;t++)e+=arguments[t].length;var i=Array(e),n=0;for(t=0;t<r;t++)for(var o=arguments[t],s=0,a=o.length;s<a;s++,n++)i[n]=o[s];return i};Object.defineProperty(t,"__esModule",{value:!0}),t.InstantiationService=t.ServiceCollection=void 0;var n=r(1),o=r(14),s=function(){function e(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this._entries=new Map;for(var r=0,i=e;r<i.length;r++){var n=i[r],o=n[0],s=n[1];this.set(o,s);}}return e.prototype.set=function(e,t){var r=this._entries.get(e);return this._entries.set(e,t),r},e.prototype.forEach=function(e){this._entries.forEach((function(t,r){return e(r,t)}));},e.prototype.has=function(e){return this._entries.has(e)},e.prototype.get=function(e){return this._entries.get(e)},e}();t.ServiceCollection=s;var a=function(){function e(){this._services=new s,this._services.set(n.IInstantiationService,this);}return e.prototype.setService=function(e,t){this._services.set(e,t);},e.prototype.getService=function(e){return this._services.get(e)},e.prototype.createInstance=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];for(var n=o.getServiceDependencies(e).sort((function(e,t){return e.index-t.index})),s=[],a=0,c=n;a<c.length;a++){var l=c[a],h=this._services.get(l.id);if(!h)throw new Error("[createInstance] "+e.name+" depends on UNKNOWN service "+l.id+".");s.push(h);}var u=n.length>0?n[0].index:t.length;if(t.length!==u)throw new Error("[createInstance] First service dependency of "+e.name+" at position "+(u+1)+" conflicts with "+t.length+" static arguments");return new(e.bind.apply(e,i([void 0],i(t,s))))},e}();t.InstantiationService=a;},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}},o=this&&this.__spreadArrays||function(){for(var e=0,t=0,r=arguments.length;t<r;t++)e+=arguments[t].length;var i=Array(e),n=0;for(t=0;t<r;t++)for(var o=arguments[t],s=0,a=o.length;s<a;s++,n++)i[n]=o[s];return i};Object.defineProperty(t,"__esModule",{value:!0}),t.LogService=t.LogLevel=void 0;var s,a=r(1);!function(e){e[e.DEBUG=0]="DEBUG",e[e.INFO=1]="INFO",e[e.WARN=2]="WARN",e[e.ERROR=3]="ERROR",e[e.OFF=4]="OFF";}(s=t.LogLevel||(t.LogLevel={}));var c={debug:s.DEBUG,info:s.INFO,warn:s.WARN,error:s.ERROR,off:s.OFF},l=function(){function e(e){var t=this;this._optionsService=e,this._updateLogLevel(),this._optionsService.onOptionChange((function(e){"logLevel"===e&&t._updateLogLevel();}));}return e.prototype._updateLogLevel=function(){this._logLevel=c[this._optionsService.options.logLevel];},e.prototype._evalLazyOptionalParams=function(e){for(var t=0;t<e.length;t++)"function"==typeof e[t]&&(e[t]=e[t]());},e.prototype._log=function(e,t,r){this._evalLazyOptionalParams(r),e.call.apply(e,o([console,"xterm.js: "+t],r));},e.prototype.debug=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];this._logLevel<=s.DEBUG&&this._log(console.log,e,t);},e.prototype.info=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];this._logLevel<=s.INFO&&this._log(console.info,e,t);},e.prototype.warn=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];this._logLevel<=s.WARN&&this._log(console.warn,e,t);},e.prototype.error=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];this._logLevel<=s.ERROR&&this._log(console.error,e,t);},e=i([n(0,a.IOptionsService)],e)}();t.LogService=l;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.BufferService=t.MINIMUM_ROWS=t.MINIMUM_COLS=void 0;var a=r(1),c=r(68),l=r(0),h=r(2);t.MINIMUM_COLS=2,t.MINIMUM_ROWS=1;var u=function(e){function r(r){var i=e.call(this)||this;return i._optionsService=r,i.isUserScrolling=!1,i._onResize=new l.EventEmitter,i.cols=Math.max(r.options.cols,t.MINIMUM_COLS),i.rows=Math.max(r.options.rows,t.MINIMUM_ROWS),i.buffers=new c.BufferSet(r,i),i}return n(r,e),Object.defineProperty(r.prototype,"onResize",{get:function(){return this._onResize.event},enumerable:!1,configurable:!0}),Object.defineProperty(r.prototype,"buffer",{get:function(){return this.buffers.active},enumerable:!1,configurable:!0}),r.prototype.dispose=function(){e.prototype.dispose.call(this),this.buffers.dispose();},r.prototype.resize=function(e,t){this.cols=e,this.rows=t,this.buffers.resize(e,t),this.buffers.setupTabStops(this.cols),this._onResize.fire({cols:e,rows:t});},r.prototype.reset=function(){this.buffers.dispose(),this.buffers=new c.BufferSet(this._optionsService,this),this.isUserScrolling=!1;},r=o([s(0,a.IOptionsService)],r)}(h.Disposable);t.BufferService=u;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.BufferSet=void 0;var o=r(69),s=r(0),a=function(e){function t(t,r){var i=e.call(this)||this;return i._onBufferActivate=i.register(new s.EventEmitter),i._normal=new o.Buffer(!0,t,r),i._normal.fillViewportRows(),i._alt=new o.Buffer(!1,t,r),i._activeBuffer=i._normal,i.setupTabStops(),i}return n(t,e),Object.defineProperty(t.prototype,"onBufferActivate",{get:function(){return this._onBufferActivate.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"alt",{get:function(){return this._alt},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"active",{get:function(){return this._activeBuffer},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"normal",{get:function(){return this._normal},enumerable:!1,configurable:!0}),t.prototype.activateNormalBuffer=function(){this._activeBuffer!==this._normal&&(this._normal.x=this._alt.x,this._normal.y=this._alt.y,this._alt.clear(),this._activeBuffer=this._normal,this._onBufferActivate.fire({activeBuffer:this._normal,inactiveBuffer:this._alt}));},t.prototype.activateAltBuffer=function(e){this._activeBuffer!==this._alt&&(this._alt.fillViewportRows(e),this._alt.x=this._normal.x,this._alt.y=this._normal.y,this._activeBuffer=this._alt,this._onBufferActivate.fire({activeBuffer:this._alt,inactiveBuffer:this._normal}));},t.prototype.resize=function(e,t){this._normal.resize(e,t),this._alt.resize(e,t);},t.prototype.setupTabStops=function(e){this._normal.setupTabStops(e),this._alt.setupTabStops(e);},t}(r(2).Disposable);t.BufferSet=a;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.BufferStringIterator=t.Buffer=t.MAX_BUFFER_SIZE=void 0;var i=r(70),n=r(16),o=r(4),s=r(3),a=r(71),c=r(72),l=r(19),h=r(6);t.MAX_BUFFER_SIZE=4294967295;var u=function(){function e(e,t,r){this._hasScrollback=e,this._optionsService=t,this._bufferService=r,this.ydisp=0,this.ybase=0,this.y=0,this.x=0,this.savedY=0,this.savedX=0,this.savedCurAttrData=n.DEFAULT_ATTR_DATA.clone(),this.savedCharset=l.DEFAULT_CHARSET,this.markers=[],this._nullCell=o.CellData.fromCharData([0,s.NULL_CELL_CHAR,s.NULL_CELL_WIDTH,s.NULL_CELL_CODE]),this._whitespaceCell=o.CellData.fromCharData([0,s.WHITESPACE_CELL_CHAR,s.WHITESPACE_CELL_WIDTH,s.WHITESPACE_CELL_CODE]),this._cols=this._bufferService.cols,this._rows=this._bufferService.rows,this.lines=new i.CircularList(this._getCorrectBufferLength(this._rows)),this.scrollTop=0,this.scrollBottom=this._rows-1,this.setupTabStops();}return e.prototype.getNullCell=function(e){return e?(this._nullCell.fg=e.fg,this._nullCell.bg=e.bg,this._nullCell.extended=e.extended):(this._nullCell.fg=0,this._nullCell.bg=0,this._nullCell.extended=new h.ExtendedAttrs),this._nullCell},e.prototype.getWhitespaceCell=function(e){return e?(this._whitespaceCell.fg=e.fg,this._whitespaceCell.bg=e.bg,this._whitespaceCell.extended=e.extended):(this._whitespaceCell.fg=0,this._whitespaceCell.bg=0,this._whitespaceCell.extended=new h.ExtendedAttrs),this._whitespaceCell},e.prototype.getBlankLine=function(e,t){return new n.BufferLine(this._bufferService.cols,this.getNullCell(e),t)},Object.defineProperty(e.prototype,"hasScrollback",{get:function(){return this._hasScrollback&&this.lines.maxLength>this._rows},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"isCursorInViewport",{get:function(){var e=this.ybase+this.y-this.ydisp;return e>=0&&e<this._rows},enumerable:!1,configurable:!0}),e.prototype._getCorrectBufferLength=function(e){if(!this._hasScrollback)return e;var r=e+this._optionsService.options.scrollback;return r>t.MAX_BUFFER_SIZE?t.MAX_BUFFER_SIZE:r},e.prototype.fillViewportRows=function(e){if(0===this.lines.length){void 0===e&&(e=n.DEFAULT_ATTR_DATA);for(var t=this._rows;t--;)this.lines.push(this.getBlankLine(e));}},e.prototype.clear=function(){this.ydisp=0,this.ybase=0,this.y=0,this.x=0,this.lines=new i.CircularList(this._getCorrectBufferLength(this._rows)),this.scrollTop=0,this.scrollBottom=this._rows-1,this.setupTabStops();},e.prototype.resize=function(e,t){var r=this.getNullCell(n.DEFAULT_ATTR_DATA),i=this._getCorrectBufferLength(t);if(i>this.lines.maxLength&&(this.lines.maxLength=i),this.lines.length>0){if(this._cols<e)for(var o=0;o<this.lines.length;o++)this.lines.get(o).resize(e,r);var s=0;if(this._rows<t)for(var a=this._rows;a<t;a++)this.lines.length<t+this.ybase&&(this._optionsService.options.windowsMode?this.lines.push(new n.BufferLine(e,r)):this.ybase>0&&this.lines.length<=this.ybase+this.y+s+1?(this.ybase--,s++,this.ydisp>0&&this.ydisp--):this.lines.push(new n.BufferLine(e,r)));else for(a=this._rows;a>t;a--)this.lines.length>t+this.ybase&&(this.lines.length>this.ybase+this.y+1?this.lines.pop():(this.ybase++,this.ydisp++));if(i<this.lines.maxLength){var c=this.lines.length-i;c>0&&(this.lines.trimStart(c),this.ybase=Math.max(this.ybase-c,0),this.ydisp=Math.max(this.ydisp-c,0),this.savedY=Math.max(this.savedY-c,0)),this.lines.maxLength=i;}this.x=Math.min(this.x,e-1),this.y=Math.min(this.y,t-1),s&&(this.y+=s),this.savedX=Math.min(this.savedX,e-1),this.scrollTop=0;}if(this.scrollBottom=t-1,this._isReflowEnabled&&(this._reflow(e,t),this._cols>e))for(o=0;o<this.lines.length;o++)this.lines.get(o).resize(e,r);this._cols=e,this._rows=t;},Object.defineProperty(e.prototype,"_isReflowEnabled",{get:function(){return this._hasScrollback&&!this._optionsService.options.windowsMode},enumerable:!1,configurable:!0}),e.prototype._reflow=function(e,t){this._cols!==e&&(e>this._cols?this._reflowLarger(e,t):this._reflowSmaller(e,t));},e.prototype._reflowLarger=function(e,t){var r=a.reflowLargerGetLinesToRemove(this.lines,this._cols,e,this.ybase+this.y,this.getNullCell(n.DEFAULT_ATTR_DATA));if(r.length>0){var i=a.reflowLargerCreateNewLayout(this.lines,r);a.reflowLargerApplyNewLayout(this.lines,i.layout),this._reflowLargerAdjustViewport(e,t,i.countRemoved);}},e.prototype._reflowLargerAdjustViewport=function(e,t,r){for(var i=this.getNullCell(n.DEFAULT_ATTR_DATA),o=r;o-- >0;)0===this.ybase?(this.y>0&&this.y--,this.lines.length<t&&this.lines.push(new n.BufferLine(e,i))):(this.ydisp===this.ybase&&this.ydisp--,this.ybase--);this.savedY=Math.max(this.savedY-r,0);},e.prototype._reflowSmaller=function(e,t){for(var r=this.getNullCell(n.DEFAULT_ATTR_DATA),i=[],o=0,s=this.lines.length-1;s>=0;s--){var c=this.lines.get(s);if(!(!c||!c.isWrapped&&c.getTrimmedLength()<=e)){for(var l=[c];c.isWrapped&&s>0;)c=this.lines.get(--s),l.unshift(c);var h=this.ybase+this.y;if(!(h>=s&&h<s+l.length)){var u=l[l.length-1].getTrimmedLength(),f=a.reflowSmallerGetNewLineLengths(l,this._cols,e),_=f.length-l.length,d=void 0;d=0===this.ybase&&this.y!==this.lines.length-1?Math.max(0,this.y-this.lines.maxLength+_):Math.max(0,this.lines.length-this.lines.maxLength+_);for(var p=[],v=0;v<_;v++){var g=this.getBlankLine(n.DEFAULT_ATTR_DATA,!0);p.push(g);}p.length>0&&(i.push({start:s+l.length+o,newLines:p}),o+=p.length),l.push.apply(l,p);var y=f.length-1,b=f[y];0===b&&(b=f[--y]);for(var S=l.length-_-1,m=u;S>=0;){var C=Math.min(m,b);if(l[y].copyCellsFrom(l[S],m-C,b-C,C,!0),0===(b-=C)&&(b=f[--y]),0===(m-=C)){S--;var w=Math.max(S,0);m=a.getWrappedLineTrimmedLength(l,w,this._cols);}}for(v=0;v<l.length;v++)f[v]<e&&l[v].setCell(f[v],r);for(var E=_-d;E-- >0;)0===this.ybase?this.y<t-1?(this.y++,this.lines.pop()):(this.ybase++,this.ydisp++):this.ybase<Math.min(this.lines.maxLength,this.lines.length+o)-t&&(this.ybase===this.ydisp&&this.ydisp++,this.ybase++);this.savedY=Math.min(this.savedY+_,this.ybase+t-1);}}}if(i.length>0){var L=[],A=[];for(v=0;v<this.lines.length;v++)A.push(this.lines.get(v));var R=this.lines.length,k=R-1,x=0,D=i[x];this.lines.length=Math.min(this.lines.maxLength,this.lines.length+o);var T=0;for(v=Math.min(this.lines.maxLength-1,R+o-1);v>=0;v--)if(D&&D.start>k+T){for(var O=D.newLines.length-1;O>=0;O--)this.lines.set(v--,D.newLines[O]);v++,L.push({index:k+1,amount:D.newLines.length}),T+=D.newLines.length,D=i[++x];}else this.lines.set(v,A[k--]);var M=0;for(v=L.length-1;v>=0;v--)L[v].index+=M,this.lines.onInsertEmitter.fire(L[v]),M+=L[v].amount;var P=Math.max(0,R+o-this.lines.maxLength);P>0&&this.lines.onTrimEmitter.fire(P);}},e.prototype.stringIndexToBufferIndex=function(e,t,r){for(void 0===r&&(r=!1);t;){var i=this.lines.get(e);if(!i)return [-1,-1];for(var n=r?i.getTrimmedLength():i.length,o=0;o<n;++o)if(i.get(o)[s.CHAR_DATA_WIDTH_INDEX]&&(t-=i.get(o)[s.CHAR_DATA_CHAR_INDEX].length||1),t<0)return [e,o];e++;}return [e,0]},e.prototype.translateBufferLineToString=function(e,t,r,i){void 0===r&&(r=0);var n=this.lines.get(e);return n?n.translateToString(t,r,i):""},e.prototype.getWrappedRangeForLine=function(e){for(var t=e,r=e;t>0&&this.lines.get(t).isWrapped;)t--;for(;r+1<this.lines.length&&this.lines.get(r+1).isWrapped;)r++;return {first:t,last:r}},e.prototype.setupTabStops=function(e){for(null!=e?this.tabs[e]||(e=this.prevStop(e)):(this.tabs={},e=0);e<this._cols;e+=this._optionsService.options.tabStopWidth)this.tabs[e]=!0;},e.prototype.prevStop=function(e){for(null==e&&(e=this.x);!this.tabs[--e]&&e>0;);return e>=this._cols?this._cols-1:e<0?0:e},e.prototype.nextStop=function(e){for(null==e&&(e=this.x);!this.tabs[++e]&&e<this._cols;);return e>=this._cols?this._cols-1:e<0?0:e},e.prototype.addMarker=function(e){var t=this,r=new c.Marker(e);return this.markers.push(r),r.register(this.lines.onTrim((function(e){r.line-=e,r.line<0&&r.dispose();}))),r.register(this.lines.onInsert((function(e){r.line>=e.index&&(r.line+=e.amount);}))),r.register(this.lines.onDelete((function(e){r.line>=e.index&&r.line<e.index+e.amount&&r.dispose(),r.line>e.index&&(r.line-=e.amount);}))),r.register(r.onDispose((function(){return t._removeMarker(r)}))),r},e.prototype._removeMarker=function(e){this.markers.splice(this.markers.indexOf(e),1);},e.prototype.iterator=function(e,t,r,i,n){return new f(this,e,t,r,i,n)},e}();t.Buffer=u;var f=function(){function e(e,t,r,i,n,o){void 0===r&&(r=0),void 0===i&&(i=e.lines.length),void 0===n&&(n=0),void 0===o&&(o=0),this._buffer=e,this._trimRight=t,this._startIndex=r,this._endIndex=i,this._startOverscan=n,this._endOverscan=o,this._startIndex<0&&(this._startIndex=0),this._endIndex>this._buffer.lines.length&&(this._endIndex=this._buffer.lines.length),this._current=this._startIndex;}return e.prototype.hasNext=function(){return this._current<this._endIndex},e.prototype.next=function(){var e=this._buffer.getWrappedRangeForLine(this._current);e.first<this._startIndex-this._startOverscan&&(e.first=this._startIndex-this._startOverscan),e.last>this._endIndex+this._endOverscan&&(e.last=this._endIndex+this._endOverscan),e.first=Math.max(e.first,0),e.last=Math.min(e.last,this._buffer.lines.length);for(var t="",r=e.first;r<=e.last;++r)t+=this._buffer.translateBufferLineToString(r,this._trimRight);return this._current=e.last+1,{range:e,content:t}},e}();t.BufferStringIterator=f;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.CircularList=void 0;var i=r(0),n=function(){function e(e){this._maxLength=e,this.onDeleteEmitter=new i.EventEmitter,this.onInsertEmitter=new i.EventEmitter,this.onTrimEmitter=new i.EventEmitter,this._array=new Array(this._maxLength),this._startIndex=0,this._length=0;}return Object.defineProperty(e.prototype,"onDelete",{get:function(){return this.onDeleteEmitter.event},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onInsert",{get:function(){return this.onInsertEmitter.event},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onTrim",{get:function(){return this.onTrimEmitter.event},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"maxLength",{get:function(){return this._maxLength},set:function(e){if(this._maxLength!==e){for(var t=new Array(e),r=0;r<Math.min(e,this.length);r++)t[r]=this._array[this._getCyclicIndex(r)];this._array=t,this._maxLength=e,this._startIndex=0;}},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"length",{get:function(){return this._length},set:function(e){if(e>this._length)for(var t=this._length;t<e;t++)this._array[t]=void 0;this._length=e;},enumerable:!1,configurable:!0}),e.prototype.get=function(e){return this._array[this._getCyclicIndex(e)]},e.prototype.set=function(e,t){this._array[this._getCyclicIndex(e)]=t;},e.prototype.push=function(e){this._array[this._getCyclicIndex(this._length)]=e,this._length===this._maxLength?(this._startIndex=++this._startIndex%this._maxLength,this.onTrimEmitter.fire(1)):this._length++;},e.prototype.recycle=function(){if(this._length!==this._maxLength)throw new Error("Can only recycle when the buffer is full");return this._startIndex=++this._startIndex%this._maxLength,this.onTrimEmitter.fire(1),this._array[this._getCyclicIndex(this._length-1)]},Object.defineProperty(e.prototype,"isFull",{get:function(){return this._length===this._maxLength},enumerable:!1,configurable:!0}),e.prototype.pop=function(){return this._array[this._getCyclicIndex(this._length---1)]},e.prototype.splice=function(e,t){for(var r=[],i=2;i<arguments.length;i++)r[i-2]=arguments[i];if(t){for(var n=e;n<this._length-t;n++)this._array[this._getCyclicIndex(n)]=this._array[this._getCyclicIndex(n+t)];this._length-=t;}for(n=this._length-1;n>=e;n--)this._array[this._getCyclicIndex(n+r.length)]=this._array[this._getCyclicIndex(n)];for(n=0;n<r.length;n++)this._array[this._getCyclicIndex(e+n)]=r[n];if(this._length+r.length>this._maxLength){var o=this._length+r.length-this._maxLength;this._startIndex+=o,this._length=this._maxLength,this.onTrimEmitter.fire(o);}else this._length+=r.length;},e.prototype.trimStart=function(e){e>this._length&&(e=this._length),this._startIndex+=e,this._length-=e,this.onTrimEmitter.fire(e);},e.prototype.shiftElements=function(e,t,r){if(!(t<=0)){if(e<0||e>=this._length)throw new Error("start argument out of range");if(e+r<0)throw new Error("Cannot shift elements in list beyond index 0");if(r>0){for(var i=t-1;i>=0;i--)this.set(e+i+r,this.get(e+i));var n=e+t+r-this._length;if(n>0)for(this._length+=n;this._length>this._maxLength;)this._length--,this._startIndex++,this.onTrimEmitter.fire(1);}else for(i=0;i<t;i++)this.set(e+i+r,this.get(e+i));}},e.prototype._getCyclicIndex=function(e){return (this._startIndex+e)%this._maxLength},e}();t.CircularList=n;},function(e,t,r){function i(e,t,r){if(t===e.length-1)return e[t].getTrimmedLength();var i=!e[t].hasContent(r-1)&&1===e[t].getWidth(r-1),n=2===e[t+1].getWidth(0);return i&&n?r-1:r}Object.defineProperty(t,"__esModule",{value:!0}),t.getWrappedLineTrimmedLength=t.reflowSmallerGetNewLineLengths=t.reflowLargerApplyNewLayout=t.reflowLargerCreateNewLayout=t.reflowLargerGetLinesToRemove=void 0,t.reflowLargerGetLinesToRemove=function(e,t,r,n,o){for(var s=[],a=0;a<e.length-1;a++){var c=a,l=e.get(++c);if(l.isWrapped){for(var h=[e.get(a)];c<e.length&&l.isWrapped;)h.push(l),l=e.get(++c);if(n>=a&&n<c)a+=h.length-1;else {for(var u=0,f=i(h,u,t),_=1,d=0;_<h.length;){var p=i(h,_,t),v=p-d,g=r-f,y=Math.min(v,g);h[u].copyCellsFrom(h[_],d,f,y,!1),(f+=y)===r&&(u++,f=0),(d+=y)===p&&(_++,d=0),0===f&&0!==u&&2===h[u-1].getWidth(r-1)&&(h[u].copyCellsFrom(h[u-1],r-1,f++,1,!1),h[u-1].setCell(r-1,o));}h[u].replaceCells(f,r,o);for(var b=0,S=h.length-1;S>0&&(S>u||0===h[S].getTrimmedLength());S--)b++;b>0&&(s.push(a+h.length-b),s.push(b)),a+=h.length-1;}}}return s},t.reflowLargerCreateNewLayout=function(e,t){for(var r=[],i=0,n=t[i],o=0,s=0;s<e.length;s++)if(n===s){var a=t[++i];e.onDeleteEmitter.fire({index:s-o,amount:a}),s+=a-1,o+=a,n=t[++i];}else r.push(s);return {layout:r,countRemoved:o}},t.reflowLargerApplyNewLayout=function(e,t){for(var r=[],i=0;i<t.length;i++)r.push(e.get(t[i]));for(i=0;i<r.length;i++)e.set(i,r[i]);e.length=t.length;},t.reflowSmallerGetNewLineLengths=function(e,t,r){for(var n=[],o=e.map((function(r,n){return i(e,n,t)})).reduce((function(e,t){return e+t})),s=0,a=0,c=0;c<o;){if(o-c<r){n.push(o-c);break}s+=r;var l=i(e,a,t);s>l&&(s-=l,a++);var h=2===e[a].getWidth(s-1);h&&s--;var u=h?r-1:r;n.push(u),c+=u;}return n},t.getWrappedLineTrimmedLength=i;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);});Object.defineProperty(t,"__esModule",{value:!0}),t.Marker=void 0;var o=r(0),s=function(e){function t(r){var i=e.call(this)||this;return i.line=r,i._id=t._nextId++,i.isDisposed=!1,i._onDispose=new o.EventEmitter,i}return n(t,e),Object.defineProperty(t.prototype,"id",{get:function(){return this._id},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onDispose",{get:function(){return this._onDispose.event},enumerable:!1,configurable:!0}),t.prototype.dispose=function(){this.isDisposed||(this.isDisposed=!0,this.line=-1,this._onDispose.fire());},t._nextId=1,t}(r(2).Disposable);t.Marker=s;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.OptionsService=t.DEFAULT_OPTIONS=t.DEFAULT_BELL_SOUND=void 0;var i=r(0),n=r(11),o=r(32);t.DEFAULT_BELL_SOUND="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjMyLjEwNAAAAAAAAAAAAAAA//tQxAADB8AhSmxhIIEVCSiJrDCQBTcu3UrAIwUdkRgQbFAZC1CQEwTJ9mjRvBA4UOLD8nKVOWfh+UlK3z/177OXrfOdKl7pyn3Xf//WreyTRUoAWgBgkOAGbZHBgG1OF6zM82DWbZaUmMBptgQhGjsyYqc9ae9XFz280948NMBWInljyzsNRFLPWdnZGWrddDsjK1unuSrVN9jJsK8KuQtQCtMBjCEtImISdNKJOopIpBFpNSMbIHCSRpRR5iakjTiyzLhchUUBwCgyKiweBv/7UsQbg8isVNoMPMjAAAA0gAAABEVFGmgqK////9bP/6XCykxBTUUzLjEwMKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",t.DEFAULT_OPTIONS=Object.freeze({cols:80,rows:24,cursorBlink:!1,cursorStyle:"block",cursorWidth:1,bellSound:t.DEFAULT_BELL_SOUND,bellStyle:"none",drawBoldTextInBrightColors:!0,fastScrollModifier:"alt",fastScrollSensitivity:5,fontFamily:"courier-new, courier, monospace",fontSize:15,fontWeight:"normal",fontWeightBold:"bold",lineHeight:1,linkTooltipHoverDuration:500,letterSpacing:0,logLevel:"info",scrollback:1e3,scrollSensitivity:1,screenReaderMode:!1,macOptionIsMeta:!1,macOptionClickForcesSelection:!1,minimumContrastRatio:1,disableStdin:!1,allowProposedApi:!0,allowTransparency:!1,tabStopWidth:8,theme:{},rightClickSelectsWord:n.isMac,rendererType:"canvas",windowOptions:{},windowsMode:!1,wordSeparator:" ()[]{}',\"`",convertEol:!1,termName:"xterm",cancelEvents:!1});var s=["cols","rows"],a=function(){function e(e){var r=this;this._onOptionChange=new i.EventEmitter,this.options=o.clone(t.DEFAULT_OPTIONS),Object.keys(e).forEach((function(t){if(t in r.options){var i=e[t];r.options[t]=i;}}));}return Object.defineProperty(e.prototype,"onOptionChange",{get:function(){return this._onOptionChange.event},enumerable:!1,configurable:!0}),e.prototype.setOption=function(e,r){if(!(e in t.DEFAULT_OPTIONS))throw new Error('No option with key "'+e+'"');if(-1!==s.indexOf(e))throw new Error('Option "'+e+'" can only be set in the constructor');this.options[e]!==r&&(r=this._sanitizeAndValidateOption(e,r),this.options[e]!==r&&(this.options[e]=r,this._onOptionChange.fire(e)));},e.prototype._sanitizeAndValidateOption=function(e,r){switch(e){case"bellStyle":case"cursorStyle":case"fontWeight":case"fontWeightBold":case"rendererType":case"wordSeparator":r||(r=t.DEFAULT_OPTIONS[e]);break;case"cursorWidth":r=Math.floor(r);case"lineHeight":case"tabStopWidth":if(r<1)throw new Error(e+" cannot be less than 1, value: "+r);break;case"minimumContrastRatio":r=Math.max(1,Math.min(21,Math.round(10*r)/10));break;case"scrollback":if((r=Math.min(r,4294967295))<0)throw new Error(e+" cannot be less than 0, value: "+r);break;case"fastScrollSensitivity":case"scrollSensitivity":if(r<=0)throw new Error(e+" cannot be less than or equal to 0, value: "+r)}return r},e.prototype.getOption=function(e){if(!(e in t.DEFAULT_OPTIONS))throw new Error('No option with key "'+e+'"');return this.options[e]},e}();t.OptionsService=a;},function(e,t,r){var i,n=this&&this.__extends||(i=function(e,t){return (i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t;}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);})(e,t)},function(e,t){function r(){this.constructor=e;}i(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r);}),o=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},s=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.CoreService=void 0;var a=r(1),c=r(0),l=r(32),h=r(2),u=Object.freeze({insertMode:!1}),f=Object.freeze({applicationCursorKeys:!1,applicationKeypad:!1,bracketedPasteMode:!1,origin:!1,reverseWraparound:!1,sendFocus:!1,wraparound:!0}),_=function(e){function t(t,r,i,n){var o=e.call(this)||this;return o._bufferService=r,o._logService=i,o._optionsService=n,o.isCursorInitialized=!1,o.isCursorHidden=!1,o._onData=o.register(new c.EventEmitter),o._onUserInput=o.register(new c.EventEmitter),o._onBinary=o.register(new c.EventEmitter),o._scrollToBottom=t,o.register({dispose:function(){return o._scrollToBottom=void 0}}),o.modes=l.clone(u),o.decPrivateModes=l.clone(f),o}return n(t,e),Object.defineProperty(t.prototype,"onData",{get:function(){return this._onData.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onUserInput",{get:function(){return this._onUserInput.event},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"onBinary",{get:function(){return this._onBinary.event},enumerable:!1,configurable:!0}),t.prototype.reset=function(){this.modes=l.clone(u),this.decPrivateModes=l.clone(f);},t.prototype.triggerDataEvent=function(e,t){if(void 0===t&&(t=!1),!this._optionsService.options.disableStdin){var r=this._bufferService.buffer;r.ybase!==r.ydisp&&this._scrollToBottom(),t&&this._onUserInput.fire(),this._logService.debug('sending data "'+e+'"',(function(){return e.split("").map((function(e){return e.charCodeAt(0)}))})),this._onData.fire(e);}},t.prototype.triggerBinaryEvent=function(e){this._optionsService.options.disableStdin||(this._logService.debug('sending binary "'+e+'"',(function(){return e.split("").map((function(e){return e.charCodeAt(0)}))})),this._onBinary.fire(e));},t=o([s(1,a.IBufferService),s(2,a.ILogService),s(3,a.IOptionsService)],t)}(h.Disposable);t.CoreService=_;},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.CoreMouseService=void 0;var o=r(1),s=r(0),a={NONE:{events:0,restrict:function(){return !1}},X10:{events:1,restrict:function(e){return 4!==e.button&&1===e.action&&(e.ctrl=!1,e.alt=!1,e.shift=!1,!0)}},VT200:{events:19,restrict:function(e){return 32!==e.action}},DRAG:{events:23,restrict:function(e){return 32!==e.action||3!==e.button}},ANY:{events:31,restrict:function(e){return !0}}};function c(e,t){var r=(e.ctrl?16:0)|(e.shift?4:0)|(e.alt?8:0);return 4===e.button?(r|=64,r|=e.action):(r|=3&e.button,4&e.button&&(r|=64),8&e.button&&(r|=128),32===e.action?r|=32:0!==e.action||t||(r|=3)),r}var l=String.fromCharCode,h={DEFAULT:function(e){var t=[c(e,!1)+32,e.col+32,e.row+32];return t[0]>255||t[1]>255||t[2]>255?"":"[M"+l(t[0])+l(t[1])+l(t[2])},SGR:function(e){var t=0===e.action&&4!==e.button?"m":"M";return "[<"+c(e,!0)+";"+e.col+";"+e.row+t}},u=function(){function e(e,t){var r=this;this._bufferService=e,this._coreService=t,this._protocols={},this._encodings={},this._activeProtocol="",this._activeEncoding="",this._onProtocolChange=new s.EventEmitter,this._lastEvent=null,Object.keys(a).forEach((function(e){return r.addProtocol(e,a[e])})),Object.keys(h).forEach((function(e){return r.addEncoding(e,h[e])})),this.reset();}return e.prototype.addProtocol=function(e,t){this._protocols[e]=t;},e.prototype.addEncoding=function(e,t){this._encodings[e]=t;},Object.defineProperty(e.prototype,"activeProtocol",{get:function(){return this._activeProtocol},set:function(e){if(!this._protocols[e])throw new Error('unknown protocol "'+e+'"');this._activeProtocol=e,this._onProtocolChange.fire(this._protocols[e].events);},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"areMouseEventsActive",{get:function(){return 0!==this._protocols[this._activeProtocol].events},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"activeEncoding",{get:function(){return this._activeEncoding},set:function(e){if(!this._encodings[e])throw new Error('unknown encoding "'+e+'"');this._activeEncoding=e;},enumerable:!1,configurable:!0}),e.prototype.reset=function(){this.activeProtocol="NONE",this.activeEncoding="DEFAULT",this._lastEvent=null;},Object.defineProperty(e.prototype,"onProtocolChange",{get:function(){return this._onProtocolChange.event},enumerable:!1,configurable:!0}),e.prototype.triggerMouseEvent=function(e){if(e.col<0||e.col>=this._bufferService.cols||e.row<0||e.row>=this._bufferService.rows)return !1;if(4===e.button&&32===e.action)return !1;if(3===e.button&&32!==e.action)return !1;if(4!==e.button&&(2===e.action||3===e.action))return !1;if(e.col++,e.row++,32===e.action&&this._lastEvent&&this._compareEvents(this._lastEvent,e))return !1;if(!this._protocols[this._activeProtocol].restrict(e))return !1;var t=this._encodings[this._activeEncoding](e);return t&&("DEFAULT"===this._activeEncoding?this._coreService.triggerBinaryEvent(t):this._coreService.triggerDataEvent(t,!0)),this._lastEvent=e,!0},e.prototype.explainEvents=function(e){return {down:!!(1&e),up:!!(2&e),drag:!!(4&e),move:!!(8&e),wheel:!!(16&e)}},e.prototype._compareEvents=function(e,t){return e.col===t.col&&(e.row===t.row&&(e.button===t.button&&(e.action===t.action&&(e.ctrl===t.ctrl&&(e.alt===t.alt&&e.shift===t.shift)))))},e=i([n(0,o.IBufferService),n(1,o.ICoreService)],e)}();t.CoreMouseService=u;},function(e,t,r){var i=this&&this.__decorate||function(e,t,r,i){var n,o=arguments.length,s=o<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,r,i);else for(var a=e.length-1;a>=0;a--)(n=e[a])&&(s=(o<3?n(s):o>3?n(t,r,s):n(t,r))||s);return o>3&&s&&Object.defineProperty(t,r,s),s},n=this&&this.__param||function(e,t){return function(r,i){t(r,i,e);}};Object.defineProperty(t,"__esModule",{value:!0}),t.DirtyRowService=void 0;var o=r(1),s=function(){function e(e){this._bufferService=e,this.clearRange();}return Object.defineProperty(e.prototype,"start",{get:function(){return this._start},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"end",{get:function(){return this._end},enumerable:!1,configurable:!0}),e.prototype.clearRange=function(){this._start=this._bufferService.buffer.y,this._end=this._bufferService.buffer.y;},e.prototype.markDirty=function(e){e<this._start?this._start=e:e>this._end&&(this._end=e);},e.prototype.markRangeDirty=function(e,t){if(e>t){var r=e;e=t,t=r;}e<this._start&&(this._start=e),t>this._end&&(this._end=t);},e.prototype.markAllDirty=function(){this.markRangeDirty(0,this._bufferService.rows-1);},e=i([n(0,o.IBufferService)],e)}();t.DirtyRowService=s;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.UnicodeService=void 0;var i=r(0),n=r(78),o=function(){function e(){this._providers=Object.create(null),this._active="",this._onChange=new i.EventEmitter;var e=new n.UnicodeV6;this.register(e),this._active=e.version,this._activeProvider=e;}return Object.defineProperty(e.prototype,"onChange",{get:function(){return this._onChange.event},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"versions",{get:function(){return Object.keys(this._providers)},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"activeVersion",{get:function(){return this._active},set:function(e){if(!this._providers[e])throw new Error('unknown Unicode version "'+e+'"');this._active=e,this._activeProvider=this._providers[e],this._onChange.fire(e);},enumerable:!1,configurable:!0}),e.prototype.register=function(e){this._providers[e.version]=e;},e.prototype.wcwidth=function(e){return this._activeProvider.wcwidth(e)},e.prototype.getStringCellWidth=function(e){for(var t=0,r=e.length,i=0;i<r;++i){var n=e.charCodeAt(i);if(55296<=n&&n<=56319){if(++i>=r)return t+this.wcwidth(n);var o=e.charCodeAt(i);56320<=o&&o<=57343?n=1024*(n-55296)+o-56320+65536:t+=this.wcwidth(o);}t+=this.wcwidth(n);}return t},e}();t.UnicodeService=o;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.UnicodeV6=void 0;var i,n=r(15),o=[[768,879],[1155,1158],[1160,1161],[1425,1469],[1471,1471],[1473,1474],[1476,1477],[1479,1479],[1536,1539],[1552,1557],[1611,1630],[1648,1648],[1750,1764],[1767,1768],[1770,1773],[1807,1807],[1809,1809],[1840,1866],[1958,1968],[2027,2035],[2305,2306],[2364,2364],[2369,2376],[2381,2381],[2385,2388],[2402,2403],[2433,2433],[2492,2492],[2497,2500],[2509,2509],[2530,2531],[2561,2562],[2620,2620],[2625,2626],[2631,2632],[2635,2637],[2672,2673],[2689,2690],[2748,2748],[2753,2757],[2759,2760],[2765,2765],[2786,2787],[2817,2817],[2876,2876],[2879,2879],[2881,2883],[2893,2893],[2902,2902],[2946,2946],[3008,3008],[3021,3021],[3134,3136],[3142,3144],[3146,3149],[3157,3158],[3260,3260],[3263,3263],[3270,3270],[3276,3277],[3298,3299],[3393,3395],[3405,3405],[3530,3530],[3538,3540],[3542,3542],[3633,3633],[3636,3642],[3655,3662],[3761,3761],[3764,3769],[3771,3772],[3784,3789],[3864,3865],[3893,3893],[3895,3895],[3897,3897],[3953,3966],[3968,3972],[3974,3975],[3984,3991],[3993,4028],[4038,4038],[4141,4144],[4146,4146],[4150,4151],[4153,4153],[4184,4185],[4448,4607],[4959,4959],[5906,5908],[5938,5940],[5970,5971],[6002,6003],[6068,6069],[6071,6077],[6086,6086],[6089,6099],[6109,6109],[6155,6157],[6313,6313],[6432,6434],[6439,6440],[6450,6450],[6457,6459],[6679,6680],[6912,6915],[6964,6964],[6966,6970],[6972,6972],[6978,6978],[7019,7027],[7616,7626],[7678,7679],[8203,8207],[8234,8238],[8288,8291],[8298,8303],[8400,8431],[12330,12335],[12441,12442],[43014,43014],[43019,43019],[43045,43046],[64286,64286],[65024,65039],[65056,65059],[65279,65279],[65529,65531]],s=[[68097,68099],[68101,68102],[68108,68111],[68152,68154],[68159,68159],[119143,119145],[119155,119170],[119173,119179],[119210,119213],[119362,119364],[917505,917505],[917536,917631],[917760,917999]];var a=function(){function e(){if(this.version="6",!i){i=new Uint8Array(65536),n.fill(i,1),i[0]=0,n.fill(i,0,1,32),n.fill(i,0,127,160),n.fill(i,2,4352,4448),i[9001]=2,i[9002]=2,n.fill(i,2,11904,42192),i[12351]=1,n.fill(i,2,44032,55204),n.fill(i,2,63744,64256),n.fill(i,2,65040,65050),n.fill(i,2,65072,65136),n.fill(i,2,65280,65377),n.fill(i,2,65504,65511);for(var e=0;e<o.length;++e)n.fill(i,0,o[e][0],o[e][1]+1);}}return e.prototype.wcwidth=function(e){return e<32?0:e<127?1:e<65536?i[e]:function(e,t){var r,i=0,n=t.length-1;if(e<t[0][0]||e>t[n][1])return !1;for(;n>=i;)if(e>t[r=i+n>>1][1])i=r+1;else {if(!(e<t[r][0]))return !0;n=r-1;}return !1}(e,s)?0:e>=131072&&e<=196605||e>=196608&&e<=262141?2:1},e}();t.UnicodeV6=a;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.CharsetService=void 0;var i=function(){function e(){this.glevel=0,this._charsets=[];}return e.prototype.reset=function(){this.charset=void 0,this._charsets=[],this.glevel=0;},e.prototype.setgLevel=function(e){this.glevel=e,this.charset=this._charsets[e];},e.prototype.setgCharset=function(e,t){this._charsets[e]=t,this.glevel===e&&(this.charset=t);},e}();t.CharsetService=i;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.updateWindowsModeWrappedState=void 0;var i=r(3);t.updateWindowsModeWrappedState=function(e){var t=e.buffer.lines.get(e.buffer.ybase+e.buffer.y-1),r=null==t?void 0:t.get(e.cols-1),n=e.buffer.lines.get(e.buffer.ybase+e.buffer.y);n&&r&&(n.isWrapped=r[i.CHAR_DATA_CODE_INDEX]!==i.NULL_CELL_CODE&&r[i.CHAR_DATA_CODE_INDEX]!==i.WHITESPACE_CELL_CODE);};},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.WriteBuffer=void 0;var i=function(){function e(e){this._action=e,this._writeBuffer=[],this._callbacks=[],this._pendingData=0,this._bufferOffset=0;}return e.prototype.writeSync=function(e){if(this._writeBuffer.length){for(var t=this._bufferOffset;t<this._writeBuffer.length;++t){var r=this._writeBuffer[t],i=this._callbacks[t];this._action(r),i&&i();}this._writeBuffer=[],this._callbacks=[],this._pendingData=0,this._bufferOffset=2147483647;}this._action(e);},e.prototype.write=function(e,t){var r=this;if(this._pendingData>5e7)throw new Error("write data discarded, use flow control to avoid losing data");this._writeBuffer.length||(this._bufferOffset=0,setTimeout((function(){return r._innerWrite()}))),this._pendingData+=e.length,this._writeBuffer.push(e),this._callbacks.push(t);},e.prototype._innerWrite=function(){for(var e=this,t=Date.now();this._writeBuffer.length>this._bufferOffset;){var r=this._writeBuffer[this._bufferOffset],i=this._callbacks[this._bufferOffset];if(this._bufferOffset++,this._action(r),this._pendingData-=r.length,i&&i(),Date.now()-t>=12)break}this._writeBuffer.length>this._bufferOffset?(this._bufferOffset>50&&(this._writeBuffer=this._writeBuffer.slice(this._bufferOffset),this._callbacks=this._callbacks.slice(this._bufferOffset),this._bufferOffset=0),setTimeout((function(){return e._innerWrite()}),0)):(this._writeBuffer=[],this._callbacks=[],this._pendingData=0,this._bufferOffset=0);},e}();t.WriteBuffer=i;},function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.AddonManager=void 0;var i=function(){function e(){this._addons=[];}return e.prototype.dispose=function(){for(var e=this._addons.length-1;e>=0;e--)this._addons[e].instance.dispose();},e.prototype.loadAddon=function(e,t){var r=this,i={instance:t,dispose:t.dispose,isDisposed:!1};this._addons.push(i),t.dispose=function(){return r._wrappedAddonDispose(i)},t.activate(e);},e.prototype._wrappedAddonDispose=function(e){if(!e.isDisposed){for(var t=-1,r=0;r<this._addons.length;r++)if(this._addons[r]===e){t=r;break}if(-1===t)throw new Error("Could not dispose an addon that has not been loaded");e.isDisposed=!0,e.dispose.apply(e.instance),this._addons.splice(t,1);}},e}();t.AddonManager=i;}])}));
  //# sourceMappingURL=xterm.js.map
  });

  var xterm$1 = unwrapExports(xterm);

  /**
   * The history controller provides an ring-buffer
   */
  class HistoryController {
      constructor(size) {
        this.size = size;
        this.entries = [];
        this.cursor = 0;
      }
    
      /**
       * Push an entry and maintain ring buffer size
       */
      push(entry) {
        // Skip empty entries
        if (entry.trim() === "") return;
        // Skip duplicate entries
        const lastEntry = this.entries[this.entries.length - 1];
        if (entry == lastEntry) return;
        // Keep track of entries
        this.entries.push(entry);
        if (this.entries.length > this.size) {
          this.entries.pop(0);
        }
        this.cursor = this.entries.length;
      }
    
      /**
       * Rewind history cursor on the last entry
       */
      rewind() {
        this.cursor = this.entries.length;
      }
    
      /**
       * Returns the previous entry
       */
      getPrevious() {
        const idx = Math.max(0, this.cursor - 1);
        this.cursor = idx;
        return this.entries[idx];
      }
    
      /**
       * Returns the next entry
       */
      getNext() {
        const idx = Math.min(this.entries.length, this.cursor + 1);
        this.cursor = idx;
        return this.entries[idx];
      }
    }

  // '<(' is process substitution operator and
  // can be parsed the same as control operator
  var CONTROL = '(?:' + [
      '\\|\\|', '\\&\\&', ';;', '\\|\\&', '\\<\\(', '>>', '>\\&', '[&;()|<>]'
  ].join('|') + ')';
  var META = '|&;()<> \\t';
  var BAREWORD = '(\\\\[\'"' + META + ']|[^\\s\'"' + META + '])+';
  var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
  var DOUBLE_QUOTE = '\'((\\\\\'|[^\'])*?)\'';

  var TOKEN = '';
  for (var i$1 = 0; i$1 < 4; i$1++) {
      TOKEN += (Math.pow(16,8)*Math.random()).toString(16);
  }

  var parse_1 = function (s, env, opts) {
      var mapped = parse(s, env, opts);
      if (typeof env !== 'function') return mapped;
      return mapped.reduce(function (acc, s) {
          if (typeof s === 'object') return acc.concat(s);
          var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));
          if (xs.length === 1) return acc.concat(xs[0]);
          return acc.concat(xs.filter(Boolean).map(function (x) {
              if (RegExp('^' + TOKEN).test(x)) {
                  return JSON.parse(x.split(TOKEN)[1]);
              }
              else return x;
          }));
      }, []);
  };

  function parse (s, env, opts) {
      var chunker = new RegExp([
          '(' + CONTROL + ')', // control chars
          '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'
      ].join('|'), 'g');
      var match = s.match(chunker).filter(Boolean);
      var commented = false;

      if (!match) return [];
      if (!env) env = {};
      if (!opts) opts = {};
      return match.map(function (s, j) {
          if (commented) {
              return;
          }
          if (RegExp('^' + CONTROL + '$').test(s)) {
              return { op: s };
          }

          // Hand-written scanner/parser for Bash quoting rules:
          //
          //  1. inside single quotes, all characters are printed literally.
          //  2. inside double quotes, all characters are printed literally
          //     except variables prefixed by '$' and backslashes followed by
          //     either a double quote or another backslash.
          //  3. outside of any quotes, backslashes are treated as escape
          //     characters and not printed (unless they are themselves escaped)
          //  4. quote context can switch mid-token if there is no whitespace
          //     between the two quote contexts (e.g. all'one'"token" parses as
          //     "allonetoken")
          var SQ = "'";
          var DQ = '"';
          var DS = '$';
          var BS = opts.escape || '\\';
          var quote = false;
          var esc = false;
          var out = '';
          var isGlob = false;

          for (var i = 0, len = s.length; i < len; i++) {
              var c = s.charAt(i);
              isGlob = isGlob || (!quote && (c === '*' || c === '?'));
              if (esc) {
                  out += c;
                  esc = false;
              }
              else if (quote) {
                  if (c === quote) {
                      quote = false;
                  }
                  else if (quote == SQ) {
                      out += c;
                  }
                  else { // Double quote
                      if (c === BS) {
                          i += 1;
                          c = s.charAt(i);
                          if (c === DQ || c === BS || c === DS) {
                              out += c;
                          } else {
                              out += BS + c;
                          }
                      }
                      else if (c === DS) {
                          out += parseEnvVar();
                      }
                      else {
                          out += c;
                      }
                  }
              }
              else if (c === DQ || c === SQ) {
                  quote = c;
              }
              else if (RegExp('^' + CONTROL + '$').test(c)) {
                  return { op: s };
              }
              else if (RegExp('^#$').test(c)) {
                  commented = true;
                  if (out.length){
                      return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
                  }
                  return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
              }
              else if (c === BS) {
                  esc = true;
              }
              else if (c === DS) {
                  out += parseEnvVar();
              }
              else out += c;
          }

          if (isGlob) return {op: 'glob', pattern: out};

          return out;

          function parseEnvVar() {
              i += 1;
              var varend, varname;
              //debugger
              if (s.charAt(i) === '{') {
                  i += 1;
                  if (s.charAt(i) === '}') {
                      throw new Error("Bad substitution: " + s.substr(i - 2, 3));
                  }
                  varend = s.indexOf('}', i);
                  if (varend < 0) {
                      throw new Error("Bad substitution: " + s.substr(i));
                  }
                  varname = s.substr(i, varend - i);
                  i = varend;
              }
              else if (/[*@#?$!_\-]/.test(s.charAt(i))) {
                  varname = s.charAt(i);
                  i += 1;
              }
              else {
                  varend = s.substr(i).match(/[^\w\d_]/);
                  if (!varend) {
                      varname = s.substr(i);
                      i = s.length;
                  } else {
                      varname = s.substr(i, varend.index);
                      i += varend.index - 1;
                  }
              }
              return getVar(null, '', varname);
          }
      })
      // finalize parsed aruments
      .reduce(function(prev, arg){
          if (arg === undefined){
              return prev;
          }
          return prev.concat(arg);
      },[]);

      function getVar (_, pre, key) {
          var r = typeof env === 'function' ? env(key) : env[key];
          if (r === undefined && key != '')
              r = '';
          else if (r === undefined)
              r = '$';

          if (typeof r === 'object') {
              return pre + TOKEN + JSON.stringify(r) + TOKEN;
          }
          else return pre + r;
      }
  }

  /**
   * Detects all the word boundaries on the given input
   */
  function wordBoundaries(input, leftSide = true) {
    let match;
    const words = [];
    const rx = /\w+/g;

    while ((match = rx.exec(input))) {
      if (leftSide) {
        words.push(match.index);
      } else {
        words.push(match.index + match[0].length);
      }
    }

    return words;
  }

  /**
   * The closest left (or right) word boundary of the given input at the
   * given offset.
   */
  function closestLeftBoundary(input, offset) {
    const found = wordBoundaries(input, true)
      .reverse()
      .find(x => x < offset);
    return found == null ? 0 : found;
  }
  function closestRightBoundary(input, offset) {
    const found = wordBoundaries(input, false).find(x => x > offset);
    return found == null ? input.length : found;
  }

  /**
   * Convert offset at the given input to col/row location
   *
   * This function is not optimized and practically emulates via brute-force
   * the navigation on the terminal, wrapping when they reach the column width.
   */
  function offsetToColRow(input, offset, maxCols) {
    let row = 0,
      col = 0;

    for (let i = 0; i < offset; ++i) {
      const chr = input.charAt(i);
      if (chr == "\n") {
        col = 0;
        row += 1;
      } else {
        col += 1;
        if (col > maxCols) {
          col = 0;
          row += 1;
        }
      }
    }

    return { row, col };
  }

  /**
   * Counts the lines in the given input
   */
  function countLines(input, maxCols) {
    return offsetToColRow(input, input.length, maxCols).row + 1;
  }

  /**
   * Checks if there is an incomplete input
   *
   * An incomplete input is considered:
   * - An input that contains unterminated single quotes
   * - An input that contains unterminated double quotes
   * - An input that ends with "\"
   * - An input that has an incomplete boolean shell expression (&& and ||)
   * - An incomplete pipe expression (|)
   */
  function isIncompleteInput(input) {
    // Empty input is not incomplete
    if (input.trim() == "") {
      return false;
    }

    // Check for dangling single-quote strings
    if ((input.match(/'/g) || []).length % 2 !== 0) {
      return true;
    }
    // Check for dangling double-quote strings
    if ((input.match(/"/g) || []).length % 2 !== 0) {
      return true;
    }
    // Check for dangling boolean or pipe operations
    if (
      input
        .split(/(\|\||\||&&)/g)
        .pop()
        .trim() == ""
    ) {
      return true;
    }
    // Check for tailing slash
    if (input.endsWith("\\") && !input.endsWith("\\\\")) {
      return true;
    }

    return false;
  }

  /**
   * Returns true if the expression ends on a tailing whitespace
   */
  function hasTailingWhitespace(input) {
    return input.match(/[^\\][ \t]$/m) != null;
  }

  /**
   * Returns the last expression in the given input
   */
  function getLastToken(input) {
    // Empty expressions
    if (input.trim() === "") return "";
    if (hasTailingWhitespace(input)) return "";

    // Last token
    const tokens = parse_1(input);
    return tokens.pop() || "";
  }

  /**
   * Returns the auto-complete candidates for the given input
   */
  function collectAutocompleteCandidates(callbacks, input) {
    const tokens = parse_1(input);
    let index = tokens.length - 1;
    let expr = tokens[index] || "";

    // Empty expressions
    if (input.trim() === "") {
      index = 0;
      expr = "";
    } else if (hasTailingWhitespace(input)) {
      // Expressions with danging space
      index += 1;
      expr = "";
    }

    // Collect all auto-complete candidates from the callbacks
    const all = callbacks.reduce((candidates, { fn, args }) => {
      try {
        return candidates.concat(fn(index, tokens, ...args));
      } catch (e) {
        console.error("Auto-complete error:", e);
        return candidates;
      }
    }, []);

    // Filter only the ones starting with the expression
    return all.filter(txt => txt.startsWith(expr));
  }


  function getSharedFragment(fragment, candidates) {

    // end loop when fragment length = first candidate length
    if (fragment.length >= candidates[0].length) return fragment;
    
    // save old fragemnt
    const oldFragment = fragment;
    
    // get new fragment
    fragment += candidates[0].slice(fragment.length, fragment.length+1);

    for (let i=0; i<candidates.length; i++ ) {

      // return null when there's a wrong candidate
      if (!candidates[i].startsWith(oldFragment)) return null;

      if (!candidates[i].startsWith(fragment)) {
        return oldFragment;
      }
    }

    return getSharedFragment(fragment, candidates);
  }

  // Code taken from https://github.com/wavesoft/local-echo but fixed for latest xterm version

  /**
   * A local terminal controller is responsible for displaying messages
   * and handling local echo for the terminal.
   *
   * Local echo supports most of bash-like input primitives. Namely:
   * - Arrow navigation on the input
   * - Alt-arrow for word-boundary navigation
   * - Alt-backspace for word-boundary deletion
   * - Multi-line input for incomplete commands
   * - Auto-complete hooks
   */
  class LocalEchoController {
    constructor(term, options = {}) {
      this.term = term;
      this._handleTermData = this.handleTermData.bind(this);
      this._handleTermResize = this.handleTermResize.bind(this);
      
      this.history = new HistoryController(options.historySize || 10);
      this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;

      this._autocompleteHandlers = [];
      this._active = false;
      this._input = "";
      this._cursor = 0;
      this._activePrompt = null;
      this._activeCharPrompt = null;
      this._termSize = {
        cols: this.term.cols,
        rows: this.term.rows
      };
      
      this.attach();
    }

    /////////////////////////////////////////////////////////////////////////////
    // User-Facing API
    /////////////////////////////////////////////////////////////////////////////
    
    /**
     *  Detach the controller from the terminal
     */
    detach() {
      this.term.off("data", this._handleTermData);
      this.term.off("resize", this._handleTermResize);
    }
    
    /**
     * Attach controller to the terminal, handling events
     */
    attach() {
      this.term.onData (this._handleTermData);
      this.term.onResize (this._handleTermResize);
    }

    /**
     * Register a handler that will be called to satisfy auto-completion
     */
    addAutocompleteHandler(fn, ...args) {
      this._autocompleteHandlers.push({
        fn,
        args
      });
    }

    /**
     * Remove a previously registered auto-complete handler
     */
    removeAutocompleteHandler(fn) {
      const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);
      if (idx === -1) return;

      this._autocompleteHandlers.splice(idx, 1);
    }

    /**
     * Return a promise that will resolve when the user has completed
     * typing a single line
     */
    read(prompt, continuationPrompt = "> ") {
      return new Promise((resolve, reject) => {
        this.term.write(prompt);
        this._activePrompt = {
          prompt,
          continuationPrompt,
          resolve,
          reject
        };

        this._input = "";
        this._cursor = 0;
        this._active = true;
      });
    }

    /**
     * Return a promise that will be resolved when the user types a single
     * character.
     *
     * This can be active in addition to `.read()` and will be resolved in
     * priority before it.
     */
    readChar(prompt) {
      return new Promise((resolve, reject) => {
        this.term.write(prompt);
        this._activeCharPrompt = {
          prompt,
          resolve,
          reject
        };
      });
    }

    /**
     * Abort a pending read operation
     */
    abortRead(reason = "aborted") {
      if (this._activePrompt != null || this._activeCharPrompt != null) {
        this.term.write("\r\n");
      }
      if (this._activePrompt != null) {
        this._activePrompt.reject(reason);
        this._activePrompt = null;
      }
      if (this._activeCharPrompt != null) {
        this._activeCharPrompt.reject(reason);
        this._activeCharPrompt = null;
      }
      this._active = false;
    }

    /**
     * Prints a message and changes line
     */
    println(message) {
      this.print(message + "\n");
    }

    /**
     * Prints a message and properly handles new-lines
     */
    print(message) {
      const normInput = message.replace(/[\r\n]+/g, "\n");
      this.term.write(normInput.replace(/\n/g, "\r\n"));
    }

    /**
     * Prints a list of items using a wide-format
     */
    printWide(items, padding = 2) {
      if (items.length == 0) return println("");

      // Compute item sizes and matrix row/cols
      const itemWidth =
        items.reduce((width, item) => Math.max(width, item.length), 0) + padding;
      const wideCols = Math.floor(this._termSize.cols / itemWidth);
      const wideRows = Math.ceil(items.length / wideCols);

      // Print matrix
      let i = 0;
      for (let row = 0; row < wideRows; ++row) {
        let rowStr = "";

        // Prepare columns
        for (let col = 0; col < wideCols; ++col) {
          if (i < items.length) {
            let item = items[i++];
            item += " ".repeat(itemWidth - item.length);
            rowStr += item;
          }
        }
        this.println(rowStr);
      }
    }

    /////////////////////////////////////////////////////////////////////////////
    // Internal API
    /////////////////////////////////////////////////////////////////////////////

    /**
     * Apply prompts to the given input
     */
    applyPrompts(input) {
      const prompt = (this._activePrompt || {}).prompt || "";
      const continuationPrompt =
        (this._activePrompt || {}).continuationPrompt || "";

      return prompt + input.replace(/\n/g, "\n" + continuationPrompt);
    }

    /**
     * Advances the `offset` as required in order to accompany the prompt
     * additions to the input.
     */
    applyPromptOffset(input, offset) {
      const newInput = this.applyPrompts(input.substr(0, offset));
      return newInput.length;
    }

    /**
     * Clears the current prompt
     *
     * This function will erase all the lines that display the current prompt
     * and move the cursor in the beginning of the first line of the prompt.
     */
    clearInput() {
      const currentPrompt = this.applyPrompts(this._input);

      // Get the overall number of lines to clear
      const allRows = countLines(currentPrompt, this._termSize.cols);

      // Get the line we are currently in
      const promptCursor = this.applyPromptOffset(this._input, this._cursor);
      const { col, row } = offsetToColRow(
        currentPrompt,
        promptCursor,
        this._termSize.cols
      );

      // First move on the last line
      const moveRows = allRows - row - 1;
      for (var i = 0; i < moveRows; ++i) this.term.write("\x1B[E");

      // Clear current input line(s)
      this.term.write("\r\x1B[K");
      for (var i = 1; i < allRows; ++i) this.term.write("\x1B[F\x1B[K");
    }

    /**
     * Replace input with the new input given
     *
     * This function clears all the lines that the current input occupies and
     * then replaces them with the new input.
     */
    setInput(newInput, clearInput = true) {
      // Clear current input
      if (clearInput) this.clearInput();

      // Write the new input lines, including the current prompt
      const newPrompt = this.applyPrompts(newInput);
      this.print(newPrompt);

      // Trim cursor overflow
      if (this._cursor > newInput.length) {
        this._cursor = newInput.length;
      }

      // Move the cursor to the appropriate row/col
      const newCursor = this.applyPromptOffset(newInput, this._cursor);
      const newLines = countLines(newPrompt, this._termSize.cols);
      const { col, row } = offsetToColRow(
        newPrompt,
        newCursor,
        this._termSize.cols
      );
      const moveUpRows = newLines - row - 1;

      this.term.write("\r");
      for (var i = 0; i < moveUpRows; ++i) this.term.write("\x1B[F");
      for (var i = 0; i < col; ++i) this.term.write("\x1B[C");

      // Replace input
      this._input = newInput;
    }

    /**
     * This function completes the current input, calls the given callback
     * and then re-displays the prompt.
     */
    printAndRestartPrompt(callback) {
      const cursor = this._cursor;

      // Complete input
      this.setCursor(this._input.length);
      this.term.write("\r\n");

      // Prepare a function that will resume prompt
      const resume = () => {
        this._cursor = cursor;
        this.setInput(this._input);
      };

      // Call the given callback to echo something, and if there is a promise
      // returned, wait for the resolution before resuming prompt.
      const ret = callback();
      if (ret == null) {
        resume();
      } else {
        ret.then(resume);
      }
    }

    /**
     * Set the new cursor position, as an offset on the input string
     *
     * This function:
     * - Calculates the previous and current
     */
    setCursor(newCursor) {
      if (newCursor < 0) newCursor = 0;
      if (newCursor > this._input.length) newCursor = this._input.length;

      // Apply prompt formatting to get the visual status of the display
      const inputWithPrompt = this.applyPrompts(this._input);
      const inputLines = countLines(inputWithPrompt, this._termSize.cols);

      // Estimate previous cursor position
      const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);
      const { col: prevCol, row: prevRow } = offsetToColRow(
        inputWithPrompt,
        prevPromptOffset,
        this._termSize.cols
      );

      // Estimate next cursor position
      const newPromptOffset = this.applyPromptOffset(this._input, newCursor);
      const { col: newCol, row: newRow } = offsetToColRow(
        inputWithPrompt,
        newPromptOffset,
        this._termSize.cols
      );

      // Adjust vertically
      if (newRow > prevRow) {
        for (let i = prevRow; i < newRow; ++i) this.term.write("\x1B[B");
      } else {
        for (let i = newRow; i < prevRow; ++i) this.term.write("\x1B[A");
      }

      // Adjust horizontally
      if (newCol > prevCol) {
        for (let i = prevCol; i < newCol; ++i) this.term.write("\x1B[C");
      } else {
        for (let i = newCol; i < prevCol; ++i) this.term.write("\x1B[D");
      }

      // Set new offset
      this._cursor = newCursor;
    }

    /**
     * Move cursor at given direction
     */
    handleCursorMove(dir) {
      if (dir > 0) {
        const num = Math.min(dir, this._input.length - this._cursor);
        this.setCursor(this._cursor + num);
      } else if (dir < 0) {
        const num = Math.max(dir, -this._cursor);
        this.setCursor(this._cursor + num);
      }
    }

    /**
     * Erase a character at cursor location
     */
    handleCursorErase(backspace) {
      const { _cursor, _input } = this;
      if (backspace) {
        if (_cursor <= 0) return;
        const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);
        this.clearInput();
        this._cursor -= 1;
        this.setInput(newInput, false);
      } else {
        const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);
        this.setInput(newInput);
      }
    }

    /**
     * Insert character at cursor location
     */
    handleCursorInsert(data) {
      const { _cursor, _input } = this;
      const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);
      this._cursor += data.length;
      this.setInput(newInput);
    }

    /**
     * Handle input completion
     */
    handleReadComplete() {
      if (this.history) {
        this.history.push(this._input);
      }
      if (this._activePrompt) {
        this._activePrompt.resolve(this._input);
        this._activePrompt = null;
      }
      this.term.write("\r\n");
      this._active = false;
    }

    /**
     * Handle terminal resize
     *
     * This function clears the prompt using the previous configuration,
     * updates the cached terminal size information and then re-renders the
     * input. This leads (most of the times) into a better formatted input.
     */
    handleTermResize(data) {
      const { rows, cols } = data;
      this.clearInput();
      this._termSize = { cols, rows };
      this.setInput(this._input, false);
    }

    /**
     * Handle terminal input
     */
    handleTermData(data) {
      if (!this._active) return;

      // If we have an active character prompt, satisfy it in priority
      if (this._activeCharPrompt != null) {
        this._activeCharPrompt.resolve(data);
        this._activeCharPrompt = null;
        this.term.write("\r\n");
        return;
      }

      // If this looks like a pasted input, expand it
      if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {
        const normData = data.replace(/[\r\n]+/g, "\r");
        Array.from(normData).forEach(c => this.handleData(c));
      } else {
        this.handleData(data);
      }
    }

    /**
     * Handle a single piece of information from the terminal.
     */
    handleData(data) {
      if (!this._active) return;
      const ord = data.charCodeAt(0);
      let ofs;

      // Handle ANSI escape sequences
      if (ord == 0x1b) {
        switch (data.substr(1)) {
          case "[A": // Up arrow
            if (this.history) {
              let value = this.history.getPrevious();
              if (value) {
                this.setInput(value);
                this.setCursor(value.length);
              }
            }
            break;

          case "[B": // Down arrow
            if (this.history) {
              let value = this.history.getNext();
              if (!value) value = "";
              this.setInput(value);
              this.setCursor(value.length);
            }
            break;

          case "[D": // Left Arrow
            this.handleCursorMove(-1);
            break;

          case "[C": // Right Arrow
            this.handleCursorMove(1);
            break;

          case "[3~": // Delete
            this.handleCursorErase(false);
            break;

          case "[F": // End
            this.setCursor(this._input.length);
            break;

          case "[H": // Home
            this.setCursor(0);
            break;

          case "b": // ALT + LEFT
            ofs = closestLeftBoundary(this._input, this._cursor);
            if (ofs != null) this.setCursor(ofs);
            break;

          case "f": // ALT + RIGHT
            ofs = closestRightBoundary(this._input, this._cursor);
            if (ofs != null) this.setCursor(ofs);
            break;

          case "\x7F": // CTRL + BACKSPACE
            ofs = closestLeftBoundary(this._input, this._cursor);
            if (ofs != null) {
              this.setInput(
                this._input.substr(0, ofs) + this._input.substr(this._cursor)
              );
              this.setCursor(ofs);
            }
            break;
        }

        // Handle special characters
      } else if (ord < 32 || ord === 0x7f) {
        switch (data) {
          case "\r": // ENTER
            if (isIncompleteInput(this._input)) {
              this.handleCursorInsert("\n");
            } else {
              this.handleReadComplete();
            }
            break;

          case "\x7F": // BACKSPACE
            this.handleCursorErase(true);
            break;

          case "\t": // TAB
            if (this._autocompleteHandlers.length > 0) {
              const inputFragment = this._input.substr(0, this._cursor);
              const hasTailingSpace = hasTailingWhitespace(inputFragment);
              const candidates = collectAutocompleteCandidates(
                this._autocompleteHandlers,
                inputFragment
              );

              // Sort candidates
              candidates.sort();

              // Depending on the number of candidates, we are handing them in
              // a different way.
              if (candidates.length === 0) {
                // No candidates? Just add a space if there is none already
                if (!hasTailingSpace) {
                  this.handleCursorInsert(" ");
                }
              } else if (candidates.length === 1) {
                // Just a single candidate? Complete
                const lastToken = getLastToken(inputFragment);
                this.handleCursorInsert(
                  candidates[0].substr(lastToken.length) + " "
                );
              } else if (candidates.length <= this.maxAutocompleteEntries) {

                // search for a shared fragement
                const sameFragment = getSharedFragment(inputFragment, candidates);
                
                // if there's a shared fragement between the candidates
                // print complete the shared fragment
                if (sameFragment) {
                  const lastToken = getLastToken(inputFragment);
                  this.handleCursorInsert(
                    sameFragment.substr(lastToken.length)
                  );
                }

                // If we are less than maximum auto-complete candidates, print
                // them to the user and re-start prompt
                this.printAndRestartPrompt(() => {
                  this.printWide(candidates);
                });
              } else {
                // If we have more than maximum auto-complete candidates, print
                // them only if the user acknowledges a warning
                this.printAndRestartPrompt(() =>
                  this.readChar(
                    `Display all ${candidates.length} possibilities? (y or n)`
                  ).then(yn => {
                    if (yn == "y" || yn == "Y") {
                      this.printWide(candidates);
                    }
                  })
                );
              }
            } else {
              this.handleCursorInsert("    ");
            }
            break;

          case "\x03": // CTRL+C
            this.setCursor(this._input.length);
            this.term.write("^C\r\n" + ((this._activePrompt || {}).prompt || ""));
            this._input = "";
            this._cursor = 0;
            if (this.history) this.history.rewind();
            break;
        }

        // Handle visible characters
      } else {
        this.handleCursorInsert(data);
      }
    }
  }

  var xtermAddonFit = createCommonjsModule(function (module, exports) {
  !function(e,t){module.exports=t();}(window,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n});},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.FitAddon=void 0;var n=function(){function e(){}return e.prototype.activate=function(e){this._terminal=e;},e.prototype.dispose=function(){},e.prototype.fit=function(){var e=this.proposeDimensions();if(e&&this._terminal){var t=this._terminal._core;this._terminal.rows===e.rows&&this._terminal.cols===e.cols||(t._renderService.clear(),this._terminal.resize(e.cols,e.rows));}},e.prototype.proposeDimensions=function(){if(this._terminal&&this._terminal.element&&this._terminal.element.parentElement){var e=this._terminal._core,t=window.getComputedStyle(this._terminal.element.parentElement),r=parseInt(t.getPropertyValue("height")),n=Math.max(0,parseInt(t.getPropertyValue("width"))),o=window.getComputedStyle(this._terminal.element),i=r-(parseInt(o.getPropertyValue("padding-top"))+parseInt(o.getPropertyValue("padding-bottom"))),a=n-(parseInt(o.getPropertyValue("padding-right"))+parseInt(o.getPropertyValue("padding-left")))-e.viewport.scrollBarWidth;return {cols:Math.max(2,Math.floor(a/e._renderService.dimensions.actualCellWidth)),rows:Math.max(1,Math.floor(i/e._renderService.dimensions.actualCellHeight))}}},e}();t.FitAddon=n;}])}));
  //# sourceMappingURL=xterm-addon-fit.js.map
  });

  var fit = unwrapExports(xtermAddonFit);
  var xtermAddonFit_1 = xtermAddonFit.FitAddon;

  // src/auth.js

  //const isLoading = writable(true);
  const GAME_CLIENT = {};

  function createClient(renderer, characterCreator) {
    let ws;
    let messageHandlers = new Map();
    let wsurl = "";

    let activeRoom = {};
    let currentCharacter = {};

    messageHandlers["enterRoom"] = (msg) => {
      activeRoom = msg.room;
      renderer(msg.message);
    };

    messageHandlers["createCharacter"] = (msg) => {
      renderer(msg.message);

      if (characterCreator) {
        characterCreator();
        //TODO: send select character
      }
    };
    messageHandlers["characterSelected"] = (msg) => {
      currentCharacter = msg.character;
      renderer(msg.message);
    };

    const setWSClient = async (wscl) => {
      ws = wscl;
      wsurl = ws.url;

      updateClient(ws);
      
    };

    const updateClient = (ws) => {
      ws.addEventListener("message", function (e) {
        var msg = JSON.parse(e.data);

        if (messageHandlers[msg.type]) {
          messageHandlers[msg.type](msg);
        } else {
          let message = msg.message;

          if (msg.username) {
            message = msg.username + ":  " + msg.message;
          }
          renderer(message);
        }
      });

      ws.addEventListener("close", function (e){
        renderer ("Connection Closed.");
      });
    };

    const onInput = async (data) => {
      const msg = await handleInput(data);
      sendMessage(msg);
      //renderer(msg);
    };

    const sendMessage = (msg) => {
      if (!ws) return;

      if (
        ws.readyState == WebSocket.CLOSING ||
        ws.readyState == WebSocket.CLOSED
      ) {
        ws = new WebSocket(wsurl);
        updateClient(ws);
        renderer("reconnecting ...\n");
      }

      ws.send(
        JSON.stringify({
          message: msg,
          type: "message",
        })
      );
    };

    const handleInput = async (data) => {
      return `${data}`;
    };

    const client = {
      onInput,
      setWSClient,
    };

    // setInterval(function () {
    //   renderer("\n<The lights in front of you are flickering>")
    // }, 5000);

    setContext(GAME_CLIENT, client);
    return client;
  }

  function getClient() {
    return getContext(GAME_CLIENT);
  }

  /* node_modules/svelte-feather-icons/src/icons/BookOpenIcon.svelte generated by Svelte v3.22.3 */

  const file$5 = "node_modules/svelte-feather-icons/src/icons/BookOpenIcon.svelte";

  function create_fragment$9(ctx) {
  	let svg;
  	let path0;
  	let path1;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			path0 = svg_element("path");
  			path1 = svg_element("path");
  			attr_dev(path0, "d", "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z");
  			add_location(path0, file$5, 12, 234, 490);
  			attr_dev(path1, "d", "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z");
  			add_location(path1, file$5, 12, 292, 548);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-book-open " + /*customClass*/ ctx[1]);
  			add_location(svg, file$5, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, path0);
  			append_dev(svg, path1);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-book-open " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$9.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$9($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BookOpenIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("BookOpenIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class BookOpenIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$9, create_fragment$9, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "BookOpenIcon",
  			options,
  			id: create_fragment$9.name
  		});
  	}

  	get size() {
  		throw new Error("<BookOpenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<BookOpenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<BookOpenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<BookOpenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-feather-icons/src/icons/EditIcon.svelte generated by Svelte v3.22.3 */

  const file$6 = "node_modules/svelte-feather-icons/src/icons/EditIcon.svelte";

  function create_fragment$a(ctx) {
  	let svg;
  	let path0;
  	let path1;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			path0 = svg_element("path");
  			path1 = svg_element("path");
  			attr_dev(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
  			add_location(path0, file$6, 12, 229, 485);
  			attr_dev(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
  			add_location(path1, file$6, 12, 305, 561);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-edit " + /*customClass*/ ctx[1]);
  			add_location(svg, file$6, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, path0);
  			append_dev(svg, path1);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-edit " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$a.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$a($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EditIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("EditIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class EditIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$a, create_fragment$a, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "EditIcon",
  			options,
  			id: create_fragment$a.name
  		});
  	}

  	get size() {
  		throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-feather-icons/src/icons/HashIcon.svelte generated by Svelte v3.22.3 */

  const file$7 = "node_modules/svelte-feather-icons/src/icons/HashIcon.svelte";

  function create_fragment$b(ctx) {
  	let svg;
  	let line0;
  	let line1;
  	let line2;
  	let line3;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			line0 = svg_element("line");
  			line1 = svg_element("line");
  			line2 = svg_element("line");
  			line3 = svg_element("line");
  			attr_dev(line0, "x1", "4");
  			attr_dev(line0, "y1", "9");
  			attr_dev(line0, "x2", "20");
  			attr_dev(line0, "y2", "9");
  			add_location(line0, file$7, 12, 229, 485);
  			attr_dev(line1, "x1", "4");
  			attr_dev(line1, "y1", "15");
  			attr_dev(line1, "x2", "20");
  			attr_dev(line1, "y2", "15");
  			add_location(line1, file$7, 12, 271, 527);
  			attr_dev(line2, "x1", "10");
  			attr_dev(line2, "y1", "3");
  			attr_dev(line2, "x2", "8");
  			attr_dev(line2, "y2", "21");
  			add_location(line2, file$7, 12, 315, 571);
  			attr_dev(line3, "x1", "16");
  			attr_dev(line3, "y1", "3");
  			attr_dev(line3, "x2", "14");
  			attr_dev(line3, "y2", "21");
  			add_location(line3, file$7, 12, 358, 614);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-hash " + /*customClass*/ ctx[1]);
  			add_location(svg, file$7, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, line0);
  			append_dev(svg, line1);
  			append_dev(svg, line2);
  			append_dev(svg, line3);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-hash " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$b.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$b($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HashIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("HashIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class HashIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$b, create_fragment$b, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "HashIcon",
  			options,
  			id: create_fragment$b.name
  		});
  	}

  	get size() {
  		throw new Error("<HashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<HashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<HashIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<HashIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-feather-icons/src/icons/PlayIcon.svelte generated by Svelte v3.22.3 */

  const file$8 = "node_modules/svelte-feather-icons/src/icons/PlayIcon.svelte";

  function create_fragment$c(ctx) {
  	let svg;
  	let polygon;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			polygon = svg_element("polygon");
  			attr_dev(polygon, "points", "5 3 19 12 5 21 5 3");
  			add_location(polygon, file$8, 12, 229, 485);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-play " + /*customClass*/ ctx[1]);
  			add_location(svg, file$8, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, polygon);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-play " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$c.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$c($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PlayIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("PlayIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class PlayIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$c, create_fragment$c, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "PlayIcon",
  			options,
  			id: create_fragment$c.name
  		});
  	}

  	get size() {
  		throw new Error("<PlayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<PlayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<PlayIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<PlayIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-feather-icons/src/icons/PlusIcon.svelte generated by Svelte v3.22.3 */

  const file$9 = "node_modules/svelte-feather-icons/src/icons/PlusIcon.svelte";

  function create_fragment$d(ctx) {
  	let svg;
  	let line0;
  	let line1;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			line0 = svg_element("line");
  			line1 = svg_element("line");
  			attr_dev(line0, "x1", "12");
  			attr_dev(line0, "y1", "5");
  			attr_dev(line0, "x2", "12");
  			attr_dev(line0, "y2", "19");
  			add_location(line0, file$9, 12, 229, 485);
  			attr_dev(line1, "x1", "5");
  			attr_dev(line1, "y1", "12");
  			attr_dev(line1, "x2", "19");
  			attr_dev(line1, "y2", "12");
  			add_location(line1, file$9, 12, 273, 529);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-plus " + /*customClass*/ ctx[1]);
  			add_location(svg, file$9, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, line0);
  			append_dev(svg, line1);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-plus " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$d.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$d($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PlusIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("PlusIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class PlusIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$d, create_fragment$d, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "PlusIcon",
  			options,
  			id: create_fragment$d.name
  		});
  	}

  	get size() {
  		throw new Error("<PlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<PlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<PlusIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<PlusIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-feather-icons/src/icons/ShieldIcon.svelte generated by Svelte v3.22.3 */

  const file$a = "node_modules/svelte-feather-icons/src/icons/ShieldIcon.svelte";

  function create_fragment$e(ctx) {
  	let svg;
  	let path;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			path = svg_element("path");
  			attr_dev(path, "d", "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z");
  			add_location(path, file$a, 12, 231, 487);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-shield " + /*customClass*/ ctx[1]);
  			add_location(svg, file$a, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, path);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-shield " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$e.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$e($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ShieldIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("ShieldIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class ShieldIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$e, create_fragment$e, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "ShieldIcon",
  			options,
  			id: create_fragment$e.name
  		});
  	}

  	get size() {
  		throw new Error("<ShieldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<ShieldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<ShieldIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<ShieldIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-feather-icons/src/icons/UserIcon.svelte generated by Svelte v3.22.3 */

  const file$b = "node_modules/svelte-feather-icons/src/icons/UserIcon.svelte";

  function create_fragment$f(ctx) {
  	let svg;
  	let path;
  	let circle;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			path = svg_element("path");
  			circle = svg_element("circle");
  			attr_dev(path, "d", "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2");
  			add_location(path, file$b, 12, 229, 485);
  			attr_dev(circle, "cx", "12");
  			attr_dev(circle, "cy", "7");
  			attr_dev(circle, "r", "4");
  			add_location(circle, file$b, 12, 288, 544);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-user " + /*customClass*/ ctx[1]);
  			add_location(svg, file$b, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, path);
  			append_dev(svg, circle);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-user " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$f.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$f($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("UserIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class UserIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$f, create_fragment$f, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "UserIcon",
  			options,
  			id: create_fragment$f.name
  		});
  	}

  	get size() {
  		throw new Error("<UserIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<UserIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<UserIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<UserIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/svelte-feather-icons/src/icons/UsersIcon.svelte generated by Svelte v3.22.3 */

  const file$c = "node_modules/svelte-feather-icons/src/icons/UsersIcon.svelte";

  function create_fragment$g(ctx) {
  	let svg;
  	let path0;
  	let circle;
  	let path1;
  	let path2;
  	let svg_class_value;

  	const block = {
  		c: function create() {
  			svg = svg_element("svg");
  			path0 = svg_element("path");
  			circle = svg_element("circle");
  			path1 = svg_element("path");
  			path2 = svg_element("path");
  			attr_dev(path0, "d", "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
  			add_location(path0, file$c, 12, 230, 486);
  			attr_dev(circle, "cx", "9");
  			attr_dev(circle, "cy", "7");
  			attr_dev(circle, "r", "4");
  			add_location(circle, file$c, 12, 289, 545);
  			attr_dev(path1, "d", "M23 21v-2a4 4 0 0 0-3-3.87");
  			add_location(path1, file$c, 12, 326, 582);
  			attr_dev(path2, "d", "M16 3.13a4 4 0 0 1 0 7.75");
  			add_location(path2, file$c, 12, 370, 626);
  			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
  			attr_dev(svg, "width", /*size*/ ctx[0]);
  			attr_dev(svg, "height", /*size*/ ctx[0]);
  			attr_dev(svg, "fill", "none");
  			attr_dev(svg, "viewBox", "0 0 24 24");
  			attr_dev(svg, "stroke", "currentColor");
  			attr_dev(svg, "stroke-width", "2");
  			attr_dev(svg, "stroke-linecap", "round");
  			attr_dev(svg, "stroke-linejoin", "round");
  			attr_dev(svg, "class", svg_class_value = "feather feather-users " + /*customClass*/ ctx[1]);
  			add_location(svg, file$c, 12, 0, 256);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svg, anchor);
  			append_dev(svg, path0);
  			append_dev(svg, circle);
  			append_dev(svg, path1);
  			append_dev(svg, path2);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "width", /*size*/ ctx[0]);
  			}

  			if (dirty & /*size*/ 1) {
  				attr_dev(svg, "height", /*size*/ ctx[0]);
  			}

  			if (dirty & /*customClass*/ 2 && svg_class_value !== (svg_class_value = "feather feather-users " + /*customClass*/ ctx[1])) {
  				attr_dev(svg, "class", svg_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svg);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$g.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$g($$self, $$props, $$invalidate) {
  	let { size = "100%" } = $$props;
  	let { class: customClass = "" } = $$props;

  	if (size !== "100%") {
  		size = size.slice(-1) === "x"
  		? size.slice(0, size.length - 1) + "em"
  		: parseInt(size) + "px";
  	}

  	const writable_props = ["size", "class"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UsersIcon> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("UsersIcon", $$slots, []);

  	$$self.$set = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("class" in $$props) $$invalidate(1, customClass = $$props.class);
  	};

  	$$self.$capture_state = () => ({ size, customClass });

  	$$self.$inject_state = $$props => {
  		if ("size" in $$props) $$invalidate(0, size = $$props.size);
  		if ("customClass" in $$props) $$invalidate(1, customClass = $$props.customClass);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [size, customClass];
  }

  class UsersIcon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$g, create_fragment$g, safe_not_equal, { size: 0, class: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "UsersIcon",
  			options,
  			id: create_fragment$g.name
  		});
  	}

  	get size() {
  		throw new Error("<UsersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<UsersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<UsersIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<UsersIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  function getUser(token, cb, errorCb) {
    axios$1
      .get(`${backend}/user`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }
  function updateUser(token, user, cb) {
    axios$1
      .put(`${backend}/user`, user, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data));
  }

  /* src/UserMenu.svelte generated by Svelte v3.22.3 */

  const { console: console_1$1 } = globals;
  const file$d = "src/UserMenu.svelte";

  // (70:28) 
  function create_if_block_2(ctx) {
  	let li0;
  	let p;
  	let t1;
  	let li1;
  	let button;
  	let dispose;

  	const block = {
  		c: function create() {
  			li0 = element("li");
  			p = element("p");
  			p.textContent = "Signup";
  			t1 = space();
  			li1 = element("li");
  			button = element("button");
  			button.textContent = "Log in";
  			attr_dev(p, "class", "btn-small userbutton green svelte-1ujdy1x");
  			add_location(p, file$d, 71, 4, 1252);
  			attr_dev(li0, "class", "right-align");
  			add_location(li0, file$d, 70, 2, 1223);
  			attr_dev(button, "class", "btn-small userbutton green svelte-1ujdy1x");
  			add_location(button, file$d, 74, 4, 1368);
  			attr_dev(li1, "class", "right-align");
  			add_location(li1, file$d, 73, 2, 1339);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, li0, anchor);
  			append_dev(li0, p);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, li1, anchor);
  			append_dev(li1, button);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(p, "click", /*click_handler_1*/ ctx[14], false, false, false),
  				listen_dev(button, "click", /*click_handler_2*/ ctx[15], false, false, false)
  			];
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li0);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(li1);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2.name,
  		type: "if",
  		source: "(70:28) ",
  		ctx
  	});

  	return block;
  }

  // (68:0) {#if $isLoading}
  function create_if_block_1$2(ctx) {
  	let li;

  	const block = {
  		c: function create() {
  			li = element("li");
  			li.textContent = "...";
  			attr_dev(li, "class", "right-align");
  			add_location(li, file$d, 68, 2, 1159);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li, anchor);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$2.name,
  		type: "if",
  		source: "(68:0) {#if $isLoading}",
  		ctx
  	});

  	return block;
  }

  // (85:6) {#if $isAuthenticated}
  function create_if_block$3(ctx) {
  	let img;
  	let img_src_value;
  	let t0;
  	let i;

  	const block = {
  		c: function create() {
  			img = element("img");
  			t0 = space();
  			i = element("i");
  			i.textContent = "arrow_drop_down";
  			if (img.src !== (img_src_value = /*$userInfo*/ ctx[2].picture)) attr_dev(img, "src", img_src_value);
  			attr_dev(img, "alt", "");
  			attr_dev(img, "class", "circle img  svelte-1ujdy1x");
  			add_location(img, file$d, 85, 8, 1622);
  			attr_dev(i, "class", "material-icons left");
  			add_location(i, file$d, 86, 8, 1691);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, i, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$userInfo*/ 4 && img.src !== (img_src_value = /*$userInfo*/ ctx[2].picture)) {
  				attr_dev(img, "src", img_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(i);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$3.name,
  		type: "if",
  		source: "(85:6) {#if $isAuthenticated}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$h(ctx) {
  	let ul;
  	let li0;
  	let a0;
  	let t1;
  	let li1;
  	let a1;
  	let t3;
  	let t4;
  	let li2;
  	let a2;
  	let span;
  	let dispose;

  	function select_block_type(ctx, dirty) {
  		if (/*$isLoading*/ ctx[1]) return create_if_block_1$2;
  		if (!/*$isAuthenticated*/ ctx[0]) return create_if_block_2;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block0 = current_block_type && current_block_type(ctx);
  	let if_block1 = /*$isAuthenticated*/ ctx[0] && create_if_block$3(ctx);

  	const block = {
  		c: function create() {
  			ul = element("ul");
  			li0 = element("li");
  			a0 = element("a");
  			a0.textContent = "logout";
  			t1 = space();
  			li1 = element("li");
  			a1 = element("a");
  			a1.textContent = "profile";
  			t3 = space();
  			if (if_block0) if_block0.c();
  			t4 = space();
  			li2 = element("li");
  			a2 = element("a");
  			span = element("span");
  			if (if_block1) if_block1.c();
  			attr_dev(a0, "href", "#!");
  			add_location(a0, file$d, 60, 4, 1024);
  			add_location(li0, file$d, 59, 2, 1015);
  			attr_dev(a1, "href", "account");
  			add_location(a1, file$d, 63, 4, 1095);
  			add_location(li1, file$d, 62, 2, 1086);
  			attr_dev(ul, "id", "dropdown1");
  			attr_dev(ul, "class", "dropdown-content");
  			add_location(ul, file$d, 58, 0, 968);
  			attr_dev(span, "class", "valign-wrapper");
  			add_location(span, file$d, 82, 4, 1554);
  			attr_dev(a2, "class", "dropdown-trigger");
  			attr_dev(a2, "href", "#");
  			attr_dev(a2, "data-target", "dropdown1");
  			add_location(a2, file$d, 81, 2, 1488);
  			add_location(li2, file$d, 79, 0, 1480);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, ul, anchor);
  			append_dev(ul, li0);
  			append_dev(li0, a0);
  			append_dev(ul, t1);
  			append_dev(ul, li1);
  			append_dev(li1, a1);
  			insert_dev(target, t3, anchor);
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t4, anchor);
  			insert_dev(target, li2, anchor);
  			append_dev(li2, a2);
  			append_dev(a2, span);
  			if (if_block1) if_block1.m(span, null);
  			if (remount) dispose();
  			dispose = listen_dev(a0, "click", /*click_handler*/ ctx[13], false, false, false);
  		},
  		p: function update(ctx, [dirty]) {
  			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
  				if_block0.p(ctx, dirty);
  			} else {
  				if (if_block0) if_block0.d(1);
  				if_block0 = current_block_type && current_block_type(ctx);

  				if (if_block0) {
  					if_block0.c();
  					if_block0.m(t4.parentNode, t4);
  				}
  			}

  			if (/*$isAuthenticated*/ ctx[0]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);
  				} else {
  					if_block1 = create_if_block$3(ctx);
  					if_block1.c();
  					if_block1.m(span, null);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(ul);
  			if (detaching) detach_dev(t3);

  			if (if_block0) {
  				if_block0.d(detaching);
  			}

  			if (detaching) detach_dev(t4);
  			if (detaching) detach_dev(li2);
  			if (if_block1) if_block1.d();
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$h.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$h($$self, $$props, $$invalidate) {
  	let $authToken;
  	let $isAuthenticated;
  	let $isLoading;
  	let $userInfo;
  	const { isLoading, isAuthenticated, login, logout, authToken, authError, userInfo } = getAuth();
  	validate_store(isLoading, "isLoading");
  	component_subscribe($$self, isLoading, value => $$invalidate(1, $isLoading = value));
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(0, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(10, $authToken = value));
  	validate_store(userInfo, "userInfo");
  	component_subscribe($$self, userInfo, value => $$invalidate(2, $userInfo = value));

  	async function loadUserData() {
  		getUser(
  			$authToken,
  			u => {
  				user.set(u);
  			},
  			err => console.log(err)
  		);
  	}

  	async function signup() {
  		await login();

  		if ($isAuthenticated) {
  			await loadUserData();
  		}
  	}

  	onMount(() => {
  		document.addEventListener("DOMContentLoaded", function () {
  			var elems = document.querySelectorAll(".dropdown-trigger");
  			var instances = M.Dropdown.init(elems);
  		});
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<UserMenu> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("UserMenu", $$slots, []);
  	const click_handler = () => logout();
  	const click_handler_1 = () => signup();
  	const click_handler_2 = () => login();

  	$$self.$capture_state = () => ({
  		onMount,
  		UserIcon,
  		getAuth,
  		getUser,
  		updateUser,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		authError,
  		userInfo,
  		loadUserData,
  		signup,
  		$authToken,
  		$isAuthenticated,
  		$isLoading,
  		$userInfo
  	});

  	return [
  		$isAuthenticated,
  		$isLoading,
  		$userInfo,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		userInfo,
  		signup,
  		$authToken,
  		authError,
  		loadUserData,
  		click_handler,
  		click_handler_1,
  		click_handler_2
  	];
  }

  class UserMenu extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "UserMenu",
  			options,
  			id: create_fragment$h.name
  		});
  	}
  }

  /* src/game/Game.svelte generated by Svelte v3.22.3 */

  const { console: console_1$2 } = globals;
  const file$e = "src/game/Game.svelte";

  function create_fragment$i(ctx) {
  	let t;
  	let div1;
  	let div0;
  	let current;
  	const charactercreator = new CharacterCreator({ $$inline: true });

  	const block = {
  		c: function create() {
  			create_component(charactercreator.$$.fragment);
  			t = space();
  			div1 = element("div");
  			div0 = element("div");
  			attr_dev(div0, "id", "terminal");
  			attr_dev(div0, "class", "svelte-1egwjd3");
  			add_location(div0, file$e, 154, 2, 3693);
  			attr_dev(div1, "id", "terminalWindow");
  			attr_dev(div1, "class", "svelte-1egwjd3");
  			add_location(div1, file$e, 153, 0, 3665);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(charactercreator, target, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, div1, anchor);
  			append_dev(div1, div0);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(charactercreator.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(charactercreator.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(charactercreator, detaching);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(div1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$i.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function sleep(ms) {
  	return new Promise(resolve => setTimeout(resolve, ms));
  }

  function autocompleteCommonCommands(index, tokens) {
  	if (index == 0) return ["north", "east", "south", "west", "say"];
  	return [];
  }

  function instance$i($$self, $$props, $$invalidate) {
  	let $isAuthenticated;
  	let $authToken;
  	let client;
  	let term;
  	let ws;
  	const { isAuthenticated, authToken } = getAuth();
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(6, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(7, $authToken = value));

  	function readLine(localEcho, term) {
  		localEcho.read("~$ ").then(input => {
  			client.onInput(input);
  			readLine(localEcho);
  		}).catch(error => console.log(`Error reading: ${error}`));
  	}

  	const createRenderer = (term, localEcho) => {
  		return data => {
  			localEcho.clearInput();
  			term.writeln(data);
  		};
  	};

  	const characterCreator = () => {
  		console.log("CREATE CHARACTER");
  		var Modalelem = document.querySelector(".modal");
  		var instance = M.Modal.init(Modalelem);
  		instance.open();
  	};

  	async function setupTerminal() {
  		term = new xterm$1.Terminal();
  		var fitAddon = new fit.FitAddon();
  		term.loadAddon(fitAddon);
  		term.setOption("cursorBlink", true);
  		term.setOption("convertEol", true);
  		term.open(document.getElementById("terminal"));
  		fitAddon.fit();
  		const localEcho = new LocalEchoController(term);
  		localEcho.addAutocompleteHandler(autocompleteCommonCommands);
  		$$invalidate(2, client = createClient(createRenderer(term, localEcho), characterCreator));
  		readLine(localEcho);
  	}

  	onMount(async () => {
  		// change global background
  		document.body.style.backgroundImage = "url('/bg.jpg')";

  		document.body.style.backdropFilter = "blur(10px) saturate(30%) brightness(50%)";
  		var nav = document.querySelector("nav");

  		if (nav) {
  			nav.style.backgroundColor = "#00000000";
  			setupTerminal();
  		}
  	});

  	onDestroy(async () => {
  		// change global background
  		document.body.style.backgroundImage = "";

  		document.body.style.backdropFilter = "";
  		var nav = document.querySelector("nav");

  		if (nav) {
  			nav.style.backgroundColor = "#00000055";
  			setupTerminal();
  		}
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Game> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Game", $$slots, []);

  	$$self.$capture_state = () => ({
  		MediaQuery,
  		CharacterCreator,
  		onMount,
  		onDestroy,
  		createAuth,
  		getAuth,
  		axios: axios$1,
  		xterm: xterm$1,
  		LocalEchoController,
  		fit,
  		createClient,
  		getClient,
  		wsbackend,
  		UserMenu,
  		client,
  		term,
  		ws,
  		isAuthenticated,
  		authToken,
  		sleep,
  		readLine,
  		createRenderer,
  		characterCreator,
  		setupTerminal,
  		autocompleteCommonCommands,
  		state,
  		$isAuthenticated,
  		$authToken
  	});

  	$$self.$inject_state = $$props => {
  		if ("client" in $$props) $$invalidate(2, client = $$props.client);
  		if ("term" in $$props) term = $$props.term;
  		if ("ws" in $$props) $$invalidate(4, ws = $$props.ws);
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isAuthenticated, $authToken*/ 192) {
  			 state = {
  				isAuthenticated: $isAuthenticated,
  				authToken: $authToken.slice(0, 20)
  			};
  		}

  		if ($$self.$$.dirty & /*client, ws, $authToken*/ 148) {
  			 {
  				if (client && !ws) {
  					// connect to websocket server
  					const url = wsbackend + "?access_token=";

  					$$invalidate(4, ws = new WebSocket(url + $authToken));
  					client.setWSClient(ws);
  				}
  			}
  		}
  	};

  	return [isAuthenticated, authToken];
  }

  class Game extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Game",
  			options,
  			id: create_fragment$i.name
  		});
  	}
  }

  /* src/components/NavLink.svelte generated by Svelte v3.22.3 */

  // (17:0) <Link to="{to}" getProps="{getProps}">
  function create_default_slot(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[1].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 4) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[2], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot.name,
  		type: "slot",
  		source: "(17:0) <Link to=\\\"{to}\\\" getProps=\\\"{getProps}\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$j(ctx) {
  	let current;

  	const link = new Link({
  			props: {
  				to: /*to*/ ctx[0],
  				getProps,
  				$$slots: { default: [create_default_slot] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(link.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(link, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const link_changes = {};
  			if (dirty & /*to*/ 1) link_changes.to = /*to*/ ctx[0];

  			if (dirty & /*$$scope*/ 4) {
  				link_changes.$$scope = { dirty, ctx };
  			}

  			link.$set(link_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(link.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(link.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(link, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$j.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function getProps({ location, href, isPartiallyCurrent, isCurrent }) {
  	const isActive = href === "/"
  	? isCurrent
  	: isPartiallyCurrent || isCurrent;

  	// The object returned here is spread on the anchor element's attributes
  	if (isActive) {
  		return { class: "active" };
  	}

  	return {};
  }

  function instance$j($$self, $$props, $$invalidate) {
  	let { to = "" } = $$props;
  	const writable_props = ["to"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavLink> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("NavLink", $$slots, ['default']);

  	$$self.$set = $$props => {
  		if ("to" in $$props) $$invalidate(0, to = $$props.to);
  		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
  	};

  	$$self.$capture_state = () => ({ Link, to, getProps });

  	$$self.$inject_state = $$props => {
  		if ("to" in $$props) $$invalidate(0, to = $$props.to);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [to, $$slots, $$scope];
  }

  class NavLink extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$j, create_fragment$j, safe_not_equal, { to: 0 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "NavLink",
  			options,
  			id: create_fragment$j.name
  		});
  	}

  	get to() {
  		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set to(value) {
  		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/Welcome.svelte generated by Svelte v3.22.3 */

  const { console: console_1$3 } = globals;
  const file$f = "src/Welcome.svelte";

  // (90:30) 
  function create_if_block_1$3(ctx) {
  	let div;
  	let h4;
  	let t1;
  	let p;
  	let t2;
  	let a0;
  	let t4;
  	let a1;

  	const block = {
  		c: function create() {
  			div = element("div");
  			h4 = element("h4");
  			h4.textContent = "Welcome Stranger";
  			t1 = space();
  			p = element("p");
  			t2 = text("Please\n        ");
  			a0 = element("a");
  			a0.textContent = "log";
  			t4 = text("\n        in or\n        ");
  			a1 = element("a");
  			a1.textContent = "signup";
  			add_location(h4, file$f, 91, 6, 1924);
  			attr_dev(a0, "href", "/login");
  			attr_dev(a0, "class", "loginText svelte-8qrmfc");
  			add_location(a0, file$f, 94, 8, 1983);
  			attr_dev(a1, "href", "/signup");
  			attr_dev(a1, "class", "loginText svelte-8qrmfc");
  			add_location(a1, file$f, 96, 8, 2048);
  			add_location(p, file$f, 92, 6, 1956);
  			add_location(div, file$f, 90, 4, 1912);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, h4);
  			append_dev(div, t1);
  			append_dev(div, p);
  			append_dev(p, t2);
  			append_dev(p, a0);
  			append_dev(p, t4);
  			append_dev(p, a1);
  		},
  		p: noop,
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$3.name,
  		type: "if",
  		source: "(90:30) ",
  		ctx
  	});

  	return block;
  }

  // (71:2) {#if $isAuthenticated}
  function create_if_block$4(ctx) {
  	let div2;
  	let h5;
  	let t0;
  	let t1;
  	let t2;
  	let div0;
  	let t3;
  	let t4;
  	let div1;
  	let p;
  	let a;
  	let current;

  	const navlink0 = new NavLink({
  			props: {
  				to: "/play",
  				$$slots: { default: [create_default_slot_3] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const navlink1 = new NavLink({
  			props: {
  				to: "/creator",
  				$$slots: { default: [create_default_slot_2] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			div2 = element("div");
  			h5 = element("h5");
  			t0 = text("Welcome back ");
  			t1 = text(/*$nickname*/ ctx[1]);
  			t2 = space();
  			div0 = element("div");
  			create_component(navlink0.$$.fragment);
  			t3 = text("\n        or try to create some\n        ");
  			create_component(navlink1.$$.fragment);
  			t4 = space();
  			div1 = element("div");
  			p = element("p");
  			a = element("a");
  			a.textContent = "Create a new Character";
  			add_location(h5, file$f, 73, 6, 1540);
  			add_location(div0, file$f, 75, 6, 1581);
  			attr_dev(a, "class", "modal-trigger");
  			attr_dev(a, "href", "#modal1");
  			add_location(a, file$f, 84, 10, 1772);
  			add_location(p, file$f, 83, 8, 1758);
  			add_location(div1, file$f, 82, 6, 1744);
  			add_location(div2, file$f, 71, 4, 1527);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div2, anchor);
  			append_dev(div2, h5);
  			append_dev(h5, t0);
  			append_dev(h5, t1);
  			append_dev(div2, t2);
  			append_dev(div2, div0);
  			mount_component(navlink0, div0, null);
  			append_dev(div0, t3);
  			mount_component(navlink1, div0, null);
  			append_dev(div2, t4);
  			append_dev(div2, div1);
  			append_dev(div1, p);
  			append_dev(p, a);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (!current || dirty & /*$nickname*/ 2) set_data_dev(t1, /*$nickname*/ ctx[1]);
  			const navlink0_changes = {};

  			if (dirty & /*$$scope*/ 131072) {
  				navlink0_changes.$$scope = { dirty, ctx };
  			}

  			navlink0.$set(navlink0_changes);
  			const navlink1_changes = {};

  			if (dirty & /*$$scope*/ 131072) {
  				navlink1_changes.$$scope = { dirty, ctx };
  			}

  			navlink1.$set(navlink1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navlink0.$$.fragment, local);
  			transition_in(navlink1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navlink0.$$.fragment, local);
  			transition_out(navlink1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div2);
  			destroy_component(navlink0);
  			destroy_component(navlink1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$4.name,
  		type: "if",
  		source: "(71:2) {#if $isAuthenticated}",
  		ctx
  	});

  	return block;
  }

  // (78:8) <NavLink to="/play">
  function create_default_slot_3(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text("Start playing");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_3.name,
  		type: "slot",
  		source: "(78:8) <NavLink to=\\\"/play\\\">",
  		ctx
  	});

  	return block;
  }

  // (80:8) <NavLink to="/creator">
  function create_default_slot_2(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text("own content.");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_2.name,
  		type: "slot",
  		source: "(80:8) <NavLink to=\\\"/creator\\\">",
  		ctx
  	});

  	return block;
  }

  // (128:6) <NavLink to="/play">
  function create_default_slot_1(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text("play");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1.name,
  		type: "slot",
  		source: "(128:6) <NavLink to=\\\"/play\\\">",
  		ctx
  	});

  	return block;
  }

  // (159:4) <NavLink to="/credits">
  function create_default_slot$1(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text("See Credits");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$1.name,
  		type: "slot",
  		source: "(159:4) <NavLink to=\\\"/credits\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$k(ctx) {
  	let div3;
  	let current_block_type_index;
  	let if_block;
  	let t0;
  	let div0;
  	let h50;
  	let t2;
  	let p0;
  	let t4;
  	let p1;
  	let t6;
  	let ul0;
  	let li0;
  	let t8;
  	let li1;
  	let t10;
  	let ul1;
  	let li2;
  	let t12;
  	let li3;
  	let t14;
  	let li4;
  	let t16;
  	let li5;
  	let t18;
  	let p2;
  	let t19;
  	let t20;
  	let t21;
  	let ul2;
  	let li6;
  	let t23;
  	let li7;
  	let t25;
  	let li8;
  	let t27;
  	let li9;
  	let t29;
  	let li10;
  	let t31;
  	let li11;
  	let t33;
  	let li12;
  	let t35;
  	let li13;
  	let t37;
  	let div1;
  	let h51;
  	let t39;
  	let ul3;
  	let li14;
  	let t41;
  	let div2;
  	let h52;
  	let t43;
  	let t44;
  	let current;
  	const if_block_creators = [create_if_block$4, create_if_block_1$3];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*$isAuthenticated*/ ctx[0]) return 0;
  		if (!/*$isAuthenticated*/ ctx[0]) return 1;
  		return -1;
  	}

  	if (~(current_block_type_index = select_block_type(ctx))) {
  		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	}

  	const navlink0 = new NavLink({
  			props: {
  				to: "/play",
  				$$slots: { default: [create_default_slot_1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const navlink1 = new NavLink({
  			props: {
  				to: "/credits",
  				$$slots: { default: [create_default_slot$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const charactercreator = new CharacterCreator({ $$inline: true });

  	const block = {
  		c: function create() {
  			div3 = element("div");
  			if (if_block) if_block.c();
  			t0 = space();
  			div0 = element("div");
  			h50 = element("h5");
  			h50.textContent = "TalesMUD";
  			t2 = space();
  			p0 = element("p");
  			p0.textContent = "TalesMUD is a MUD/MUX game engine/game development platform. Using\n      TalesMud you can create your own MUD server, define your game content and\n      either use the existing web client or build a new one from scratch.";
  			t4 = space();
  			p1 = element("p");
  			p1.textContent = "This is still a very early version with many more features planned. As\n      development progresses you can expect several updates to the developer\n      sandbox version running on this site.";
  			t6 = text("\n    Implemented\n    ");
  			ul0 = element("ul");
  			li0 = element("li");
  			li0.textContent = "- Character creation";
  			t8 = space();
  			li1 = element("li");
  			li1.textContent = "- Room creation, movement between rooms";
  			t10 = text("\n    Planned\n    ");
  			ul1 = element("ul");
  			li2 = element("li");
  			li2.textContent = "- Items, Inventory Management";
  			t12 = space();
  			li3 = element("li");
  			li3.textContent = "- NPCs, Enemies and Dialogs";
  			t14 = space();
  			li4 = element("li");
  			li4.textContent = "- Combat System";
  			t16 = space();
  			li5 = element("li");
  			li5.textContent = "- Quest System";
  			t18 = space();
  			p2 = element("p");
  			t19 = text("Head over to\n      ");
  			create_component(navlink0.$$.fragment);
  			t20 = text("\n      create a character and try out the current set of commands by typing\n      [help]. List of all global commands:");
  			t21 = space();
  			ul2 = element("ul");
  			li6 = element("li");
  			li6.textContent = "[shrug] shrug emote";
  			t23 = space();
  			li7 = element("li");
  			li7.textContent = "[sc, selectcharacter] select a character, use: sc [charactername]";
  			t25 = space();
  			li8 = element("li");
  			li8.textContent = "[lc, listcharacters] list all your characters";
  			t27 = space();
  			li9 = element("li");
  			li9.textContent = "[h, help] are you really asking?";
  			t29 = space();
  			li10 = element("li");
  			li10.textContent = "[who] list all online players";
  			t31 = space();
  			li11 = element("li");
  			li11.textContent = "[inventory, i] Display your inventory";
  			t33 = space();
  			li12 = element("li");
  			li12.textContent = "[newcharacter, nc] Createa new character";
  			t35 = space();
  			li13 = element("li");
  			li13.textContent = "[scream] scream through the room";
  			t37 = space();
  			div1 = element("div");
  			h51 = element("h5");
  			h51.textContent = "News";
  			t39 = space();
  			ul3 = element("ul");
  			li14 = element("li");
  			li14.textContent = "12.06.2020 - First minimalistic version live supporting room creation,\n        character creation (template picks)";
  			t41 = space();
  			div2 = element("div");
  			h52 = element("h5");
  			h52.textContent = "Credits";
  			t43 = text("\n    The application uses several assets througout the app and the backend, here\n    is a list of free and licensed art:\n    ");
  			create_component(navlink1.$$.fragment);
  			t44 = space();
  			create_component(charactercreator.$$.fragment);
  			add_location(h50, file$f, 102, 4, 2138);
  			add_location(p0, file$f, 103, 4, 2160);
  			add_location(p1, file$f, 108, 4, 2404);
  			add_location(li0, file$f, 115, 6, 2646);
  			add_location(li1, file$f, 116, 6, 2682);
  			add_location(ul0, file$f, 114, 4, 2635);
  			add_location(li2, file$f, 120, 6, 2768);
  			add_location(li3, file$f, 121, 6, 2813);
  			add_location(li4, file$f, 122, 6, 2856);
  			add_location(li5, file$f, 123, 6, 2887);
  			add_location(ul1, file$f, 119, 4, 2757);
  			add_location(p2, file$f, 125, 4, 2925);
  			add_location(li6, file$f, 133, 6, 3132);
  			add_location(li7, file$f, 134, 6, 3167);
  			add_location(li8, file$f, 135, 6, 3248);
  			add_location(li9, file$f, 136, 6, 3309);
  			add_location(li10, file$f, 137, 6, 3357);
  			add_location(li11, file$f, 138, 6, 3402);
  			add_location(li12, file$f, 139, 6, 3455);
  			add_location(li13, file$f, 140, 6, 3511);
  			add_location(ul2, file$f, 131, 4, 3120);
  			add_location(div0, file$f, 101, 2, 2128);
  			add_location(h51, file$f, 146, 4, 3586);
  			add_location(li14, file$f, 148, 6, 3615);
  			add_location(ul3, file$f, 147, 4, 3604);
  			add_location(div1, file$f, 145, 2, 3576);
  			add_location(h52, file$f, 155, 4, 3786);
  			add_location(div2, file$f, 154, 2, 3776);
  			attr_dev(div3, "class", "left");
  			add_location(div3, file$f, 69, 0, 1479);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div3, anchor);

  			if (~current_block_type_index) {
  				if_blocks[current_block_type_index].m(div3, null);
  			}

  			append_dev(div3, t0);
  			append_dev(div3, div0);
  			append_dev(div0, h50);
  			append_dev(div0, t2);
  			append_dev(div0, p0);
  			append_dev(div0, t4);
  			append_dev(div0, p1);
  			append_dev(div0, t6);
  			append_dev(div0, ul0);
  			append_dev(ul0, li0);
  			append_dev(ul0, t8);
  			append_dev(ul0, li1);
  			append_dev(div0, t10);
  			append_dev(div0, ul1);
  			append_dev(ul1, li2);
  			append_dev(ul1, t12);
  			append_dev(ul1, li3);
  			append_dev(ul1, t14);
  			append_dev(ul1, li4);
  			append_dev(ul1, t16);
  			append_dev(ul1, li5);
  			append_dev(div0, t18);
  			append_dev(div0, p2);
  			append_dev(p2, t19);
  			mount_component(navlink0, p2, null);
  			append_dev(p2, t20);
  			append_dev(div0, t21);
  			append_dev(div0, ul2);
  			append_dev(ul2, li6);
  			append_dev(ul2, t23);
  			append_dev(ul2, li7);
  			append_dev(ul2, t25);
  			append_dev(ul2, li8);
  			append_dev(ul2, t27);
  			append_dev(ul2, li9);
  			append_dev(ul2, t29);
  			append_dev(ul2, li10);
  			append_dev(ul2, t31);
  			append_dev(ul2, li11);
  			append_dev(ul2, t33);
  			append_dev(ul2, li12);
  			append_dev(ul2, t35);
  			append_dev(ul2, li13);
  			append_dev(div3, t37);
  			append_dev(div3, div1);
  			append_dev(div1, h51);
  			append_dev(div1, t39);
  			append_dev(div1, ul3);
  			append_dev(ul3, li14);
  			append_dev(div3, t41);
  			append_dev(div3, div2);
  			append_dev(div2, h52);
  			append_dev(div2, t43);
  			mount_component(navlink1, div2, null);
  			append_dev(div3, t44);
  			mount_component(charactercreator, div3, null);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if (~current_block_type_index) {
  					if_blocks[current_block_type_index].p(ctx, dirty);
  				}
  			} else {
  				if (if_block) {
  					group_outros();

  					transition_out(if_blocks[previous_block_index], 1, 1, () => {
  						if_blocks[previous_block_index] = null;
  					});

  					check_outros();
  				}

  				if (~current_block_type_index) {
  					if_block = if_blocks[current_block_type_index];

  					if (!if_block) {
  						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  						if_block.c();
  					}

  					transition_in(if_block, 1);
  					if_block.m(div3, t0);
  				} else {
  					if_block = null;
  				}
  			}

  			const navlink0_changes = {};

  			if (dirty & /*$$scope*/ 131072) {
  				navlink0_changes.$$scope = { dirty, ctx };
  			}

  			navlink0.$set(navlink0_changes);
  			const navlink1_changes = {};

  			if (dirty & /*$$scope*/ 131072) {
  				navlink1_changes.$$scope = { dirty, ctx };
  			}

  			navlink1.$set(navlink1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			transition_in(navlink0.$$.fragment, local);
  			transition_in(navlink1.$$.fragment, local);
  			transition_in(charactercreator.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			transition_out(navlink0.$$.fragment, local);
  			transition_out(navlink1.$$.fragment, local);
  			transition_out(charactercreator.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div3);

  			if (~current_block_type_index) {
  				if_blocks[current_block_type_index].d();
  			}

  			destroy_component(navlink0);
  			destroy_component(navlink1);
  			destroy_component(charactercreator);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$k.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$k($$self, $$props, $$invalidate) {
  	let $isLoading;
  	let $isAuthenticated;
  	let $authError;
  	let $userInfo;
  	let $authToken;
  	let $nickname;
  	const nickname = writable("stranger");
  	validate_store(nickname, "nickname");
  	component_subscribe($$self, nickname, value => $$invalidate(1, $nickname = value));
  	let loaded = false;
  	const { isLoading, isAuthenticated, login, logout, authToken, authError, userInfo } = getAuth();
  	validate_store(isLoading, "isLoading");
  	component_subscribe($$self, isLoading, value => $$invalidate(10, $isLoading = value));
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(0, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(13, $authToken = value));
  	validate_store(authError, "authError");
  	component_subscribe($$self, authError, value => $$invalidate(11, $authError = value));
  	validate_store(userInfo, "userInfo");
  	component_subscribe($$self, userInfo, value => $$invalidate(12, $userInfo = value));

  	const loadUser = async () => {
  		
  	};

  	onMount(async () => {
  		document.addEventListener("DOMContentLoaded", function () {
  			var elems = document.querySelectorAll(".modal");
  			var instances = M.Modal.init(elems, {});
  		});

  		await loadUser();
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Welcome> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Welcome", $$slots, []);

  	$$self.$capture_state = () => ({
  		Sprites,
  		NavLink,
  		CharacterCreator,
  		onMount,
  		createAuth,
  		getAuth,
  		axios: axios$1,
  		onInterval,
  		getUser,
  		writable,
  		nickname,
  		loaded,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		authError,
  		userInfo,
  		loadUser,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken,
  		$nickname
  	});

  	$$self.$inject_state = $$props => {
  		if ("loaded" in $$props) $$invalidate(8, loaded = $$props.loaded);
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isLoading, $isAuthenticated, $authError, $userInfo, $authToken, $nickname*/ 15363) {
  			 state = {
  				isLoading: $isLoading,
  				isAuthenticated: $isAuthenticated,
  				authError: $authError,
  				userInfo: $userInfo ? $userInfo.name : null,
  				authToken: $authToken.slice(0, 20),
  				nickname: $nickname
  			};
  		}

  		if ($$self.$$.dirty & /*loaded, $isLoading, $isAuthenticated, $authToken*/ 9473) {
  			 {
  				if (!loaded && !$isLoading && $isAuthenticated) {
  					$$invalidate(8, loaded = true);

  					getUser(
  						$authToken,
  						user => {
  							nickname.set(user.nickname);
  						},
  						err => console.log(err)
  					);
  				}
  			}
  		}
  	};

  	return [
  		$isAuthenticated,
  		$nickname,
  		nickname,
  		isLoading,
  		isAuthenticated,
  		authToken,
  		authError,
  		userInfo
  	];
  }

  class Welcome extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Welcome",
  			options,
  			id: create_fragment$k.name
  		});
  	}
  }

  /* src/creator/ActionEditor.svelte generated by Svelte v3.22.3 */

  const file$g = "src/creator/ActionEditor.svelte";

  function create_fragment$l(ctx) {
  	let li;
  	let div0;
  	let i;
  	let t1;
  	let t2_value = /*exit*/ ctx[0].name + "";
  	let t2;
  	let t3;
  	let div7;
  	let div1;
  	let label0;
  	let input0;
  	let t4;
  	let span;
  	let t6;
  	let button;
  	let t8;
  	let div6;
  	let div5;
  	let input1;
  	let input1_id_value;
  	let t9;
  	let label1;
  	let t10;
  	let label1_for_value;
  	let t11;
  	let div4;
  	let input2;
  	let input2_id_value;
  	let t12;
  	let label2;
  	let t13;
  	let label2_for_value;
  	let t14;
  	let div2;
  	let input3;
  	let input3_id_value;
  	let t15;
  	let label3;
  	let t16;
  	let label3_for_value;
  	let t17;
  	let div3;
  	let input4;
  	let input4_id_value;
  	let t18;
  	let label4;
  	let dispose;

  	const block = {
  		c: function create() {
  			li = element("li");
  			div0 = element("div");
  			i = element("i");
  			i.textContent = "exit_to_app";
  			t1 = space();
  			t2 = text(t2_value);
  			t3 = space();
  			div7 = element("div");
  			div1 = element("div");
  			label0 = element("label");
  			input0 = element("input");
  			t4 = space();
  			span = element("span");
  			span.textContent = "Hidden";
  			t6 = space();
  			button = element("button");
  			button.textContent = "Delete Exit";
  			t8 = space();
  			div6 = element("div");
  			div5 = element("div");
  			input1 = element("input");
  			t9 = space();
  			label1 = element("label");
  			t10 = text("Name");
  			t11 = space();
  			div4 = element("div");
  			input2 = element("input");
  			t12 = space();
  			label2 = element("label");
  			t13 = text("Description");
  			t14 = space();
  			div2 = element("div");
  			input3 = element("input");
  			t15 = space();
  			label3 = element("label");
  			t16 = text("Target Room");
  			t17 = space();
  			div3 = element("div");
  			input4 = element("input");
  			t18 = space();
  			label4 = element("label");
  			label4.textContent = "Target Room";
  			attr_dev(i, "class", "material-icons");
  			add_location(i, file$g, 26, 4, 336);
  			attr_dev(div0, "class", "collapsible-header svelte-1bo8y5f");
  			add_location(div0, file$g, 25, 2, 299);
  			attr_dev(input0, "type", "checkbox");
  			attr_dev(input0, "class", "svelte-1bo8y5f");
  			add_location(input0, file$g, 34, 8, 482);
  			add_location(span, file$g, 35, 8, 545);
  			attr_dev(label0, "class", "svelte-1bo8y5f");
  			add_location(label0, file$g, 33, 6, 466);
  			attr_dev(button, "class", "btn-small red right");
  			add_location(button, file$g, 37, 6, 586);
  			attr_dev(div1, "class", "row");
  			add_location(div1, file$g, 31, 4, 441);
  			attr_dev(input1, "placeholder", "Placeholder");
  			attr_dev(input1, "id", input1_id_value = "name-" + /*exit*/ ctx[0].name);
  			attr_dev(input1, "type", "text");
  			attr_dev(input1, "class", "svelte-1bo8y5f");
  			add_location(input1, file$g, 45, 8, 770);
  			attr_dev(label1, "for", label1_for_value = "name-" + /*exit*/ ctx[0].name);
  			attr_dev(label1, "class", "svelte-1bo8y5f");
  			add_location(label1, file$g, 51, 8, 921);
  			attr_dev(input2, "placeholder", "Placeholder");
  			attr_dev(input2, "id", input2_id_value = "desc-" + /*exit*/ ctx[0].description);
  			attr_dev(input2, "type", "text");
  			attr_dev(input2, "class", "svelte-1bo8y5f");
  			add_location(input2, file$g, 54, 10, 1009);
  			attr_dev(label2, "for", label2_for_value = "desc-" + /*exit*/ ctx[0].description);
  			attr_dev(label2, "class", "svelte-1bo8y5f");
  			add_location(label2, file$g, 60, 10, 1186);
  			attr_dev(input3, "id", input3_id_value = "target-" + /*exit*/ ctx[0].target);
  			attr_dev(input3, "type", "text");
  			attr_dev(input3, "class", "svelte-1bo8y5f");
  			add_location(input3, file$g, 62, 12, 1291);
  			attr_dev(label3, "for", label3_for_value = "target-" + /*exit*/ ctx[0].target);
  			attr_dev(label3, "class", "svelte-1bo8y5f");
  			add_location(label3, file$g, 67, 12, 1432);
  			attr_dev(div2, "class", "input-field");
  			add_location(div2, file$g, 61, 10, 1253);
  			attr_dev(input4, "type", "text");
  			attr_dev(input4, "id", input4_id_value = "autocomplete-input-" + /*exit*/ ctx[0].name);
  			attr_dev(input4, "class", "autocomplete svelte-1bo8y5f");
  			add_location(input4, file$g, 70, 12, 1551);
  			attr_dev(label4, "for", "autocomplete-input");
  			attr_dev(label4, "class", "svelte-1bo8y5f");
  			add_location(label4, file$g, 75, 12, 1696);
  			attr_dev(div3, "class", "input-field");
  			add_location(div3, file$g, 69, 10, 1513);
  			attr_dev(div4, "class", "input-field");
  			add_location(div4, file$g, 53, 8, 973);
  			attr_dev(div5, "class", "input-field");
  			add_location(div5, file$g, 44, 6, 736);
  			attr_dev(div6, "class", "row");
  			add_location(div6, file$g, 42, 4, 711);
  			attr_dev(div7, "class", "collapsible-body svelte-1bo8y5f");
  			add_location(div7, file$g, 30, 2, 406);
  			add_location(li, file$g, 24, 0, 292);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, li, anchor);
  			append_dev(li, div0);
  			append_dev(div0, i);
  			append_dev(div0, t1);
  			append_dev(div0, t2);
  			append_dev(li, t3);
  			append_dev(li, div7);
  			append_dev(div7, div1);
  			append_dev(div1, label0);
  			append_dev(label0, input0);
  			input0.checked = /*exit*/ ctx[0].hidden;
  			append_dev(label0, t4);
  			append_dev(label0, span);
  			append_dev(div1, t6);
  			append_dev(div1, button);
  			append_dev(div7, t8);
  			append_dev(div7, div6);
  			append_dev(div6, div5);
  			append_dev(div5, input1);
  			set_input_value(input1, /*exit*/ ctx[0].name);
  			append_dev(div5, t9);
  			append_dev(div5, label1);
  			append_dev(label1, t10);
  			append_dev(div5, t11);
  			append_dev(div5, div4);
  			append_dev(div4, input2);
  			set_input_value(input2, /*exit*/ ctx[0].description);
  			append_dev(div4, t12);
  			append_dev(div4, label2);
  			append_dev(label2, t13);
  			append_dev(div4, t14);
  			append_dev(div4, div2);
  			append_dev(div2, input3);
  			set_input_value(input3, /*exit*/ ctx[0].target);
  			append_dev(div2, t15);
  			append_dev(div2, label3);
  			append_dev(label3, t16);
  			append_dev(div4, t17);
  			append_dev(div4, div3);
  			append_dev(div3, input4);
  			append_dev(div3, t18);
  			append_dev(div3, label4);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input0, "change", /*input0_change_handler*/ ctx[2]),
  				listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false),
  				listen_dev(input1, "input", /*input1_input_handler*/ ctx[4]),
  				listen_dev(input2, "input", /*input2_input_handler*/ ctx[5]),
  				listen_dev(input3, "input", /*input3_input_handler*/ ctx[6])
  			];
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*exit*/ 1 && t2_value !== (t2_value = /*exit*/ ctx[0].name + "")) set_data_dev(t2, t2_value);

  			if (dirty & /*exit*/ 1) {
  				input0.checked = /*exit*/ ctx[0].hidden;
  			}

  			if (dirty & /*exit*/ 1 && input1_id_value !== (input1_id_value = "name-" + /*exit*/ ctx[0].name)) {
  				attr_dev(input1, "id", input1_id_value);
  			}

  			if (dirty & /*exit*/ 1 && input1.value !== /*exit*/ ctx[0].name) {
  				set_input_value(input1, /*exit*/ ctx[0].name);
  			}

  			if (dirty & /*exit*/ 1 && label1_for_value !== (label1_for_value = "name-" + /*exit*/ ctx[0].name)) {
  				attr_dev(label1, "for", label1_for_value);
  			}

  			if (dirty & /*exit*/ 1 && input2_id_value !== (input2_id_value = "desc-" + /*exit*/ ctx[0].description)) {
  				attr_dev(input2, "id", input2_id_value);
  			}

  			if (dirty & /*exit*/ 1 && input2.value !== /*exit*/ ctx[0].description) {
  				set_input_value(input2, /*exit*/ ctx[0].description);
  			}

  			if (dirty & /*exit*/ 1 && label2_for_value !== (label2_for_value = "desc-" + /*exit*/ ctx[0].description)) {
  				attr_dev(label2, "for", label2_for_value);
  			}

  			if (dirty & /*exit*/ 1 && input3_id_value !== (input3_id_value = "target-" + /*exit*/ ctx[0].target)) {
  				attr_dev(input3, "id", input3_id_value);
  			}

  			if (dirty & /*exit*/ 1 && input3.value !== /*exit*/ ctx[0].target) {
  				set_input_value(input3, /*exit*/ ctx[0].target);
  			}

  			if (dirty & /*exit*/ 1 && label3_for_value !== (label3_for_value = "target-" + /*exit*/ ctx[0].target)) {
  				attr_dev(label3, "for", label3_for_value);
  			}

  			if (dirty & /*exit*/ 1 && input4_id_value !== (input4_id_value = "autocomplete-input-" + /*exit*/ ctx[0].name)) {
  				attr_dev(input4, "id", input4_id_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$l.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$l($$self, $$props, $$invalidate) {
  	let { exit } = $$props;
  	let { deleteExit } = $$props;
  	const writable_props = ["exit", "deleteExit"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ActionEditor> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("ActionEditor", $$slots, []);

  	function input0_change_handler() {
  		exit.hidden = this.checked;
  		$$invalidate(0, exit);
  	}

  	const click_handler = () => deleteExit(exit);

  	function input1_input_handler() {
  		exit.name = this.value;
  		$$invalidate(0, exit);
  	}

  	function input2_input_handler() {
  		exit.description = this.value;
  		$$invalidate(0, exit);
  	}

  	function input3_input_handler() {
  		exit.target = this.value;
  		$$invalidate(0, exit);
  	}

  	$$self.$set = $$props => {
  		if ("exit" in $$props) $$invalidate(0, exit = $$props.exit);
  		if ("deleteExit" in $$props) $$invalidate(1, deleteExit = $$props.deleteExit);
  	};

  	$$self.$capture_state = () => ({ exit, deleteExit });

  	$$self.$inject_state = $$props => {
  		if ("exit" in $$props) $$invalidate(0, exit = $$props.exit);
  		if ("deleteExit" in $$props) $$invalidate(1, deleteExit = $$props.deleteExit);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		exit,
  		deleteExit,
  		input0_change_handler,
  		click_handler,
  		input1_input_handler,
  		input2_input_handler,
  		input3_input_handler
  	];
  }

  class ActionEditor extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$l, create_fragment$l, safe_not_equal, { exit: 0, deleteExit: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "ActionEditor",
  			options,
  			id: create_fragment$l.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*exit*/ ctx[0] === undefined && !("exit" in props)) {
  			console.warn("<ActionEditor> was created without expected prop 'exit'");
  		}

  		if (/*deleteExit*/ ctx[1] === undefined && !("deleteExit" in props)) {
  			console.warn("<ActionEditor> was created without expected prop 'deleteExit'");
  		}
  	}

  	get exit() {
  		throw new Error("<ActionEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set exit(value) {
  		throw new Error("<ActionEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get deleteExit() {
  		throw new Error("<ActionEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set deleteExit(value) {
  		throw new Error("<ActionEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/creator/Toolbar.svelte generated by Svelte v3.22.3 */

  const { console: console_1$4 } = globals;
  const file$h = "src/creator/Toolbar.svelte";

  function get_each_context$2(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[1] = list[i];
  	return child_ctx;
  }

  // (56:32) 
  function create_if_block_2$1(ctx) {
  	let i;
  	let t_value = /*action*/ ctx[1].icon + "";
  	let t;

  	const block = {
  		c: function create() {
  			i = element("i");
  			t = text(t_value);
  			attr_dev(i, "class", "material-icons center");
  			add_location(i, file$h, 56, 12, 994);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, i, anchor);
  			append_dev(i, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*toolbar*/ 1 && t_value !== (t_value = /*action*/ ctx[1].icon + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(i);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$1.name,
  		type: "if",
  		source: "(56:32) ",
  		ctx
  	});

  	return block;
  }

  // (54:10) {#if action.icon && action.name}
  function create_if_block_1$4(ctx) {
  	let i;
  	let t_value = /*action*/ ctx[1].icon + "";
  	let t;

  	const block = {
  		c: function create() {
  			i = element("i");
  			t = text(t_value);
  			attr_dev(i, "class", "material-icons left");
  			add_location(i, file$h, 54, 12, 900);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, i, anchor);
  			append_dev(i, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*toolbar*/ 1 && t_value !== (t_value = /*action*/ ctx[1].icon + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(i);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$4.name,
  		type: "if",
  		source: "(54:10) {#if action.icon && action.name}",
  		ctx
  	});

  	return block;
  }

  // (59:10) {#if action.name}
  function create_if_block$5(ctx) {
  	let t_value = /*action*/ ctx[1].name + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*toolbar*/ 1 && t_value !== (t_value = /*action*/ ctx[1].name + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$5.name,
  		type: "if",
  		source: "(59:10) {#if action.name}",
  		ctx
  	});

  	return block;
  }

  // (50:4) {#each toolbar.actions as action}
  function create_each_block$2(ctx) {
  	let li;
  	let button;
  	let t0;
  	let button_class_value;
  	let t1;
  	let dispose;

  	function select_block_type(ctx, dirty) {
  		if (/*action*/ ctx[1].icon && /*action*/ ctx[1].name) return create_if_block_1$4;
  		if (/*action*/ ctx[1].icon) return create_if_block_2$1;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block0 = current_block_type && current_block_type(ctx);
  	let if_block1 = /*action*/ ctx[1].name && create_if_block$5(ctx);

  	const block = {
  		c: function create() {
  			li = element("li");
  			button = element("button");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			if (if_block1) if_block1.c();
  			t1 = space();
  			attr_dev(button, "class", button_class_value = "btn-flat " + /*action*/ ctx[1].color + " svelte-13bgm0");
  			add_location(button, file$h, 51, 8, 777);
  			attr_dev(li, "class", "svelte-13bgm0");
  			add_location(li, file$h, 50, 6, 764);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, li, anchor);
  			append_dev(li, button);
  			if (if_block0) if_block0.m(button, null);
  			append_dev(button, t0);
  			if (if_block1) if_block1.m(button, null);
  			append_dev(li, t1);
  			if (remount) dispose();

  			dispose = listen_dev(
  				button,
  				"click",
  				function () {
  					if (is_function(/*action*/ ctx[1].fnc())) /*action*/ ctx[1].fnc().apply(this, arguments);
  				},
  				false,
  				false,
  				false
  			);
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;

  			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
  				if_block0.p(ctx, dirty);
  			} else {
  				if (if_block0) if_block0.d(1);
  				if_block0 = current_block_type && current_block_type(ctx);

  				if (if_block0) {
  					if_block0.c();
  					if_block0.m(button, t0);
  				}
  			}

  			if (/*action*/ ctx[1].name) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);
  				} else {
  					if_block1 = create_if_block$5(ctx);
  					if_block1.c();
  					if_block1.m(button, null);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}

  			if (dirty & /*toolbar*/ 1 && button_class_value !== (button_class_value = "btn-flat " + /*action*/ ctx[1].color + " svelte-13bgm0")) {
  				attr_dev(button, "class", button_class_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);

  			if (if_block0) {
  				if_block0.d();
  			}

  			if (if_block1) if_block1.d();
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$2.name,
  		type: "each",
  		source: "(50:4) {#each toolbar.actions as action}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$m(ctx) {
  	let div;
  	let ul;
  	let li;
  	let t0_value = /*toolbar*/ ctx[0].title + "";
  	let t0;
  	let t1;
  	let each_value = /*toolbar*/ ctx[0].actions;
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			div = element("div");
  			ul = element("ul");
  			li = element("li");
  			t0 = text(t0_value);
  			t1 = space();

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			attr_dev(li, "class", "header svelte-13bgm0");
  			add_location(li, file$h, 48, 4, 680);
  			attr_dev(ul, "class", "svelte-13bgm0");
  			add_location(ul, file$h, 47, 2, 671);
  			attr_dev(div, "class", "row");
  			add_location(div, file$h, 46, 0, 651);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, ul);
  			append_dev(ul, li);
  			append_dev(li, t0);
  			append_dev(ul, t1);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(ul, null);
  			}
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*toolbar*/ 1 && t0_value !== (t0_value = /*toolbar*/ ctx[0].title + "")) set_data_dev(t0, t0_value);

  			if (dirty & /*toolbar*/ 1) {
  				each_value = /*toolbar*/ ctx[0].actions;
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$2(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block$2(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(ul, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$m.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$m($$self, $$props, $$invalidate) {
  	let { toolbar = {
  		title: "TODO",
  		actions: [
  			{
  				name: "Change Me",
  				color: "green",
  				fnc: () => console.log("ACTION")
  			}
  		]
  	} } = $$props;

  	const writable_props = ["toolbar"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<Toolbar> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Toolbar", $$slots, []);

  	$$self.$set = $$props => {
  		if ("toolbar" in $$props) $$invalidate(0, toolbar = $$props.toolbar);
  	};

  	$$self.$capture_state = () => ({ toolbar });

  	$$self.$inject_state = $$props => {
  		if ("toolbar" in $$props) $$invalidate(0, toolbar = $$props.toolbar);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [toolbar];
  }

  class Toolbar extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$m, create_fragment$m, safe_not_equal, { toolbar: 0 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Toolbar",
  			options,
  			id: create_fragment$m.name
  		});
  	}

  	get toolbar() {
  		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set toolbar(value) {
  		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  function createStore() {
    const { subscribe, set, update } = writable({
      elements: [],
      selectedElement: null,
      filters: [],
      filterActive: false,
    });
    return {
      subscribe,
      set,
      addFilter: (key, val) => {
        update((state) => {
          let newFilters = state.filters;
          for (var i = 0; i < newFilters.length; i++) {
            if (newFilters[i].key === key) {
              newFilters.splice(i, 1);
            }
          }
          newFilters.push({
            key: key,
            val: val,
          });

          console.log("Added filter " + key + " " + val);

          state.filters = newFilters;
          return state;
        });
      },
      removeFilter: (key) => {
        update((state) => {
          let newFilters = state.filters;
          for (var i = 0; i < newFilters.length; i++) {
            if (newFilters[i].key === key) {
              newFilters.splice(i, 1);
            }
          }
          console.log("Removed filter " + key);
          state.filters = newFilters;
          return state;
        });
      },
      toggleFilter: () => {
        update((state) => {
          state.filterActive = !state.filterActive;
          return state;
        });
      },
      setSelectedElement: (element, cb) => {
        update((state) => {
          state.selectedElement = element;
          return state;
        });
        if (cb) cb();
      },
      setElements: (newelements) => {
        update((state) => {
          state.elements = newelements;
          return state;
        });
      },
    };
  }

  /* src/creator/CRUDEditorStore.svelte generated by Svelte v3.22.3 */

  const { console: console_1$5 } = globals;
  const file$i = "src/creator/CRUDEditorStore.svelte";
  const get_content_slot_changes = dirty => ({});
  const get_content_slot_context = ctx => ({});
  const get_hero_slot_changes = dirty => ({});
  const get_hero_slot_context = ctx => ({});

  function get_each_context$3(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[27] = list[i];
  	return child_ctx;
  }

  // (239:10) {#if element.slot}
  function create_if_block_4(ctx) {
  	let span;
  	let t_value = /*config*/ ctx[0].badge(/*element*/ ctx[27]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text(t_value);
  			attr_dev(span, "class", "new badge");
  			attr_dev(span, "data-badge-caption", "");
  			add_location(span, file$i, 239, 12, 4635);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*config, $store*/ 5 && t_value !== (t_value = /*config*/ ctx[0].badge(/*element*/ ctx[27]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_4.name,
  		type: "if",
  		source: "(239:10) {#if element.slot}",
  		ctx
  	});

  	return block;
  }

  // (232:6) {#each $store.elements as element}
  function create_each_block$3(ctx) {
  	let a;
  	let t0;
  	let t1_value = /*element*/ ctx[27].name + "";
  	let t1;
  	let t2;
  	let dispose;
  	let if_block = /*element*/ ctx[27].slot && create_if_block_4(ctx);

  	const block = {
  		c: function create() {
  			a = element("a");
  			if (if_block) if_block.c();
  			t0 = space();
  			t1 = text(t1_value);
  			t2 = space();
  			attr_dev(a, "href", "#!");
  			attr_dev(a, "class", "collection-item svelte-gyvals");
  			add_location(a, file$i, 232, 8, 4480);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);
  			if (if_block) if_block.m(a, null);
  			append_dev(a, t0);
  			append_dev(a, t1);
  			append_dev(a, t2);
  			if (remount) dispose();

  			dispose = listen_dev(
  				a,
  				"click",
  				function () {
  					if (is_function(/*selectElement*/ ctx[7](/*element*/ ctx[27]))) /*selectElement*/ ctx[7](/*element*/ ctx[27]).apply(this, arguments);
  				},
  				false,
  				false,
  				false
  			);
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;

  			if (/*element*/ ctx[27].slot) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_4(ctx);
  					if_block.c();
  					if_block.m(a, t0);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (dirty & /*$store*/ 4 && t1_value !== (t1_value = /*element*/ ctx[27].name + "")) set_data_dev(t1, t1_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (if_block) if_block.d();
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$3.name,
  		type: "each",
  		source: "(232:6) {#each $store.elements as element}",
  		ctx
  	});

  	return block;
  }

  // (253:4) {#if $store.filterActive}
  function create_if_block_3(ctx) {
  	let div1;
  	let div0;

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			div0 = element("div");
  			attr_dev(div0, "class", "chips chips-placeholder search svelte-gyvals");
  			add_location(div0, file$i, 254, 8, 4957);
  			attr_dev(div1, "class", "card-panel white");
  			add_location(div1, file$i, 253, 6, 4918);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			append_dev(div1, div0);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3.name,
  		type: "if",
  		source: "(253:4) {#if $store.filterActive}",
  		ctx
  	});

  	return block;
  }

  // (260:4) {#if $store.selectedElement}
  function create_if_block$6(ctx) {
  	let div7;
  	let div0;
  	let t0;
  	let span;
  	let t1_value = /*$store*/ ctx[2].selectedElement.name + "";
  	let t1;
  	let t2;
  	let t3;
  	let div2;
  	let div1;
  	let input0;
  	let t4;
  	let label0;
  	let t6;
  	let t7;
  	let div4;
  	let div3;
  	let input1;
  	let t8;
  	let label1;
  	let t10;
  	let div6;
  	let div5;
  	let input2;
  	let t11;
  	let label2;
  	let t13;
  	let current;
  	let dispose;
  	const hero_slot_template = /*$$slots*/ ctx[18].hero;
  	const hero_slot = create_slot(hero_slot_template, ctx, /*$$scope*/ ctx[17], get_hero_slot_context);

  	function select_block_type(ctx, dirty) {
  		if (/*$store*/ ctx[2].selectedElement.isNew) return create_if_block_2$2;
  		return create_else_block_1;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block0 = current_block_type(ctx);

  	function select_block_type_1(ctx, dirty) {
  		if (/*$store*/ ctx[2].selectedElement.isNew) return create_if_block_1$5;
  		return create_else_block$1;
  	}

  	let current_block_type_1 = select_block_type_1(ctx);
  	let if_block1 = current_block_type_1(ctx);
  	const content_slot_template = /*$$slots*/ ctx[18].content;
  	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[17], get_content_slot_context);

  	const block = {
  		c: function create() {
  			div7 = element("div");
  			div0 = element("div");
  			if (hero_slot) hero_slot.c();
  			t0 = space();
  			span = element("span");
  			t1 = text(t1_value);
  			t2 = space();
  			if_block0.c();
  			t3 = space();
  			div2 = element("div");
  			div1 = element("div");
  			input0 = element("input");
  			t4 = space();
  			label0 = element("label");
  			label0.textContent = "Name";
  			t6 = space();
  			if_block1.c();
  			t7 = space();
  			div4 = element("div");
  			div3 = element("div");
  			input1 = element("input");
  			t8 = space();
  			label1 = element("label");
  			label1.textContent = "Description";
  			t10 = space();
  			div6 = element("div");
  			div5 = element("div");
  			input2 = element("input");
  			t11 = space();
  			label2 = element("label");
  			label2.textContent = "Detail (look)";
  			t13 = space();
  			if (content_slot) content_slot.c();
  			attr_dev(span, "class", "header svelte-gyvals");
  			add_location(span, file$i, 264, 10, 5218);
  			attr_dev(div0, "class", "row");
  			add_location(div0, file$i, 262, 8, 5159);
  			attr_dev(input0, "placeholder", "Name");
  			attr_dev(input0, "id", "itemTemplate_name");
  			attr_dev(input0, "type", "text");
  			attr_dev(input0, "class", "svelte-gyvals");
  			add_location(input0, file$i, 291, 12, 6033);
  			attr_dev(label0, "class", "first_label svelte-gyvals");
  			attr_dev(label0, "for", "itemTemplate_name");
  			add_location(label0, file$i, 297, 12, 6220);
  			attr_dev(div1, "class", "no-padding input-field col s6 svelte-gyvals");
  			add_location(div1, file$i, 290, 10, 5977);
  			attr_dev(div2, "class", "row");
  			add_location(div2, file$i, 289, 8, 5949);
  			attr_dev(input1, "placeholder", "Item Description");
  			attr_dev(input1, "id", "itemTemplate_description");
  			attr_dev(input1, "type", "text");
  			attr_dev(input1, "class", "materialize-textarea svelte-gyvals");
  			add_location(input1, file$i, 327, 12, 7149);
  			attr_dev(label1, "class", "active svelte-gyvals");
  			attr_dev(label1, "for", "itemTemplate_description");
  			add_location(label1, file$i, 334, 12, 7405);
  			attr_dev(div3, "class", "input-field");
  			add_location(div3, file$i, 326, 10, 7111);
  			attr_dev(div4, "class", "row");
  			add_location(div4, file$i, 325, 8, 7083);
  			attr_dev(input2, "placeholder", "Item Details");
  			attr_dev(input2, "id", "itemTemplate_detail");
  			attr_dev(input2, "type", "text");
  			attr_dev(input2, "class", "materialize-textarea svelte-gyvals");
  			add_location(input2, file$i, 342, 12, 7613);
  			attr_dev(label2, "class", "active svelte-gyvals");
  			attr_dev(label2, "for", "itemTemplate_detail");
  			add_location(label2, file$i, 349, 12, 7855);
  			attr_dev(div5, "class", "input-field");
  			add_location(div5, file$i, 341, 10, 7575);
  			attr_dev(div6, "class", "row");
  			add_location(div6, file$i, 340, 8, 7547);
  			attr_dev(div7, "class", "card-panel cyan darken-4");
  			add_location(div7, file$i, 260, 6, 5111);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div7, anchor);
  			append_dev(div7, div0);

  			if (hero_slot) {
  				hero_slot.m(div0, null);
  			}

  			append_dev(div0, t0);
  			append_dev(div0, span);
  			append_dev(span, t1);
  			append_dev(div0, t2);
  			if_block0.m(div0, null);
  			append_dev(div7, t3);
  			append_dev(div7, div2);
  			append_dev(div2, div1);
  			append_dev(div1, input0);
  			set_input_value(input0, /*$store*/ ctx[2].selectedElement.name);
  			append_dev(div1, t4);
  			append_dev(div1, label0);
  			append_dev(div2, t6);
  			if_block1.m(div2, null);
  			append_dev(div7, t7);
  			append_dev(div7, div4);
  			append_dev(div4, div3);
  			append_dev(div3, input1);
  			set_input_value(input1, /*$store*/ ctx[2].selectedElement.description);
  			append_dev(div3, t8);
  			append_dev(div3, label1);
  			append_dev(div7, t10);
  			append_dev(div7, div6);
  			append_dev(div6, div5);
  			append_dev(div5, input2);
  			set_input_value(input2, /*$store*/ ctx[2].selectedElement.detail);
  			append_dev(div5, t11);
  			append_dev(div5, label2);
  			append_dev(div7, t13);

  			if (content_slot) {
  				content_slot.m(div7, null);
  			}

  			current = true;
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input0, "input", /*input0_input_handler*/ ctx[22]),
  				listen_dev(input1, "input", /*input1_input_handler*/ ctx[25]),
  				listen_dev(input2, "input", /*input2_input_handler*/ ctx[26])
  			];
  		},
  		p: function update(ctx, dirty) {
  			if (hero_slot) {
  				if (hero_slot.p && dirty & /*$$scope*/ 131072) {
  					hero_slot.p(get_slot_context(hero_slot_template, ctx, /*$$scope*/ ctx[17], get_hero_slot_context), get_slot_changes(hero_slot_template, /*$$scope*/ ctx[17], dirty, get_hero_slot_changes));
  				}
  			}

  			if ((!current || dirty & /*$store*/ 4) && t1_value !== (t1_value = /*$store*/ ctx[2].selectedElement.name + "")) set_data_dev(t1, t1_value);

  			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
  				if_block0.p(ctx, dirty);
  			} else {
  				if_block0.d(1);
  				if_block0 = current_block_type(ctx);

  				if (if_block0) {
  					if_block0.c();
  					if_block0.m(div0, null);
  				}
  			}

  			if (dirty & /*$store*/ 4 && input0.value !== /*$store*/ ctx[2].selectedElement.name) {
  				set_input_value(input0, /*$store*/ ctx[2].selectedElement.name);
  			}

  			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
  				if_block1.p(ctx, dirty);
  			} else {
  				if_block1.d(1);
  				if_block1 = current_block_type_1(ctx);

  				if (if_block1) {
  					if_block1.c();
  					if_block1.m(div2, null);
  				}
  			}

  			if (dirty & /*$store*/ 4 && input1.value !== /*$store*/ ctx[2].selectedElement.description) {
  				set_input_value(input1, /*$store*/ ctx[2].selectedElement.description);
  			}

  			if (dirty & /*$store*/ 4 && input2.value !== /*$store*/ ctx[2].selectedElement.detail) {
  				set_input_value(input2, /*$store*/ ctx[2].selectedElement.detail);
  			}

  			if (content_slot) {
  				if (content_slot.p && dirty & /*$$scope*/ 131072) {
  					content_slot.p(get_slot_context(content_slot_template, ctx, /*$$scope*/ ctx[17], get_content_slot_context), get_slot_changes(content_slot_template, /*$$scope*/ ctx[17], dirty, get_content_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(hero_slot, local);
  			transition_in(content_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(hero_slot, local);
  			transition_out(content_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div7);
  			if (hero_slot) hero_slot.d(detaching);
  			if_block0.d();
  			if_block1.d();
  			if (content_slot) content_slot.d(detaching);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$6.name,
  		type: "if",
  		source: "(260:4) {#if $store.selectedElement}",
  		ctx
  	});

  	return block;
  }

  // (274:10) {:else}
  function create_else_block_1(ctx) {
  	let button0;
  	let t1;
  	let button1;
  	let dispose;

  	const block = {
  		c: function create() {
  			button0 = element("button");
  			button0.textContent = "Update";
  			t1 = space();
  			button1 = element("button");
  			button1.textContent = "Delete";
  			attr_dev(button0, "class", "waves-effect waves-light btn-small green right svelte-gyvals");
  			add_location(button0, file$i, 274, 12, 5540);
  			attr_dev(button1, "class", "waves-effect waves-light btn-small red right svelte-gyvals");
  			add_location(button1, file$i, 280, 12, 5728);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, button0, anchor);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, button1, anchor);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(button0, "click", /*click_handler_1*/ ctx[20], false, false, false),
  				listen_dev(button1, "click", /*click_handler_2*/ ctx[21], false, false, false)
  			];
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(button0);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(button1);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_1.name,
  		type: "else",
  		source: "(274:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (267:10) {#if $store.selectedElement.isNew}
  function create_if_block_2$2(ctx) {
  	let button;
  	let dispose;

  	const block = {
  		c: function create() {
  			button = element("button");
  			button.textContent = "Create";
  			attr_dev(button, "class", "waves-effect waves-light btn-small green right svelte-gyvals");
  			add_location(button, file$i, 267, 12, 5334);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, button, anchor);
  			if (remount) dispose();
  			dispose = listen_dev(button, "click", /*click_handler*/ ctx[19], false, false, false);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(button);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$2.name,
  		type: "if",
  		source: "(267:10) {#if $store.selectedElement.isNew}",
  		ctx
  	});

  	return block;
  }

  // (311:10) {:else}
  function create_else_block$1(ctx) {
  	let div;
  	let input;
  	let t0;
  	let label;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			input = element("input");
  			t0 = space();
  			label = element("label");
  			label.textContent = "ID";
  			attr_dev(input, "placeholder", "ID");
  			attr_dev(input, "id", "itemTemplate_id");
  			attr_dev(input, "type", "text");
  			input.disabled = true;
  			attr_dev(input, "class", "svelte-gyvals");
  			add_location(input, file$i, 312, 14, 6750);
  			attr_dev(label, "class", "active svelte-gyvals");
  			attr_dev(label, "for", "itemTemplate_id");
  			add_location(label, file$i, 319, 14, 6968);
  			attr_dev(div, "class", "input-field col s4");
  			add_location(div, file$i, 311, 12, 6703);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, input);
  			set_input_value(input, /*$store*/ ctx[2].selectedElement.id);
  			append_dev(div, t0);
  			append_dev(div, label);
  			if (remount) dispose();
  			dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[24]);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$store*/ 4 && input.value !== /*$store*/ ctx[2].selectedElement.id) {
  				set_input_value(input, /*$store*/ ctx[2].selectedElement.id);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$1.name,
  		type: "else",
  		source: "(311:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (301:10) {#if $store.selectedElement.isNew}
  function create_if_block_1$5(ctx) {
  	let div;
  	let input;
  	let t0;
  	let label;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			input = element("input");
  			t0 = space();
  			label = element("label");
  			label.textContent = "ID";
  			attr_dev(input, "placeholder", "ID");
  			attr_dev(input, "id", "itemTemplate_id");
  			attr_dev(input, "type", "text");
  			attr_dev(input, "class", "svelte-gyvals");
  			add_location(input, file$i, 302, 14, 6406);
  			attr_dev(label, "class", "active svelte-gyvals");
  			attr_dev(label, "for", "itemTemplate_id");
  			add_location(label, file$i, 308, 14, 6599);
  			attr_dev(div, "class", "input-field col s4");
  			add_location(div, file$i, 301, 12, 6359);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, input);
  			set_input_value(input, /*$store*/ ctx[2].selectedElement.id);
  			append_dev(div, t0);
  			append_dev(div, label);
  			if (remount) dispose();
  			dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[23]);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$store*/ 4 && input.value !== /*$store*/ ctx[2].selectedElement.id) {
  				set_input_value(input, /*$store*/ ctx[2].selectedElement.id);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$5.name,
  		type: "if",
  		source: "(301:10) {#if $store.selectedElement.isNew}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$n(ctx) {
  	let t0;
  	let div3;
  	let div1;
  	let div0;
  	let t1;
  	let div2;
  	let t2;
  	let current;

  	const toolbar = new Toolbar({
  			props: { toolbar: /*toolbarConfig*/ ctx[9] },
  			$$inline: true
  		});

  	let each_value = /*$store*/ ctx[2].elements;
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  	}

  	let if_block0 = /*$store*/ ctx[2].filterActive && create_if_block_3(ctx);
  	let if_block1 = /*$store*/ ctx[2].selectedElement && create_if_block$6(ctx);

  	const block = {
  		c: function create() {
  			create_component(toolbar.$$.fragment);
  			t0 = space();
  			div3 = element("div");
  			div1 = element("div");
  			div0 = element("div");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			t1 = space();
  			div2 = element("div");
  			if (if_block0) if_block0.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div0, "class", "collection svelte-gyvals");
  			add_location(div0, file$i, 230, 4, 4406);
  			attr_dev(div1, "class", "col s3");
  			add_location(div1, file$i, 229, 2, 4381);
  			attr_dev(div2, "class", "col s9");
  			add_location(div2, file$i, 250, 2, 4860);
  			attr_dev(div3, "class", "row");
  			add_location(div3, file$i, 226, 0, 4321);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(toolbar, target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div3, anchor);
  			append_dev(div3, div1);
  			append_dev(div1, div0);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(div0, null);
  			}

  			append_dev(div3, t1);
  			append_dev(div3, div2);
  			if (if_block0) if_block0.m(div2, null);
  			append_dev(div2, t2);
  			if (if_block1) if_block1.m(div2, null);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*selectElement, $store, config*/ 133) {
  				each_value = /*$store*/ ctx[2].elements;
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$3(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block$3(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(div0, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}

  			if (/*$store*/ ctx[2].filterActive) {
  				if (if_block0) ; else {
  					if_block0 = create_if_block_3(ctx);
  					if_block0.c();
  					if_block0.m(div2, t2);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (/*$store*/ ctx[2].selectedElement) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty & /*$store*/ 4) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block$6(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div2, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(toolbar.$$.fragment, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(toolbar.$$.fragment, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(toolbar, detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div3);
  			destroy_each(each_blocks, detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$n.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$n($$self, $$props, $$invalidate) {
  	let $isAuthenticated;
  	let $authToken;

  	let $store,
  		$$unsubscribe_store = noop,
  		$$subscribe_store = () => ($$unsubscribe_store(), $$unsubscribe_store = subscribe(store, $$value => $$invalidate(2, $store = $$value)), store);

  	$$self.$$.on_destroy.push(() => $$unsubscribe_store());
  	let { config } = $$props;
  	let { store } = $$props;
  	validate_store(store, "store");
  	$$subscribe_store();
  	const { isAuthenticated, authToken } = getAuth();
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(11, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(12, $authToken = value));

  	const loadData = async cb => {
  		if (!$isAuthenticated) return;

  		config.get(
  			$authToken,
  			$store.filters,
  			all => {
  				store.setElements(all);
  				if (cb) cb();
  			},
  			err => console.log(err)
  		);
  	};

  	onMount(async () => {
  		loadData(() => {
  			selectElement($store.elements[0]);
  		});
  	});

  	const deleteElement = async () => {
  		config.delete(
  			$authToken,
  			$store.selectedElement.id,
  			() => {
  				loadData(() => {
  					if ($store.elements) {
  						store.setSelectedElement($store.elements[0]);
  					}
  				});
  			},
  			() => {
  				console.log("create error.");
  			}
  		);
  	};

  	const create = async () => {
  		config.create(
  			$authToken,
  			$store.selectedElement,
  			element => {
  				loadData();
  				selectElement(element);
  			},
  			() => {
  				console.log("create error.");
  			}
  		);
  	};

  	const selectElement = element => {
  		store.setSelectedElement(element, () => {
  			refreshUI();
  		});
  	};

  	const addFilter = filter => {
  		if (filter.includes(":")) {
  			let keyval = filter.split(":");
  			store.addFilter(keyval[0], keyval[1]);

  			loadData(() => {
  				selectElement($store.elements[0]);
  			});
  		}
  	};

  	const removeFilter = filter => {
  		if (filter.includes(":")) {
  			let keyval = filter.split(":");
  			store.removeFilter(keyval[0]);

  			loadData(() => {
  				selectElement($store.elements[0]);
  			});
  		}
  	};

  	const refreshUI = () => {
  		setTimeout(
  			function () {
  				let chips = document.querySelectorAll(".chips");
  				let filters = [];

  				// restore current filters
  				$store.filters.forEach(f => {
  					filters.push({ tag: f.key + ":" + f.val });
  				});

  				M.Chips.init(chips, {
  					data: filters,
  					onChipAdd: (ev, chip) => addFilter(chip.firstChild.nodeValue),
  					onChipDelete: (ev, chip) => removeFilter(chip.firstChild.nodeValue)
  				});

  				var elems = document.querySelectorAll("select");
  				M.FormSelect.init(elems, {});

  				if (config.refreshUI) {
  					config.refreshUI();
  				}
  			},
  			50
  		);
  	};

  	const update = () => {
  		config.update(
  			$authToken,
  			$store.selectedElement.id,
  			$store.selectedElement,
  			() => {
  				console.log("update successful.");
  				loadData();
  			},
  			() => {
  				console.log("update error.");
  			}
  		);
  	};

  	const toolbarConfig = {
  		title: config.title,
  		actions: [
  			{
  				name: null,
  				color: "",
  				icon: "filter_alt",
  				fnc: () => {
  					store.toggleFilter();
  					refreshUI();
  				}
  			},
  			{
  				name: null,
  				icon: "add",
  				color: "",
  				fnc: () => config.new(selectElement)
  			},
  			...config.actions
  		], // add extra ctions
  		
  	};

  	const writable_props = ["config", "store"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<CRUDEditorStore> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("CRUDEditorStore", $$slots, ['hero','content']);
  	const click_handler = () => create();
  	const click_handler_1 = () => update();
  	const click_handler_2 = () => deleteElement();

  	function input0_input_handler() {
  		$store.selectedElement.name = this.value;
  		store.set($store);
  	}

  	function input_input_handler() {
  		$store.selectedElement.id = this.value;
  		store.set($store);
  	}

  	function input_input_handler_1() {
  		$store.selectedElement.id = this.value;
  		store.set($store);
  	}

  	function input1_input_handler() {
  		$store.selectedElement.description = this.value;
  		store.set($store);
  	}

  	function input2_input_handler() {
  		$store.selectedElement.detail = this.value;
  		store.set($store);
  	}

  	$$self.$set = $$props => {
  		if ("config" in $$props) $$invalidate(0, config = $$props.config);
  		if ("store" in $$props) $$subscribe_store($$invalidate(1, store = $$props.store));
  		if ("$$scope" in $$props) $$invalidate(17, $$scope = $$props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		ActionEditor,
  		Toolbar,
  		createStore,
  		PlusIcon,
  		writable,
  		onMount,
  		createAuth,
  		getAuth,
  		config,
  		store,
  		isAuthenticated,
  		authToken,
  		loadData,
  		deleteElement,
  		create,
  		selectElement,
  		addFilter,
  		removeFilter,
  		refreshUI,
  		update,
  		toolbarConfig,
  		state,
  		$isAuthenticated,
  		$authToken,
  		$store
  	});

  	$$self.$inject_state = $$props => {
  		if ("config" in $$props) $$invalidate(0, config = $$props.config);
  		if ("store" in $$props) $$subscribe_store($$invalidate(1, store = $$props.store));
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isAuthenticated, $authToken*/ 6144) {
  			 state = {
  				isAuthenticated: $isAuthenticated,
  				authToken: $authToken.slice(0, 20)
  			};
  		}
  	};

  	return [
  		config,
  		store,
  		$store,
  		isAuthenticated,
  		authToken,
  		deleteElement,
  		create,
  		selectElement,
  		update,
  		toolbarConfig,
  		state,
  		$isAuthenticated,
  		$authToken,
  		loadData,
  		addFilter,
  		removeFilter,
  		refreshUI,
  		$$scope,
  		$$slots,
  		click_handler,
  		click_handler_1,
  		click_handler_2,
  		input0_input_handler,
  		input_input_handler,
  		input_input_handler_1,
  		input1_input_handler,
  		input2_input_handler
  	];
  }

  class CRUDEditorStore extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$n, create_fragment$n, safe_not_equal, { config: 0, store: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "CRUDEditorStore",
  			options,
  			id: create_fragment$n.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*config*/ ctx[0] === undefined && !("config" in props)) {
  			console_1$5.warn("<CRUDEditorStore> was created without expected prop 'config'");
  		}

  		if (/*store*/ ctx[1] === undefined && !("store" in props)) {
  			console_1$5.warn("<CRUDEditorStore> was created without expected prop 'store'");
  		}
  	}

  	get config() {
  		throw new Error("<CRUDEditorStore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set config(value) {
  		throw new Error("<CRUDEditorStore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get store() {
  		throw new Error("<CRUDEditorStore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set store(value) {
  		throw new Error("<CRUDEditorStore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
  // find the complete implementation of crypto (msCrypto) on IE11.
  var getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }

    return getRandomValues(rnds8);
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  var byteToHex = [];

  for (var i$2 = 0; i$2 < 256; ++i$2) {
    byteToHex.push((i$2 + 0x100).toString(16).substr(1));
  }

  function bytesToUuid(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex; // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

    return (bth[buf[i + 0]] + bth[buf[i + 1]] + bth[buf[i + 2]] + bth[buf[i + 3]] + '-' + bth[buf[i + 4]] + bth[buf[i + 5]] + '-' + bth[buf[i + 6]] + bth[buf[i + 7]] + '-' + bth[buf[i + 8]] + bth[buf[i + 9]] + '-' + bth[buf[i + 10]] + bth[buf[i + 11]] + bth[buf[i + 12]] + bth[buf[i + 13]] + bth[buf[i + 14]] + bth[buf[i + 15]]).toLowerCase();
  }

  function v4(options, buf, offset) {
    if (typeof options === 'string') {
      buf = options === 'binary' ? new Uint8Array(16) : null;
      options = null;
    }

    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      var start = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[start + i] = rnds[i];
      }

      return buf;
    }

    return bytesToUuid(rnds);
  }

  function getItem(token, id, cb, errorCb) {
    axios$1
      .get(`${backend}/items/${id}`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function deleteItem(token, id, cb, errorCb) {
    axios$1
      .delete(`${backend}/items/${id}`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function getItems(token, filters, cb, errorCb) {
    const path = `${backend}/items`;
    let filtered = path;
    if (filters) {
      filtered += "?";
      filters.forEach((f) => {
        filtered += f.key + "=" + f.val;
      });
    }

    axios$1
      .get(filtered, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }
  function updateItem(token, id, item, cb, errorCb) {
    axios$1
      .put(`${backend}/items/${id}`, item, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",

          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data))
      .catch((err) => errorCb(err));
  }
  function createItem(token, item, cb, errorCb) {
    axios$1
      .post(`${backend}/items`, item, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data))
      .catch((err) => errorCb(err));
  }

  function getItemSlots(cb, errorCb) {
    axios$1
      .get(`${backend}/item-slots`)
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function getItemQualities(cb, errorCb) {
    axios$1
      .get(`${backend}/item-qualities`)
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function getItemTypes(cb, errorCb) {
    axios$1
      .get(`${backend}/item-types`)
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function getItemSubTypes(cb, errorCb) {
    axios$1
      .get(`${backend}/item-subtypes`)
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function getItemTemplate(token, id, cb, errorCb) {
    axios$1
      .get(`${backend}/item-templates/${id}`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function deleteItemTemplate(token, id, cb, errorCb) {
    axios$1
      .delete(`${backend}/item-templates/${id}`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function getItemTemplates(token, filters, cb, errorCb) {
    const path = `${backend}/item-templates`;
    let filtered = path;
    if (filters) {
      filtered += "?";
      let i = 0;
      filters.forEach((f) => {
        if (i > 0) {
          filtered += "&";
        }
        filtered += f.key + "=" + f.val;
        i++;
      });
    }
    axios$1
      .get(filtered, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }
  function updateItemTemplate(token, id, ItemTemplate, cb, errorCb) {
    axios$1
      .put(`${backend}/item-templates/${id}`, ItemTemplate, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",

          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data))
      .catch((err) => errorCb(err));
  }
  function createItemTemplate(token, ItemTemplate, cb, errorCb) {
    axios$1
      .post(`${backend}/item-templates`, ItemTemplate, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data))
      .catch((err) => errorCb(err));
  }

  /* src/creator/ItemsEditor.svelte generated by Svelte v3.22.3 */

  const file$j = "src/creator/ItemsEditor.svelte";

  function get_each_context$4(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[19] = list[i];
  	return child_ctx;
  }

  function get_each_context_1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[22] = list[i];
  	return child_ctx;
  }

  function get_each_context_2(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[25] = list[i];
  	return child_ctx;
  }

  function get_each_context_3(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[28] = list[i];
  	return child_ctx;
  }

  function get_each_context_4(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[31] = list[i];
  	return child_ctx;
  }

  // (94:2) <span slot="hero" class="col s1 valign-wrapper">
  function create_hero_slot(ctx) {
  	let span;
  	let current;

  	const sprites = new Sprites({
  			props: { item: "weapon" },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			span = element("span");
  			create_component(sprites.$$.fragment);
  			attr_dev(span, "slot", "hero");
  			attr_dev(span, "class", "col s1 valign-wrapper");
  			add_location(span, file$j, 93, 2, 2121);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			mount_component(sprites, span, null);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(sprites.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(sprites.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  			destroy_component(sprites);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_hero_slot.name,
  		type: "slot",
  		source: "(94:2) <span slot=\\\"hero\\\" class=\\\"col s1 valign-wrapper\\\">",
  		ctx
  	});

  	return block;
  }

  // (103:10) {#each levels as lvl}
  function create_each_block_4(ctx) {
  	let option;
  	let t_value = /*lvl*/ ctx[31] + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*lvl*/ ctx[31];
  			option.value = option.__value;
  			add_location(option, file$j, 103, 12, 2423);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_4.name,
  		type: "each",
  		source: "(103:10) {#each levels as lvl}",
  		ctx
  	});

  	return block;
  }

  // (113:10) {#each itemTypes as type}
  function create_each_block_3(ctx) {
  	let option;
  	let t_value = /*type*/ ctx[28].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*type*/ ctx[28];
  			option.value = option.__value;
  			add_location(option, file$j, 113, 12, 2772);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemTypes*/ 2 && t_value !== (t_value = /*type*/ ctx[28].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemTypes*/ 2 && option_value_value !== (option_value_value = /*type*/ ctx[28])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_3.name,
  		type: "each",
  		source: "(113:10) {#each itemTypes as type}",
  		ctx
  	});

  	return block;
  }

  // (123:10) {#each itemSubTypes as subType}
  function create_each_block_2(ctx) {
  	let option;
  	let t_value = /*subType*/ ctx[25].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*subType*/ ctx[25];
  			option.value = option.__value;
  			add_location(option, file$j, 123, 12, 3150);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemSubTypes*/ 4 && t_value !== (t_value = /*subType*/ ctx[25].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemSubTypes*/ 4 && option_value_value !== (option_value_value = /*subType*/ ctx[25])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_2.name,
  		type: "each",
  		source: "(123:10) {#each itemSubTypes as subType}",
  		ctx
  	});

  	return block;
  }

  // (136:10) {#each itemQualities as quality}
  function create_each_block_1(ctx) {
  	let option;
  	let t_value = /*quality*/ ctx[22].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*quality*/ ctx[22];
  			option.value = option.__value;
  			add_location(option, file$j, 136, 12, 3582);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemQualities*/ 1 && t_value !== (t_value = /*quality*/ ctx[22].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemQualities*/ 1 && option_value_value !== (option_value_value = /*quality*/ ctx[22])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_1.name,
  		type: "each",
  		source: "(136:10) {#each itemQualities as quality}",
  		ctx
  	});

  	return block;
  }

  // (151:10) {#each itemSlots as slot}
  function create_each_block$4(ctx) {
  	let option;
  	let t_value = /*slot*/ ctx[19].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			attr_dev(option, "class", "select");
  			option.__value = option_value_value = /*slot*/ ctx[19];
  			option.value = option.__value;
  			add_location(option, file$j, 151, 12, 4017);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemSlots*/ 8 && t_value !== (t_value = /*slot*/ ctx[19].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemSlots*/ 8 && option_value_value !== (option_value_value = /*slot*/ ctx[19])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$4.name,
  		type: "each",
  		source: "(151:10) {#each itemSlots as slot}",
  		ctx
  	});

  	return block;
  }

  // (98:2) <div slot="content">
  function create_content_slot(ctx) {
  	let div0;
  	let div4;
  	let div1;
  	let select0;
  	let t0;
  	let label0;
  	let t2;
  	let div2;
  	let select1;
  	let option0;
  	let t4;
  	let label1;
  	let t6;
  	let div3;
  	let select2;
  	let option1;
  	let t8;
  	let label2;
  	let t10;
  	let div7;
  	let div5;
  	let select3;
  	let option2;
  	let t12;
  	let label3;
  	let t14;
  	let div6;
  	let select4;
  	let option3;
  	let t16;
  	let label4;
  	let dispose;
  	let each_value_4 = /*levels*/ ctx[7];
  	validate_each_argument(each_value_4);
  	let each_blocks_4 = [];

  	for (let i = 0; i < each_value_4.length; i += 1) {
  		each_blocks_4[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  	}

  	let each_value_3 = /*itemTypes*/ ctx[1];
  	validate_each_argument(each_value_3);
  	let each_blocks_3 = [];

  	for (let i = 0; i < each_value_3.length; i += 1) {
  		each_blocks_3[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  	}

  	let each_value_2 = /*itemSubTypes*/ ctx[2];
  	validate_each_argument(each_value_2);
  	let each_blocks_2 = [];

  	for (let i = 0; i < each_value_2.length; i += 1) {
  		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  	}

  	let each_value_1 = /*itemQualities*/ ctx[0];
  	validate_each_argument(each_value_1);
  	let each_blocks_1 = [];

  	for (let i = 0; i < each_value_1.length; i += 1) {
  		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  	}

  	let each_value = /*itemSlots*/ ctx[3];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			div0 = element("div");
  			div4 = element("div");
  			div1 = element("div");
  			select0 = element("select");

  			for (let i = 0; i < each_blocks_4.length; i += 1) {
  				each_blocks_4[i].c();
  			}

  			t0 = space();
  			label0 = element("label");
  			label0.textContent = "Level";
  			t2 = space();
  			div2 = element("div");
  			select1 = element("select");
  			option0 = element("option");
  			option0.textContent = "Item Type";

  			for (let i = 0; i < each_blocks_3.length; i += 1) {
  				each_blocks_3[i].c();
  			}

  			t4 = space();
  			label1 = element("label");
  			label1.textContent = "Select Item Type";
  			t6 = space();
  			div3 = element("div");
  			select2 = element("select");
  			option1 = element("option");
  			option1.textContent = "Item Subtype";

  			for (let i = 0; i < each_blocks_2.length; i += 1) {
  				each_blocks_2[i].c();
  			}

  			t8 = space();
  			label2 = element("label");
  			label2.textContent = "Select Item Sub Type";
  			t10 = space();
  			div7 = element("div");
  			div5 = element("div");
  			select3 = element("select");
  			option2 = element("option");
  			option2.textContent = "Item Quality";

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].c();
  			}

  			t12 = space();
  			label3 = element("label");
  			label3.textContent = "Select Item Quality";
  			t14 = space();
  			div6 = element("div");
  			select4 = element("select");
  			option3 = element("option");
  			option3.textContent = "Item Slot";

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			t16 = space();
  			label4 = element("label");
  			label4.textContent = "Select Item Slot";
  			if (/*$store*/ ctx[4].selectedElement.level === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[14].call(select0));
  			add_location(select0, file$j, 101, 8, 2316);
  			add_location(label0, file$j, 106, 8, 2504);
  			attr_dev(div1, "class", "margininput input-field col s1");
  			add_location(div1, file$j, 100, 6, 2263);
  			option0.__value = "";
  			option0.value = option0.__value;
  			option0.disabled = true;
  			option0.selected = true;
  			add_location(option0, file$j, 111, 10, 2670);
  			if (/*$store*/ ctx[4].selectedElement.type === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[15].call(select1));
  			add_location(select1, file$j, 110, 8, 2598);
  			add_location(label1, file$j, 116, 8, 2868);
  			attr_dev(div2, "class", "margininput input-field col s5");
  			add_location(div2, file$j, 109, 6, 2545);
  			option1.__value = "";
  			option1.value = option1.__value;
  			option1.selected = true;
  			add_location(option1, file$j, 121, 10, 3048);
  			if (/*$store*/ ctx[4].selectedElement.subType === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[16].call(select2));
  			add_location(select2, file$j, 120, 8, 2973);
  			add_location(label2, file$j, 126, 8, 3252);
  			attr_dev(div3, "class", "margininput input-field col s5");
  			add_location(div3, file$j, 119, 6, 2920);
  			attr_dev(div4, "class", "row");
  			add_location(div4, file$j, 98, 4, 2238);
  			option2.__value = "";
  			option2.value = option2.__value;
  			option2.disabled = true;
  			option2.selected = true;
  			add_location(option2, file$j, 134, 10, 3470);
  			if (/*$store*/ ctx[4].selectedElement.quality === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[17].call(select3));
  			add_location(select3, file$j, 133, 8, 3395);
  			add_location(label3, file$j, 140, 8, 3685);
  			attr_dev(div5, "class", "margininput input-field col s5");
  			add_location(div5, file$j, 132, 6, 3342);
  			option3.__value = "";
  			option3.value = option3.__value;
  			option3.selected = true;
  			add_location(option3, file$j, 149, 10, 3924);
  			attr_dev(select4, "class", "margininput");
  			if (/*$store*/ ctx[4].selectedElement.slot === void 0) add_render_callback(() => /*select4_change_handler*/ ctx[18].call(select4));
  			add_location(select4, file$j, 144, 8, 3793);
  			add_location(label4, file$j, 154, 8, 4128);
  			attr_dev(div6, "class", "margininput input-field col s5");
  			add_location(div6, file$j, 143, 6, 3740);
  			attr_dev(div7, "class", "row");
  			add_location(div7, file$j, 130, 4, 3317);
  			attr_dev(div0, "slot", "content");
  			add_location(div0, file$j, 97, 2, 2213);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div0, anchor);
  			append_dev(div0, div4);
  			append_dev(div4, div1);
  			append_dev(div1, select0);

  			for (let i = 0; i < each_blocks_4.length; i += 1) {
  				each_blocks_4[i].m(select0, null);
  			}

  			select_option(select0, /*$store*/ ctx[4].selectedElement.level);
  			append_dev(div1, t0);
  			append_dev(div1, label0);
  			append_dev(div4, t2);
  			append_dev(div4, div2);
  			append_dev(div2, select1);
  			append_dev(select1, option0);

  			for (let i = 0; i < each_blocks_3.length; i += 1) {
  				each_blocks_3[i].m(select1, null);
  			}

  			select_option(select1, /*$store*/ ctx[4].selectedElement.type);
  			append_dev(div2, t4);
  			append_dev(div2, label1);
  			append_dev(div4, t6);
  			append_dev(div4, div3);
  			append_dev(div3, select2);
  			append_dev(select2, option1);

  			for (let i = 0; i < each_blocks_2.length; i += 1) {
  				each_blocks_2[i].m(select2, null);
  			}

  			select_option(select2, /*$store*/ ctx[4].selectedElement.subType);
  			append_dev(div3, t8);
  			append_dev(div3, label2);
  			append_dev(div0, t10);
  			append_dev(div0, div7);
  			append_dev(div7, div5);
  			append_dev(div5, select3);
  			append_dev(select3, option2);

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].m(select3, null);
  			}

  			select_option(select3, /*$store*/ ctx[4].selectedElement.quality);
  			append_dev(div5, t12);
  			append_dev(div5, label3);
  			append_dev(div7, t14);
  			append_dev(div7, div6);
  			append_dev(div6, select4);
  			append_dev(select4, option3);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(select4, null);
  			}

  			select_option(select4, /*$store*/ ctx[4].selectedElement.slot);
  			append_dev(div6, t16);
  			append_dev(div6, label4);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(select0, "change", /*select0_change_handler*/ ctx[14]),
  				listen_dev(select0, "change", /*change_handler*/ ctx[13], false, false, false),
  				listen_dev(select1, "change", /*select1_change_handler*/ ctx[15]),
  				listen_dev(select1, "change", /*change_handler_1*/ ctx[12], false, false, false),
  				listen_dev(select2, "change", /*select2_change_handler*/ ctx[16]),
  				listen_dev(select2, "change", /*change_handler_2*/ ctx[11], false, false, false),
  				listen_dev(select3, "change", /*select3_change_handler*/ ctx[17]),
  				listen_dev(select3, "change", /*change_handler_3*/ ctx[10], false, false, false),
  				listen_dev(select4, "change", /*select4_change_handler*/ ctx[18]),
  				listen_dev(select4, "change", /*change_handler_4*/ ctx[9], false, false, false)
  			];
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*levels*/ 128) {
  				each_value_4 = /*levels*/ ctx[7];
  				validate_each_argument(each_value_4);
  				let i;

  				for (i = 0; i < each_value_4.length; i += 1) {
  					const child_ctx = get_each_context_4(ctx, each_value_4, i);

  					if (each_blocks_4[i]) {
  						each_blocks_4[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_4[i] = create_each_block_4(child_ctx);
  						each_blocks_4[i].c();
  						each_blocks_4[i].m(select0, null);
  					}
  				}

  				for (; i < each_blocks_4.length; i += 1) {
  					each_blocks_4[i].d(1);
  				}

  				each_blocks_4.length = each_value_4.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select0, /*$store*/ ctx[4].selectedElement.level);
  			}

  			if (dirty[0] & /*itemTypes*/ 2) {
  				each_value_3 = /*itemTypes*/ ctx[1];
  				validate_each_argument(each_value_3);
  				let i;

  				for (i = 0; i < each_value_3.length; i += 1) {
  					const child_ctx = get_each_context_3(ctx, each_value_3, i);

  					if (each_blocks_3[i]) {
  						each_blocks_3[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_3[i] = create_each_block_3(child_ctx);
  						each_blocks_3[i].c();
  						each_blocks_3[i].m(select1, null);
  					}
  				}

  				for (; i < each_blocks_3.length; i += 1) {
  					each_blocks_3[i].d(1);
  				}

  				each_blocks_3.length = each_value_3.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select1, /*$store*/ ctx[4].selectedElement.type);
  			}

  			if (dirty[0] & /*itemSubTypes*/ 4) {
  				each_value_2 = /*itemSubTypes*/ ctx[2];
  				validate_each_argument(each_value_2);
  				let i;

  				for (i = 0; i < each_value_2.length; i += 1) {
  					const child_ctx = get_each_context_2(ctx, each_value_2, i);

  					if (each_blocks_2[i]) {
  						each_blocks_2[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_2[i] = create_each_block_2(child_ctx);
  						each_blocks_2[i].c();
  						each_blocks_2[i].m(select2, null);
  					}
  				}

  				for (; i < each_blocks_2.length; i += 1) {
  					each_blocks_2[i].d(1);
  				}

  				each_blocks_2.length = each_value_2.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select2, /*$store*/ ctx[4].selectedElement.subType);
  			}

  			if (dirty[0] & /*itemQualities*/ 1) {
  				each_value_1 = /*itemQualities*/ ctx[0];
  				validate_each_argument(each_value_1);
  				let i;

  				for (i = 0; i < each_value_1.length; i += 1) {
  					const child_ctx = get_each_context_1(ctx, each_value_1, i);

  					if (each_blocks_1[i]) {
  						each_blocks_1[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_1[i] = create_each_block_1(child_ctx);
  						each_blocks_1[i].c();
  						each_blocks_1[i].m(select3, null);
  					}
  				}

  				for (; i < each_blocks_1.length; i += 1) {
  					each_blocks_1[i].d(1);
  				}

  				each_blocks_1.length = each_value_1.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select3, /*$store*/ ctx[4].selectedElement.quality);
  			}

  			if (dirty[0] & /*itemSlots*/ 8) {
  				each_value = /*itemSlots*/ ctx[3];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$4(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block$4(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(select4, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select4, /*$store*/ ctx[4].selectedElement.slot);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div0);
  			destroy_each(each_blocks_4, detaching);
  			destroy_each(each_blocks_3, detaching);
  			destroy_each(each_blocks_2, detaching);
  			destroy_each(each_blocks_1, detaching);
  			destroy_each(each_blocks, detaching);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_content_slot.name,
  		type: "slot",
  		source: "(98:2) <div slot=\\\"content\\\">",
  		ctx
  	});

  	return block;
  }

  // (92:0) <CRUDEditorStore store="{store}" config="{config}">
  function create_default_slot$2(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = space();
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: noop,
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$2.name,
  		type: "slot",
  		source: "(92:0) <CRUDEditorStore store=\\\"{store}\\\" config=\\\"{config}\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$o(ctx) {
  	let current;

  	const crudeditorstore = new CRUDEditorStore({
  			props: {
  				store: /*store*/ ctx[6],
  				config: /*config*/ ctx[5],
  				$$slots: {
  					default: [create_default_slot$2],
  					content: [create_content_slot],
  					hero: [create_hero_slot]
  				},
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(crudeditorstore.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(crudeditorstore, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const crudeditorstore_changes = {};

  			if (dirty[0] & /*$store, itemSlots, itemQualities, itemSubTypes, itemTypes*/ 31 | dirty[1] & /*$$scope*/ 8) {
  				crudeditorstore_changes.$$scope = { dirty, ctx };
  			}

  			crudeditorstore.$set(crudeditorstore_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(crudeditorstore.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(crudeditorstore.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(crudeditorstore, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$o.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$o($$self, $$props, $$invalidate) {
  	let $store;

  	const config = {
  		title: "Manage Items",
  		actions: [],
  		get: getItems,
  		getElement: getItem,
  		create: createItem,
  		update: updateItem,
  		delete: deleteItem,
  		refreshUI: () => {
  			var elems = document.querySelectorAll("select");
  			var instances = M.FormSelect.init(elems, {});

  			// second time to fix the selects
  			setTimeout(
  				function () {
  					var elems = document.querySelectorAll("select");
  					var instances = M.FormSelect.init(elems, {});
  				},
  				50
  			);
  		},
  		new: select => {
  			select({
  				id: v4(),
  				name: "Unnamed Item",
  				description: "",
  				detail: "",
  				type: "",
  				slot: "inventory",
  				quality: "normal",
  				level: 1,
  				properties: new Map(),
  				attributes: new Map(),
  				noPickup: false,
  				tags: [],
  				isNew: true
  			});
  		},
  		badge: element => {
  			return element.quality + " " + element.subType;
  		}
  	};

  	// create store outside of the component to use it in the slot..
  	const store = createStore();

  	validate_store(store, "store");
  	component_subscribe($$self, store, value => $$invalidate(4, $store = value));

  	///////// ADDITIONAL DATA
  	// additional data
  	let itemQualities = [];

  	let itemTypes = [];
  	let itemSubTypes = [];
  	let itemSlots = [];

  	// create level array
  	var levels = [];

  	for (var i = 1; i <= 50; i++) {
  		levels.push(i);
  	}

  	onMount(async () => {
  		getItemQualities(q => $$invalidate(0, itemQualities = q));
  		getItemTypes(t => $$invalidate(1, itemTypes = t));
  		getItemSubTypes(st => $$invalidate(2, itemSubTypes = st));
  		getItemSlots(s => $$invalidate(3, itemSlots = s));
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ItemsEditor> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("ItemsEditor", $$slots, []);

  	function change_handler_4(event) {
  		bubble($$self, event);
  	}

  	function change_handler_3(event) {
  		bubble($$self, event);
  	}

  	function change_handler_2(event) {
  		bubble($$self, event);
  	}

  	function change_handler_1(event) {
  		bubble($$self, event);
  	}

  	function change_handler(event) {
  		bubble($$self, event);
  	}

  	function select0_change_handler() {
  		$store.selectedElement.level = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select1_change_handler() {
  		$store.selectedElement.type = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select2_change_handler() {
  		$store.selectedElement.subType = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select3_change_handler() {
  		$store.selectedElement.quality = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select4_change_handler() {
  		$store.selectedElement.slot = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	$$self.$capture_state = () => ({
  		Sprites,
  		onMount,
  		CRUDEditorStore,
  		createStore,
  		uuidv4: v4,
  		getItem,
  		getItems,
  		createItem,
  		updateItem,
  		deleteItem,
  		getItemQualities,
  		getItemTypes,
  		getItemSubTypes,
  		getItemSlots,
  		config,
  		store,
  		itemQualities,
  		itemTypes,
  		itemSubTypes,
  		itemSlots,
  		levels,
  		i,
  		$store
  	});

  	$$self.$inject_state = $$props => {
  		if ("itemQualities" in $$props) $$invalidate(0, itemQualities = $$props.itemQualities);
  		if ("itemTypes" in $$props) $$invalidate(1, itemTypes = $$props.itemTypes);
  		if ("itemSubTypes" in $$props) $$invalidate(2, itemSubTypes = $$props.itemSubTypes);
  		if ("itemSlots" in $$props) $$invalidate(3, itemSlots = $$props.itemSlots);
  		if ("levels" in $$props) $$invalidate(7, levels = $$props.levels);
  		if ("i" in $$props) i = $$props.i;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		itemQualities,
  		itemTypes,
  		itemSubTypes,
  		itemSlots,
  		$store,
  		config,
  		store,
  		levels,
  		i,
  		change_handler_4,
  		change_handler_3,
  		change_handler_2,
  		change_handler_1,
  		change_handler,
  		select0_change_handler,
  		select1_change_handler,
  		select2_change_handler,
  		select3_change_handler,
  		select4_change_handler
  	];
  }

  class ItemsEditor extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$o, create_fragment$o, safe_not_equal, {}, [-1, -1]);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "ItemsEditor",
  			options,
  			id: create_fragment$o.name
  		});
  	}
  }

  /* src/creator/SampleEditor.svelte generated by Svelte v3.22.3 */

  const { console: console_1$6 } = globals;

  const file$k = "src/creator/SampleEditor.svelte";

  function get_each_context$5(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[19] = list[i];
  	return child_ctx;
  }

  function get_each_context_1$1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[22] = list[i];
  	return child_ctx;
  }

  function get_each_context_2$1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[25] = list[i];
  	return child_ctx;
  }

  function get_each_context_3$1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[28] = list[i];
  	return child_ctx;
  }

  function get_each_context_4$1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[31] = list[i];
  	return child_ctx;
  }

  // (102:2) <span slot="hero" class="col s1 valign-wrapper">
  function create_hero_slot$1(ctx) {
  	let span;
  	let current;

  	const sprites = new Sprites({
  			props: { item: "weapon" },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			span = element("span");
  			create_component(sprites.$$.fragment);
  			attr_dev(span, "slot", "hero");
  			attr_dev(span, "class", "col s1 valign-wrapper");
  			add_location(span, file$k, 101, 2, 2406);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			mount_component(sprites, span, null);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(sprites.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(sprites.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  			destroy_component(sprites);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_hero_slot$1.name,
  		type: "slot",
  		source: "(102:2) <span slot=\\\"hero\\\" class=\\\"col s1 valign-wrapper\\\">",
  		ctx
  	});

  	return block;
  }

  // (111:10) {#each levels as lvl}
  function create_each_block_4$1(ctx) {
  	let option;
  	let t_value = /*lvl*/ ctx[31] + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*lvl*/ ctx[31];
  			option.value = option.__value;
  			add_location(option, file$k, 111, 12, 2708);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_4$1.name,
  		type: "each",
  		source: "(111:10) {#each levels as lvl}",
  		ctx
  	});

  	return block;
  }

  // (121:10) {#each itemTypes as type}
  function create_each_block_3$1(ctx) {
  	let option;
  	let t_value = /*type*/ ctx[28].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*type*/ ctx[28];
  			option.value = option.__value;
  			add_location(option, file$k, 121, 12, 3057);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemTypes*/ 2 && t_value !== (t_value = /*type*/ ctx[28].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemTypes*/ 2 && option_value_value !== (option_value_value = /*type*/ ctx[28])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_3$1.name,
  		type: "each",
  		source: "(121:10) {#each itemTypes as type}",
  		ctx
  	});

  	return block;
  }

  // (131:10) {#each itemSubTypes as subType}
  function create_each_block_2$1(ctx) {
  	let option;
  	let t_value = /*subType*/ ctx[25].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*subType*/ ctx[25];
  			option.value = option.__value;
  			add_location(option, file$k, 131, 12, 3435);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemSubTypes*/ 4 && t_value !== (t_value = /*subType*/ ctx[25].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemSubTypes*/ 4 && option_value_value !== (option_value_value = /*subType*/ ctx[25])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_2$1.name,
  		type: "each",
  		source: "(131:10) {#each itemSubTypes as subType}",
  		ctx
  	});

  	return block;
  }

  // (144:10) {#each itemQualities as quality}
  function create_each_block_1$1(ctx) {
  	let option;
  	let t_value = /*quality*/ ctx[22].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*quality*/ ctx[22];
  			option.value = option.__value;
  			add_location(option, file$k, 144, 12, 3867);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemQualities*/ 1 && t_value !== (t_value = /*quality*/ ctx[22].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemQualities*/ 1 && option_value_value !== (option_value_value = /*quality*/ ctx[22])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_1$1.name,
  		type: "each",
  		source: "(144:10) {#each itemQualities as quality}",
  		ctx
  	});

  	return block;
  }

  // (159:10) {#each itemSlots as slot}
  function create_each_block$5(ctx) {
  	let option;
  	let t_value = /*slot*/ ctx[19].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			attr_dev(option, "class", "select");
  			option.__value = option_value_value = /*slot*/ ctx[19];
  			option.value = option.__value;
  			add_location(option, file$k, 159, 12, 4302);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemSlots*/ 8 && t_value !== (t_value = /*slot*/ ctx[19].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemSlots*/ 8 && option_value_value !== (option_value_value = /*slot*/ ctx[19])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$5.name,
  		type: "each",
  		source: "(159:10) {#each itemSlots as slot}",
  		ctx
  	});

  	return block;
  }

  // (106:2) <div slot="content">
  function create_content_slot$1(ctx) {
  	let div0;
  	let div4;
  	let div1;
  	let select0;
  	let t0;
  	let label0;
  	let t2;
  	let div2;
  	let select1;
  	let option0;
  	let t4;
  	let label1;
  	let t6;
  	let div3;
  	let select2;
  	let option1;
  	let t8;
  	let label2;
  	let t10;
  	let div7;
  	let div5;
  	let select3;
  	let option2;
  	let t12;
  	let label3;
  	let t14;
  	let div6;
  	let select4;
  	let option3;
  	let t16;
  	let label4;
  	let dispose;
  	let each_value_4 = /*levels*/ ctx[7];
  	validate_each_argument(each_value_4);
  	let each_blocks_4 = [];

  	for (let i = 0; i < each_value_4.length; i += 1) {
  		each_blocks_4[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
  	}

  	let each_value_3 = /*itemTypes*/ ctx[1];
  	validate_each_argument(each_value_3);
  	let each_blocks_3 = [];

  	for (let i = 0; i < each_value_3.length; i += 1) {
  		each_blocks_3[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
  	}

  	let each_value_2 = /*itemSubTypes*/ ctx[2];
  	validate_each_argument(each_value_2);
  	let each_blocks_2 = [];

  	for (let i = 0; i < each_value_2.length; i += 1) {
  		each_blocks_2[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
  	}

  	let each_value_1 = /*itemQualities*/ ctx[0];
  	validate_each_argument(each_value_1);
  	let each_blocks_1 = [];

  	for (let i = 0; i < each_value_1.length; i += 1) {
  		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  	}

  	let each_value = /*itemSlots*/ ctx[3];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			div0 = element("div");
  			div4 = element("div");
  			div1 = element("div");
  			select0 = element("select");

  			for (let i = 0; i < each_blocks_4.length; i += 1) {
  				each_blocks_4[i].c();
  			}

  			t0 = space();
  			label0 = element("label");
  			label0.textContent = "Level";
  			t2 = space();
  			div2 = element("div");
  			select1 = element("select");
  			option0 = element("option");
  			option0.textContent = "Item Type";

  			for (let i = 0; i < each_blocks_3.length; i += 1) {
  				each_blocks_3[i].c();
  			}

  			t4 = space();
  			label1 = element("label");
  			label1.textContent = "Select Item Type";
  			t6 = space();
  			div3 = element("div");
  			select2 = element("select");
  			option1 = element("option");
  			option1.textContent = "Item Subtype";

  			for (let i = 0; i < each_blocks_2.length; i += 1) {
  				each_blocks_2[i].c();
  			}

  			t8 = space();
  			label2 = element("label");
  			label2.textContent = "Select Item Sub Type";
  			t10 = space();
  			div7 = element("div");
  			div5 = element("div");
  			select3 = element("select");
  			option2 = element("option");
  			option2.textContent = "Item Quality";

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].c();
  			}

  			t12 = space();
  			label3 = element("label");
  			label3.textContent = "Select Item Quality";
  			t14 = space();
  			div6 = element("div");
  			select4 = element("select");
  			option3 = element("option");
  			option3.textContent = "Item Slot";

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			t16 = space();
  			label4 = element("label");
  			label4.textContent = "Select Item Slot";
  			if (/*$store*/ ctx[4].selectedElement.level === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[14].call(select0));
  			add_location(select0, file$k, 109, 8, 2601);
  			add_location(label0, file$k, 114, 8, 2789);
  			attr_dev(div1, "class", "margininput input-field col s1");
  			add_location(div1, file$k, 108, 6, 2548);
  			option0.__value = "";
  			option0.value = option0.__value;
  			option0.disabled = true;
  			option0.selected = true;
  			add_location(option0, file$k, 119, 10, 2955);
  			if (/*$store*/ ctx[4].selectedElement.type === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[15].call(select1));
  			add_location(select1, file$k, 118, 8, 2883);
  			add_location(label1, file$k, 124, 8, 3153);
  			attr_dev(div2, "class", "margininput input-field col s5");
  			add_location(div2, file$k, 117, 6, 2830);
  			option1.__value = "";
  			option1.value = option1.__value;
  			option1.selected = true;
  			add_location(option1, file$k, 129, 10, 3333);
  			if (/*$store*/ ctx[4].selectedElement.subType === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[16].call(select2));
  			add_location(select2, file$k, 128, 8, 3258);
  			add_location(label2, file$k, 134, 8, 3537);
  			attr_dev(div3, "class", "margininput input-field col s5");
  			add_location(div3, file$k, 127, 6, 3205);
  			attr_dev(div4, "class", "row");
  			add_location(div4, file$k, 106, 4, 2523);
  			option2.__value = "";
  			option2.value = option2.__value;
  			option2.disabled = true;
  			option2.selected = true;
  			add_location(option2, file$k, 142, 10, 3755);
  			if (/*$store*/ ctx[4].selectedElement.quality === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[17].call(select3));
  			add_location(select3, file$k, 141, 8, 3680);
  			add_location(label3, file$k, 148, 8, 3970);
  			attr_dev(div5, "class", "margininput input-field col s5");
  			add_location(div5, file$k, 140, 6, 3627);
  			option3.__value = "";
  			option3.value = option3.__value;
  			option3.selected = true;
  			add_location(option3, file$k, 157, 10, 4209);
  			attr_dev(select4, "class", "margininput");
  			if (/*$store*/ ctx[4].selectedElement.slot === void 0) add_render_callback(() => /*select4_change_handler*/ ctx[18].call(select4));
  			add_location(select4, file$k, 152, 8, 4078);
  			add_location(label4, file$k, 162, 8, 4413);
  			attr_dev(div6, "class", "margininput input-field col s5");
  			add_location(div6, file$k, 151, 6, 4025);
  			attr_dev(div7, "class", "row");
  			add_location(div7, file$k, 138, 4, 3602);
  			attr_dev(div0, "slot", "content");
  			add_location(div0, file$k, 105, 2, 2498);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div0, anchor);
  			append_dev(div0, div4);
  			append_dev(div4, div1);
  			append_dev(div1, select0);

  			for (let i = 0; i < each_blocks_4.length; i += 1) {
  				each_blocks_4[i].m(select0, null);
  			}

  			select_option(select0, /*$store*/ ctx[4].selectedElement.level);
  			append_dev(div1, t0);
  			append_dev(div1, label0);
  			append_dev(div4, t2);
  			append_dev(div4, div2);
  			append_dev(div2, select1);
  			append_dev(select1, option0);

  			for (let i = 0; i < each_blocks_3.length; i += 1) {
  				each_blocks_3[i].m(select1, null);
  			}

  			select_option(select1, /*$store*/ ctx[4].selectedElement.type);
  			append_dev(div2, t4);
  			append_dev(div2, label1);
  			append_dev(div4, t6);
  			append_dev(div4, div3);
  			append_dev(div3, select2);
  			append_dev(select2, option1);

  			for (let i = 0; i < each_blocks_2.length; i += 1) {
  				each_blocks_2[i].m(select2, null);
  			}

  			select_option(select2, /*$store*/ ctx[4].selectedElement.subType);
  			append_dev(div3, t8);
  			append_dev(div3, label2);
  			append_dev(div0, t10);
  			append_dev(div0, div7);
  			append_dev(div7, div5);
  			append_dev(div5, select3);
  			append_dev(select3, option2);

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].m(select3, null);
  			}

  			select_option(select3, /*$store*/ ctx[4].selectedElement.quality);
  			append_dev(div5, t12);
  			append_dev(div5, label3);
  			append_dev(div7, t14);
  			append_dev(div7, div6);
  			append_dev(div6, select4);
  			append_dev(select4, option3);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(select4, null);
  			}

  			select_option(select4, /*$store*/ ctx[4].selectedElement.slot);
  			append_dev(div6, t16);
  			append_dev(div6, label4);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(select0, "change", /*select0_change_handler*/ ctx[14]),
  				listen_dev(select0, "change", /*change_handler*/ ctx[13], false, false, false),
  				listen_dev(select1, "change", /*select1_change_handler*/ ctx[15]),
  				listen_dev(select1, "change", /*change_handler_1*/ ctx[12], false, false, false),
  				listen_dev(select2, "change", /*select2_change_handler*/ ctx[16]),
  				listen_dev(select2, "change", /*change_handler_2*/ ctx[11], false, false, false),
  				listen_dev(select3, "change", /*select3_change_handler*/ ctx[17]),
  				listen_dev(select3, "change", /*change_handler_3*/ ctx[10], false, false, false),
  				listen_dev(select4, "change", /*select4_change_handler*/ ctx[18]),
  				listen_dev(select4, "change", /*change_handler_4*/ ctx[9], false, false, false)
  			];
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*levels*/ 128) {
  				each_value_4 = /*levels*/ ctx[7];
  				validate_each_argument(each_value_4);
  				let i;

  				for (i = 0; i < each_value_4.length; i += 1) {
  					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

  					if (each_blocks_4[i]) {
  						each_blocks_4[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_4[i] = create_each_block_4$1(child_ctx);
  						each_blocks_4[i].c();
  						each_blocks_4[i].m(select0, null);
  					}
  				}

  				for (; i < each_blocks_4.length; i += 1) {
  					each_blocks_4[i].d(1);
  				}

  				each_blocks_4.length = each_value_4.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select0, /*$store*/ ctx[4].selectedElement.level);
  			}

  			if (dirty[0] & /*itemTypes*/ 2) {
  				each_value_3 = /*itemTypes*/ ctx[1];
  				validate_each_argument(each_value_3);
  				let i;

  				for (i = 0; i < each_value_3.length; i += 1) {
  					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

  					if (each_blocks_3[i]) {
  						each_blocks_3[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_3[i] = create_each_block_3$1(child_ctx);
  						each_blocks_3[i].c();
  						each_blocks_3[i].m(select1, null);
  					}
  				}

  				for (; i < each_blocks_3.length; i += 1) {
  					each_blocks_3[i].d(1);
  				}

  				each_blocks_3.length = each_value_3.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select1, /*$store*/ ctx[4].selectedElement.type);
  			}

  			if (dirty[0] & /*itemSubTypes*/ 4) {
  				each_value_2 = /*itemSubTypes*/ ctx[2];
  				validate_each_argument(each_value_2);
  				let i;

  				for (i = 0; i < each_value_2.length; i += 1) {
  					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

  					if (each_blocks_2[i]) {
  						each_blocks_2[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_2[i] = create_each_block_2$1(child_ctx);
  						each_blocks_2[i].c();
  						each_blocks_2[i].m(select2, null);
  					}
  				}

  				for (; i < each_blocks_2.length; i += 1) {
  					each_blocks_2[i].d(1);
  				}

  				each_blocks_2.length = each_value_2.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select2, /*$store*/ ctx[4].selectedElement.subType);
  			}

  			if (dirty[0] & /*itemQualities*/ 1) {
  				each_value_1 = /*itemQualities*/ ctx[0];
  				validate_each_argument(each_value_1);
  				let i;

  				for (i = 0; i < each_value_1.length; i += 1) {
  					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

  					if (each_blocks_1[i]) {
  						each_blocks_1[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_1[i] = create_each_block_1$1(child_ctx);
  						each_blocks_1[i].c();
  						each_blocks_1[i].m(select3, null);
  					}
  				}

  				for (; i < each_blocks_1.length; i += 1) {
  					each_blocks_1[i].d(1);
  				}

  				each_blocks_1.length = each_value_1.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select3, /*$store*/ ctx[4].selectedElement.quality);
  			}

  			if (dirty[0] & /*itemSlots*/ 8) {
  				each_value = /*itemSlots*/ ctx[3];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$5(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block$5(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(select4, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select4, /*$store*/ ctx[4].selectedElement.slot);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div0);
  			destroy_each(each_blocks_4, detaching);
  			destroy_each(each_blocks_3, detaching);
  			destroy_each(each_blocks_2, detaching);
  			destroy_each(each_blocks_1, detaching);
  			destroy_each(each_blocks, detaching);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_content_slot$1.name,
  		type: "slot",
  		source: "(106:2) <div slot=\\\"content\\\">",
  		ctx
  	});

  	return block;
  }

  // (100:0) <CRUDEditorStore store="{store}" config="{config}">
  function create_default_slot$3(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = space();
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: noop,
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$3.name,
  		type: "slot",
  		source: "(100:0) <CRUDEditorStore store=\\\"{store}\\\" config=\\\"{config}\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$p(ctx) {
  	let current;

  	const crudeditorstore = new CRUDEditorStore({
  			props: {
  				store: /*store*/ ctx[6],
  				config: /*config*/ ctx[5],
  				$$slots: {
  					default: [create_default_slot$3],
  					content: [create_content_slot$1],
  					hero: [create_hero_slot$1]
  				},
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(crudeditorstore.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(crudeditorstore, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const crudeditorstore_changes = {};

  			if (dirty[0] & /*$store, itemSlots, itemQualities, itemSubTypes, itemTypes*/ 31 | dirty[1] & /*$$scope*/ 8) {
  				crudeditorstore_changes.$$scope = { dirty, ctx };
  			}

  			crudeditorstore.$set(crudeditorstore_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(crudeditorstore.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(crudeditorstore.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(crudeditorstore, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$p.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$p($$self, $$props, $$invalidate) {
  	let $store;

  	const config = {
  		title: "Manage Item Templates",
  		actions: [
  			{
  				icon: "add",
  				name: "Item from Template",
  				color: "",
  				fnc: () => {
  					console.log("Create new template for id " + $store.selectedElement.id);
  				}
  			}
  		],
  		get: getItemTemplates,
  		getElement: getItemTemplate,
  		create: createItemTemplate,
  		update: updateItemTemplate,
  		delete: deleteItemTemplate,
  		refreshUI: () => {
  			var elems = document.querySelectorAll("select");
  			var instances = M.FormSelect.init(elems, {});

  			// second time to fix the selects
  			setTimeout(
  				function () {
  					var elems = document.querySelectorAll("select");
  					var instances = M.FormSelect.init(elems, {});
  				},
  				50
  			);
  		},
  		new: select => {
  			select({
  				id: v4(),
  				name: "Unnamed Item",
  				description: "",
  				detail: "",
  				type: "",
  				slot: "inventory",
  				quality: "normal",
  				level: 1,
  				properties: new Map(),
  				attributes: new Map(),
  				noPickup: false,
  				tags: [],
  				isNew: true
  			});
  		},
  		badge: element => {
  			return element.quality + " " + element.subType;
  		}
  	};

  	// create store outside of the component to use it in the slot..
  	const store = createStore();

  	validate_store(store, "store");
  	component_subscribe($$self, store, value => $$invalidate(4, $store = value));

  	///////// ADDITIONAL DATA
  	// additional data
  	let itemQualities = [];

  	let itemTypes = [];
  	let itemSubTypes = [];
  	let itemSlots = [];

  	// create level array
  	var levels = [];

  	for (var i = 1; i <= 50; i++) {
  		levels.push(i);
  	}

  	onMount(async () => {
  		getItemQualities(q => $$invalidate(0, itemQualities = q));
  		getItemTypes(t => $$invalidate(1, itemTypes = t));
  		getItemSubTypes(st => $$invalidate(2, itemSubTypes = st));
  		getItemSlots(s => $$invalidate(3, itemSlots = s));
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<SampleEditor> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("SampleEditor", $$slots, []);

  	function change_handler_4(event) {
  		bubble($$self, event);
  	}

  	function change_handler_3(event) {
  		bubble($$self, event);
  	}

  	function change_handler_2(event) {
  		bubble($$self, event);
  	}

  	function change_handler_1(event) {
  		bubble($$self, event);
  	}

  	function change_handler(event) {
  		bubble($$self, event);
  	}

  	function select0_change_handler() {
  		$store.selectedElement.level = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select1_change_handler() {
  		$store.selectedElement.type = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select2_change_handler() {
  		$store.selectedElement.subType = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select3_change_handler() {
  		$store.selectedElement.quality = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	function select4_change_handler() {
  		$store.selectedElement.slot = select_value(this);
  		store.set($store);
  		$$invalidate(7, levels);
  	}

  	$$self.$capture_state = () => ({
  		Sprites,
  		onMount,
  		CRUDEditorStore,
  		createStore,
  		uuidv4: v4,
  		getItemTemplate,
  		getItemTemplates,
  		createItemTemplate,
  		updateItemTemplate,
  		deleteItemTemplate,
  		getItemTypes,
  		getItemSubTypes,
  		getItemSlots,
  		getItemQualities,
  		config,
  		store,
  		itemQualities,
  		itemTypes,
  		itemSubTypes,
  		itemSlots,
  		levels,
  		i,
  		$store
  	});

  	$$self.$inject_state = $$props => {
  		if ("itemQualities" in $$props) $$invalidate(0, itemQualities = $$props.itemQualities);
  		if ("itemTypes" in $$props) $$invalidate(1, itemTypes = $$props.itemTypes);
  		if ("itemSubTypes" in $$props) $$invalidate(2, itemSubTypes = $$props.itemSubTypes);
  		if ("itemSlots" in $$props) $$invalidate(3, itemSlots = $$props.itemSlots);
  		if ("levels" in $$props) $$invalidate(7, levels = $$props.levels);
  		if ("i" in $$props) i = $$props.i;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		itemQualities,
  		itemTypes,
  		itemSubTypes,
  		itemSlots,
  		$store,
  		config,
  		store,
  		levels,
  		i,
  		change_handler_4,
  		change_handler_3,
  		change_handler_2,
  		change_handler_1,
  		change_handler,
  		select0_change_handler,
  		select1_change_handler,
  		select2_change_handler,
  		select3_change_handler,
  		select4_change_handler
  	];
  }

  class SampleEditor extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$p, create_fragment$p, safe_not_equal, {}, [-1, -1]);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "SampleEditor",
  			options,
  			id: create_fragment$p.name
  		});
  	}
  }

  /* src/creator/ItemsToolbar.svelte generated by Svelte v3.22.3 */

  const file$l = "src/creator/ItemsToolbar.svelte";

  function create_fragment$q(ctx) {
  	let div;
  	let ul;
  	let li0;
  	let t1;
  	let li1;
  	let button0;
  	let t3;
  	let li2;
  	let button1;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			ul = element("ul");
  			li0 = element("li");
  			li0.textContent = "Manage Item Templates";
  			t1 = space();
  			li1 = element("li");
  			button0 = element("button");
  			button0.textContent = "Create Item Template";
  			t3 = space();
  			li2 = element("li");
  			button1 = element("button");
  			button1.textContent = "Create Item From template";
  			attr_dev(li0, "class", "header svelte-13xq72");
  			add_location(li0, file$l, 39, 4, 520);
  			attr_dev(button0, "class", "btn-flat green svelte-13xq72");
  			add_location(button0, file$l, 41, 6, 581);
  			attr_dev(li1, "class", "svelte-13xq72");
  			add_location(li1, file$l, 40, 4, 570);
  			attr_dev(button1, "class", "btn-flat blue svelte-13xq72");
  			add_location(button1, file$l, 46, 6, 705);
  			attr_dev(li2, "class", "svelte-13xq72");
  			add_location(li2, file$l, 45, 4, 694);
  			attr_dev(ul, "class", "svelte-13xq72");
  			add_location(ul, file$l, 38, 2, 511);
  			attr_dev(div, "class", "row");
  			add_location(div, file$l, 37, 0, 491);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, ul);
  			append_dev(ul, li0);
  			append_dev(ul, t1);
  			append_dev(ul, li1);
  			append_dev(li1, button0);
  			append_dev(ul, t3);
  			append_dev(ul, li2);
  			append_dev(li2, button1);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(
  					button0,
  					"click",
  					function () {
  						if (is_function(/*create*/ ctx[0]())) /*create*/ ctx[0]().apply(this, arguments);
  					},
  					false,
  					false,
  					false
  				),
  				listen_dev(
  					button1,
  					"click",
  					function () {
  						if (is_function(/*createFromTemplate*/ ctx[1]())) /*createFromTemplate*/ ctx[1]().apply(this, arguments);
  					},
  					false,
  					false,
  					false
  				)
  			];
  		},
  		p: function update(new_ctx, [dirty]) {
  			ctx = new_ctx;
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$q.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$q($$self, $$props, $$invalidate) {
  	let { create } = $$props;
  	let { createFromTemplate } = $$props;
  	const writable_props = ["create", "createFromTemplate"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ItemsToolbar> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("ItemsToolbar", $$slots, []);

  	$$self.$set = $$props => {
  		if ("create" in $$props) $$invalidate(0, create = $$props.create);
  		if ("createFromTemplate" in $$props) $$invalidate(1, createFromTemplate = $$props.createFromTemplate);
  	};

  	$$self.$capture_state = () => ({ create, createFromTemplate });

  	$$self.$inject_state = $$props => {
  		if ("create" in $$props) $$invalidate(0, create = $$props.create);
  		if ("createFromTemplate" in $$props) $$invalidate(1, createFromTemplate = $$props.createFromTemplate);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [create, createFromTemplate];
  }

  class ItemsToolbar extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$q, create_fragment$q, safe_not_equal, { create: 0, createFromTemplate: 1 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "ItemsToolbar",
  			options,
  			id: create_fragment$q.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*create*/ ctx[0] === undefined && !("create" in props)) {
  			console.warn("<ItemsToolbar> was created without expected prop 'create'");
  		}

  		if (/*createFromTemplate*/ ctx[1] === undefined && !("createFromTemplate" in props)) {
  			console.warn("<ItemsToolbar> was created without expected prop 'createFromTemplate'");
  		}
  	}

  	get create() {
  		throw new Error("<ItemsToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set create(value) {
  		throw new Error("<ItemsToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get createFromTemplate() {
  		throw new Error("<ItemsToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set createFromTemplate(value) {
  		throw new Error("<ItemsToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  function createStore$1() {
    const { subscribe, set, update } = writable({
      items: [],
      itemTemplates: [],
      selectedItemTemplate: null,
      selectedItem: null,

      filter: "",
    });

    return {
      subscribe,
      set,
      setSelectedItemTemplate: (itemTemplate, cb) => {
        update((state) => {
          state.selectedItemTemplate = itemTemplate;
          return state;
        });
        if (cb) cb();
      },
      setSelectedItem: (item, cb) => {
        update((state) => {
          state.selectedItem = item;
          return state;
        });
        if (cb) cb();
      },
      setItemTemplates: (itemTemplates) => {
        update((state) => {
          state.itemTemplates = itemTemplates;      
          return state;
        });
      },
      setItems: (items) => {
        update((state) => {
          state.items = items;      
          return state;
        });
      }
    };
  }

  const store = createStore$1();

  /* src/creator/ItemTemplatesEditor.svelte generated by Svelte v3.22.3 */

  const { console: console_1$7 } = globals;

  const file$m = "src/creator/ItemTemplatesEditor.svelte";

  function get_each_context$6(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[45] = list[i];
  	return child_ctx;
  }

  function get_each_context_1$2(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[48] = list[i];
  	return child_ctx;
  }

  function get_each_context_2$2(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[51] = list[i];
  	return child_ctx;
  }

  function get_each_context_3$2(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[54] = list[i];
  	return child_ctx;
  }

  function get_each_context_4$2(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[57] = list[i];
  	return child_ctx;
  }

  function get_each_context_5(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[60] = list[i];
  	return child_ctx;
  }

  // (244:10) {#if item.slot}
  function create_if_block_3$1(ctx) {
  	let span;
  	let t0_value = /*item*/ ctx[60].quality + "";
  	let t0;
  	let t1;
  	let t2_value = /*item*/ ctx[60].subType + "";
  	let t2;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t0 = text(t0_value);
  			t1 = space();
  			t2 = text(t2_value);
  			attr_dev(span, "class", "new badge");
  			attr_dev(span, "data-badge-caption", "");
  			add_location(span, file$m, 244, 12, 5024);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t0);
  			append_dev(span, t1);
  			append_dev(span, t2);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 16 && t0_value !== (t0_value = /*item*/ ctx[60].quality + "")) set_data_dev(t0, t0_value);
  			if (dirty[0] & /*$store*/ 16 && t2_value !== (t2_value = /*item*/ ctx[60].subType + "")) set_data_dev(t2, t2_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$1.name,
  		type: "if",
  		source: "(244:10) {#if item.slot}",
  		ctx
  	});

  	return block;
  }

  // (238:6) {#each $store.itemTemplates as item}
  function create_each_block_5(ctx) {
  	let a;
  	let t0;
  	let t1_value = /*item*/ ctx[60].name + "";
  	let t1;
  	let t2;
  	let dispose;
  	let if_block = /*item*/ ctx[60].slot && create_if_block_3$1(ctx);

  	const block = {
  		c: function create() {
  			a = element("a");
  			if (if_block) if_block.c();
  			t0 = space();
  			t1 = text(t1_value);
  			t2 = space();
  			attr_dev(a, "href", "#!");
  			attr_dev(a, "class", "collection-item svelte-16uu6ev");
  			add_location(a, file$m, 238, 8, 4871);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);
  			if (if_block) if_block.m(a, null);
  			append_dev(a, t0);
  			append_dev(a, t1);
  			append_dev(a, t2);
  			if (remount) dispose();

  			dispose = listen_dev(
  				a,
  				"click",
  				function () {
  					if (is_function(/*selectItemTemplate*/ ctx[14](/*item*/ ctx[60]))) /*selectItemTemplate*/ ctx[14](/*item*/ ctx[60]).apply(this, arguments);
  				},
  				false,
  				false,
  				false
  			);
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;

  			if (/*item*/ ctx[60].slot) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_3$1(ctx);
  					if_block.c();
  					if_block.m(a, t0);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (dirty[0] & /*$store*/ 16 && t1_value !== (t1_value = /*item*/ ctx[60].name + "")) set_data_dev(t1, t1_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (if_block) if_block.d();
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_5.name,
  		type: "each",
  		source: "(238:6) {#each $store.itemTemplates as item}",
  		ctx
  	});

  	return block;
  }

  // (255:2) {#if $store.selectedItemTemplate}
  function create_if_block$7(ctx) {
  	let div16;
  	let div15;
  	let div0;
  	let span;
  	let t0_value = /*$store*/ ctx[4].selectedItemTemplate.name + "";
  	let t0;
  	let t1;
  	let t2;
  	let div1;
  	let t3;
  	let div4;
  	let div2;
  	let input0;
  	let t4;
  	let label0;
  	let t6;
  	let div3;
  	let select0;
  	let t7;
  	let label1;
  	let t9;
  	let t10;
  	let div6;
  	let div5;
  	let input1;
  	let t11;
  	let label2;
  	let t13;
  	let div8;
  	let div7;
  	let input2;
  	let t14;
  	let label3;
  	let t16;
  	let div11;
  	let div9;
  	let select1;
  	let option0;
  	let t18;
  	let label4;
  	let t20;
  	let div10;
  	let select2;
  	let option1;
  	let t22;
  	let label5;
  	let t24;
  	let div14;
  	let div12;
  	let select3;
  	let option2;
  	let t26;
  	let label6;
  	let t28;
  	let div13;
  	let select4;
  	let option3;
  	let t30;
  	let label7;
  	let dispose;

  	function select_block_type(ctx, dirty) {
  		if (/*$store*/ ctx[4].selectedItemTemplate.isNew) return create_if_block_2$3;
  		return create_else_block_1$1;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block0 = current_block_type(ctx);
  	let each_value_4 = /*levels*/ ctx[5];
  	validate_each_argument(each_value_4);
  	let each_blocks_4 = [];

  	for (let i = 0; i < each_value_4.length; i += 1) {
  		each_blocks_4[i] = create_each_block_4$2(get_each_context_4$2(ctx, each_value_4, i));
  	}

  	function select_block_type_1(ctx, dirty) {
  		if (/*$store*/ ctx[4].selectedItemTemplate.isNew) return create_if_block_1$6;
  		return create_else_block$2;
  	}

  	let current_block_type_1 = select_block_type_1(ctx);
  	let if_block1 = current_block_type_1(ctx);
  	let each_value_3 = /*itemTypes*/ ctx[1];
  	validate_each_argument(each_value_3);
  	let each_blocks_3 = [];

  	for (let i = 0; i < each_value_3.length; i += 1) {
  		each_blocks_3[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
  	}

  	let each_value_2 = /*itemSubTypes*/ ctx[2];
  	validate_each_argument(each_value_2);
  	let each_blocks_2 = [];

  	for (let i = 0; i < each_value_2.length; i += 1) {
  		each_blocks_2[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
  	}

  	let each_value_1 = /*itemQualities*/ ctx[0];
  	validate_each_argument(each_value_1);
  	let each_blocks_1 = [];

  	for (let i = 0; i < each_value_1.length; i += 1) {
  		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  	}

  	let each_value = /*itemSlots*/ ctx[3];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			div16 = element("div");
  			div15 = element("div");
  			div0 = element("div");
  			span = element("span");
  			t0 = text(t0_value);
  			t1 = space();
  			if_block0.c();
  			t2 = space();
  			div1 = element("div");
  			t3 = space();
  			div4 = element("div");
  			div2 = element("div");
  			input0 = element("input");
  			t4 = space();
  			label0 = element("label");
  			label0.textContent = "Name";
  			t6 = space();
  			div3 = element("div");
  			select0 = element("select");

  			for (let i = 0; i < each_blocks_4.length; i += 1) {
  				each_blocks_4[i].c();
  			}

  			t7 = space();
  			label1 = element("label");
  			label1.textContent = "Level";
  			t9 = space();
  			if_block1.c();
  			t10 = space();
  			div6 = element("div");
  			div5 = element("div");
  			input1 = element("input");
  			t11 = space();
  			label2 = element("label");
  			label2.textContent = "Description";
  			t13 = space();
  			div8 = element("div");
  			div7 = element("div");
  			input2 = element("input");
  			t14 = space();
  			label3 = element("label");
  			label3.textContent = "Detail (look)";
  			t16 = space();
  			div11 = element("div");
  			div9 = element("div");
  			select1 = element("select");
  			option0 = element("option");
  			option0.textContent = "Item Type";

  			for (let i = 0; i < each_blocks_3.length; i += 1) {
  				each_blocks_3[i].c();
  			}

  			t18 = space();
  			label4 = element("label");
  			label4.textContent = "Select Item Type";
  			t20 = space();
  			div10 = element("div");
  			select2 = element("select");
  			option1 = element("option");
  			option1.textContent = "Item Subtype";

  			for (let i = 0; i < each_blocks_2.length; i += 1) {
  				each_blocks_2[i].c();
  			}

  			t22 = space();
  			label5 = element("label");
  			label5.textContent = "Select Item Sub Type";
  			t24 = space();
  			div14 = element("div");
  			div12 = element("div");
  			select3 = element("select");
  			option2 = element("option");
  			option2.textContent = "Item Quality";

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].c();
  			}

  			t26 = space();
  			label6 = element("label");
  			label6.textContent = "Select Item Quality";
  			t28 = space();
  			div13 = element("div");
  			select4 = element("select");
  			option3 = element("option");
  			option3.textContent = "Item Slot";

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			t30 = space();
  			label7 = element("label");
  			label7.textContent = "Select Item Slot";
  			attr_dev(span, "class", "header svelte-16uu6ev");
  			add_location(span, file$m, 261, 10, 5366);
  			attr_dev(div0, "class", "row");
  			add_location(div0, file$m, 259, 8, 5337);
  			attr_dev(div1, "id", "general");
  			add_location(div1, file$m, 286, 8, 6109);
  			attr_dev(input0, "placeholder", "Name");
  			attr_dev(input0, "id", "itemTemplate_name");
  			attr_dev(input0, "type", "text");
  			attr_dev(input0, "class", "svelte-16uu6ev");
  			add_location(input0, file$m, 290, 12, 6227);
  			attr_dev(label0, "class", "first_label svelte-16uu6ev");
  			attr_dev(label0, "for", "itemTemplate_name");
  			add_location(label0, file$m, 296, 12, 6419);
  			attr_dev(div2, "class", "no-padding input-field col s6 svelte-16uu6ev");
  			add_location(div2, file$m, 289, 10, 6171);
  			if (/*$store*/ ctx[4].selectedItemTemplate.level === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[36].call(select0));
  			add_location(select0, file$m, 300, 12, 6568);
  			attr_dev(label1, "class", "svelte-16uu6ev");
  			add_location(label1, file$m, 305, 12, 6781);
  			attr_dev(div3, "class", "margininput input-field col s1 svelte-16uu6ev");
  			add_location(div3, file$m, 299, 10, 6511);
  			attr_dev(div4, "class", "row");
  			add_location(div4, file$m, 288, 8, 6143);
  			attr_dev(input1, "placeholder", "Item Description");
  			attr_dev(input1, "id", "itemTemplate_description");
  			attr_dev(input1, "type", "text");
  			attr_dev(input1, "class", "materialize-textarea svelte-16uu6ev");
  			add_location(input1, file$m, 335, 12, 7682);
  			attr_dev(label2, "class", "active svelte-16uu6ev");
  			attr_dev(label2, "for", "itemTemplate_description");
  			add_location(label2, file$m, 342, 12, 7943);
  			attr_dev(div5, "class", "input-field");
  			add_location(div5, file$m, 334, 10, 7644);
  			attr_dev(div6, "class", "row");
  			add_location(div6, file$m, 333, 8, 7616);
  			attr_dev(input2, "placeholder", "Item Details");
  			attr_dev(input2, "id", "itemTemplate_detail");
  			attr_dev(input2, "type", "text");
  			attr_dev(input2, "class", "materialize-textarea svelte-16uu6ev");
  			add_location(input2, file$m, 350, 12, 8151);
  			attr_dev(label3, "class", "active svelte-16uu6ev");
  			attr_dev(label3, "for", "itemTemplate_detail");
  			add_location(label3, file$m, 357, 12, 8398);
  			attr_dev(div7, "class", "input-field");
  			add_location(div7, file$m, 349, 10, 8113);
  			attr_dev(div8, "class", "row");
  			add_location(div8, file$m, 348, 8, 8085);
  			option0.__value = "";
  			option0.value = option0.__value;
  			option0.disabled = true;
  			option0.selected = true;
  			add_location(option0, file$m, 367, 14, 8704);
  			if (/*$store*/ ctx[4].selectedItemTemplate.type === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[41].call(select1));
  			add_location(select1, file$m, 366, 12, 8623);
  			attr_dev(label4, "class", "svelte-16uu6ev");
  			add_location(label4, file$m, 372, 12, 8922);
  			attr_dev(div9, "class", "margininput input-field col s5 svelte-16uu6ev");
  			add_location(div9, file$m, 365, 10, 8566);
  			option1.__value = "";
  			option1.value = option1.__value;
  			option1.selected = true;
  			add_location(option1, file$m, 380, 14, 9164);
  			if (/*$store*/ ctx[4].selectedItemTemplate.subType === void 0) add_render_callback(() => /*select2_change_handler*/ ctx[42].call(select2));
  			add_location(select2, file$m, 376, 12, 9039);
  			attr_dev(label5, "class", "svelte-16uu6ev");
  			add_location(label5, file$m, 385, 12, 9388);
  			attr_dev(div10, "class", "margininput input-field col s5 svelte-16uu6ev");
  			add_location(div10, file$m, 375, 10, 8982);
  			attr_dev(div11, "class", "row");
  			add_location(div11, file$m, 363, 8, 8537);
  			option2.__value = "";
  			option2.value = option2.__value;
  			option2.disabled = true;
  			option2.selected = true;
  			add_location(option2, file$m, 396, 14, 9676);
  			if (/*$store*/ ctx[4].selectedItemTemplate.quality === void 0) add_render_callback(() => /*select3_change_handler*/ ctx[43].call(select3));
  			add_location(select3, file$m, 392, 12, 9551);
  			attr_dev(label6, "class", "svelte-16uu6ev");
  			add_location(label6, file$m, 402, 12, 9911);
  			attr_dev(div12, "class", "margininput input-field col s5 svelte-16uu6ev");
  			add_location(div12, file$m, 391, 10, 9494);
  			option3.__value = "";
  			option3.value = option3.__value;
  			option3.selected = true;
  			add_location(option3, file$m, 411, 14, 10187);
  			attr_dev(select4, "class", "margininput svelte-16uu6ev");
  			if (/*$store*/ ctx[4].selectedItemTemplate.slot === void 0) add_render_callback(() => /*select4_change_handler*/ ctx[44].call(select4));
  			add_location(select4, file$m, 406, 12, 10031);
  			attr_dev(label7, "class", "svelte-16uu6ev");
  			add_location(label7, file$m, 418, 12, 10447);
  			attr_dev(div13, "class", "margininput input-field col s5 svelte-16uu6ev");
  			add_location(div13, file$m, 405, 10, 9974);
  			attr_dev(div14, "class", "row");
  			add_location(div14, file$m, 389, 8, 9465);
  			attr_dev(div15, "class", "card-panel cyan darken-4");
  			add_location(div15, file$m, 257, 6, 5289);
  			attr_dev(div16, "class", "col s9");
  			add_location(div16, file$m, 255, 4, 5261);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div16, anchor);
  			append_dev(div16, div15);
  			append_dev(div15, div0);
  			append_dev(div0, span);
  			append_dev(span, t0);
  			append_dev(div0, t1);
  			if_block0.m(div0, null);
  			append_dev(div15, t2);
  			append_dev(div15, div1);
  			append_dev(div15, t3);
  			append_dev(div15, div4);
  			append_dev(div4, div2);
  			append_dev(div2, input0);
  			set_input_value(input0, /*$store*/ ctx[4].selectedItemTemplate.name);
  			append_dev(div2, t4);
  			append_dev(div2, label0);
  			append_dev(div4, t6);
  			append_dev(div4, div3);
  			append_dev(div3, select0);

  			for (let i = 0; i < each_blocks_4.length; i += 1) {
  				each_blocks_4[i].m(select0, null);
  			}

  			select_option(select0, /*$store*/ ctx[4].selectedItemTemplate.level);
  			append_dev(div3, t7);
  			append_dev(div3, label1);
  			append_dev(div4, t9);
  			if_block1.m(div4, null);
  			append_dev(div15, t10);
  			append_dev(div15, div6);
  			append_dev(div6, div5);
  			append_dev(div5, input1);
  			set_input_value(input1, /*$store*/ ctx[4].selectedItemTemplate.description);
  			append_dev(div5, t11);
  			append_dev(div5, label2);
  			append_dev(div15, t13);
  			append_dev(div15, div8);
  			append_dev(div8, div7);
  			append_dev(div7, input2);
  			set_input_value(input2, /*$store*/ ctx[4].selectedItemTemplate.detail);
  			append_dev(div7, t14);
  			append_dev(div7, label3);
  			append_dev(div15, t16);
  			append_dev(div15, div11);
  			append_dev(div11, div9);
  			append_dev(div9, select1);
  			append_dev(select1, option0);

  			for (let i = 0; i < each_blocks_3.length; i += 1) {
  				each_blocks_3[i].m(select1, null);
  			}

  			select_option(select1, /*$store*/ ctx[4].selectedItemTemplate.type);
  			append_dev(div9, t18);
  			append_dev(div9, label4);
  			append_dev(div11, t20);
  			append_dev(div11, div10);
  			append_dev(div10, select2);
  			append_dev(select2, option1);

  			for (let i = 0; i < each_blocks_2.length; i += 1) {
  				each_blocks_2[i].m(select2, null);
  			}

  			select_option(select2, /*$store*/ ctx[4].selectedItemTemplate.subType);
  			append_dev(div10, t22);
  			append_dev(div10, label5);
  			append_dev(div15, t24);
  			append_dev(div15, div14);
  			append_dev(div14, div12);
  			append_dev(div12, select3);
  			append_dev(select3, option2);

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].m(select3, null);
  			}

  			select_option(select3, /*$store*/ ctx[4].selectedItemTemplate.quality);
  			append_dev(div12, t26);
  			append_dev(div12, label6);
  			append_dev(div14, t28);
  			append_dev(div14, div13);
  			append_dev(div13, select4);
  			append_dev(select4, option3);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(select4, null);
  			}

  			select_option(select4, /*$store*/ ctx[4].selectedItemTemplate.slot);
  			append_dev(div13, t30);
  			append_dev(div13, label7);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input0, "input", /*input0_input_handler*/ ctx[35]),
  				listen_dev(select0, "change", /*select0_change_handler*/ ctx[36]),
  				listen_dev(select0, "change", /*change_handler*/ ctx[31], false, false, false),
  				listen_dev(input1, "input", /*input1_input_handler*/ ctx[39]),
  				listen_dev(input2, "input", /*input2_input_handler*/ ctx[40]),
  				listen_dev(select1, "change", /*select1_change_handler*/ ctx[41]),
  				listen_dev(select1, "change", /*change_handler_1*/ ctx[30], false, false, false),
  				listen_dev(select2, "change", /*select2_change_handler*/ ctx[42]),
  				listen_dev(select2, "change", /*change_handler_2*/ ctx[29], false, false, false),
  				listen_dev(select3, "change", /*select3_change_handler*/ ctx[43]),
  				listen_dev(select3, "change", /*change_handler_3*/ ctx[28], false, false, false),
  				listen_dev(select4, "change", /*select4_change_handler*/ ctx[44]),
  				listen_dev(select4, "change", /*change_handler_4*/ ctx[27], false, false, false)
  			];
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 16 && t0_value !== (t0_value = /*$store*/ ctx[4].selectedItemTemplate.name + "")) set_data_dev(t0, t0_value);

  			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
  				if_block0.p(ctx, dirty);
  			} else {
  				if_block0.d(1);
  				if_block0 = current_block_type(ctx);

  				if (if_block0) {
  					if_block0.c();
  					if_block0.m(div0, null);
  				}
  			}

  			if (dirty[0] & /*$store*/ 16 && input0.value !== /*$store*/ ctx[4].selectedItemTemplate.name) {
  				set_input_value(input0, /*$store*/ ctx[4].selectedItemTemplate.name);
  			}

  			if (dirty[0] & /*levels*/ 32) {
  				each_value_4 = /*levels*/ ctx[5];
  				validate_each_argument(each_value_4);
  				let i;

  				for (i = 0; i < each_value_4.length; i += 1) {
  					const child_ctx = get_each_context_4$2(ctx, each_value_4, i);

  					if (each_blocks_4[i]) {
  						each_blocks_4[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_4[i] = create_each_block_4$2(child_ctx);
  						each_blocks_4[i].c();
  						each_blocks_4[i].m(select0, null);
  					}
  				}

  				for (; i < each_blocks_4.length; i += 1) {
  					each_blocks_4[i].d(1);
  				}

  				each_blocks_4.length = each_value_4.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select0, /*$store*/ ctx[4].selectedItemTemplate.level);
  			}

  			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
  				if_block1.p(ctx, dirty);
  			} else {
  				if_block1.d(1);
  				if_block1 = current_block_type_1(ctx);

  				if (if_block1) {
  					if_block1.c();
  					if_block1.m(div4, null);
  				}
  			}

  			if (dirty[0] & /*$store*/ 16 && input1.value !== /*$store*/ ctx[4].selectedItemTemplate.description) {
  				set_input_value(input1, /*$store*/ ctx[4].selectedItemTemplate.description);
  			}

  			if (dirty[0] & /*$store*/ 16 && input2.value !== /*$store*/ ctx[4].selectedItemTemplate.detail) {
  				set_input_value(input2, /*$store*/ ctx[4].selectedItemTemplate.detail);
  			}

  			if (dirty[0] & /*itemTypes*/ 2) {
  				each_value_3 = /*itemTypes*/ ctx[1];
  				validate_each_argument(each_value_3);
  				let i;

  				for (i = 0; i < each_value_3.length; i += 1) {
  					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

  					if (each_blocks_3[i]) {
  						each_blocks_3[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_3[i] = create_each_block_3$2(child_ctx);
  						each_blocks_3[i].c();
  						each_blocks_3[i].m(select1, null);
  					}
  				}

  				for (; i < each_blocks_3.length; i += 1) {
  					each_blocks_3[i].d(1);
  				}

  				each_blocks_3.length = each_value_3.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select1, /*$store*/ ctx[4].selectedItemTemplate.type);
  			}

  			if (dirty[0] & /*itemSubTypes*/ 4) {
  				each_value_2 = /*itemSubTypes*/ ctx[2];
  				validate_each_argument(each_value_2);
  				let i;

  				for (i = 0; i < each_value_2.length; i += 1) {
  					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

  					if (each_blocks_2[i]) {
  						each_blocks_2[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_2[i] = create_each_block_2$2(child_ctx);
  						each_blocks_2[i].c();
  						each_blocks_2[i].m(select2, null);
  					}
  				}

  				for (; i < each_blocks_2.length; i += 1) {
  					each_blocks_2[i].d(1);
  				}

  				each_blocks_2.length = each_value_2.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select2, /*$store*/ ctx[4].selectedItemTemplate.subType);
  			}

  			if (dirty[0] & /*itemQualities*/ 1) {
  				each_value_1 = /*itemQualities*/ ctx[0];
  				validate_each_argument(each_value_1);
  				let i;

  				for (i = 0; i < each_value_1.length; i += 1) {
  					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

  					if (each_blocks_1[i]) {
  						each_blocks_1[i].p(child_ctx, dirty);
  					} else {
  						each_blocks_1[i] = create_each_block_1$2(child_ctx);
  						each_blocks_1[i].c();
  						each_blocks_1[i].m(select3, null);
  					}
  				}

  				for (; i < each_blocks_1.length; i += 1) {
  					each_blocks_1[i].d(1);
  				}

  				each_blocks_1.length = each_value_1.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select3, /*$store*/ ctx[4].selectedItemTemplate.quality);
  			}

  			if (dirty[0] & /*itemSlots*/ 8) {
  				each_value = /*itemSlots*/ ctx[3];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$6(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block$6(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(select4, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}

  			if (dirty[0] & /*$store*/ 16) {
  				select_option(select4, /*$store*/ ctx[4].selectedItemTemplate.slot);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div16);
  			if_block0.d();
  			destroy_each(each_blocks_4, detaching);
  			if_block1.d();
  			destroy_each(each_blocks_3, detaching);
  			destroy_each(each_blocks_2, detaching);
  			destroy_each(each_blocks_1, detaching);
  			destroy_each(each_blocks, detaching);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$7.name,
  		type: "if",
  		source: "(255:2) {#if $store.selectedItemTemplate}",
  		ctx
  	});

  	return block;
  }

  // (271:10) {:else}
  function create_else_block_1$1(ctx) {
  	let button0;
  	let t1;
  	let button1;
  	let dispose;

  	const block = {
  		c: function create() {
  			button0 = element("button");
  			button0.textContent = "Update";
  			t1 = space();
  			button1 = element("button");
  			button1.textContent = "Delete";
  			attr_dev(button0, "class", "waves-effect waves-light btn-small green right svelte-16uu6ev");
  			add_location(button0, file$m, 271, 12, 5698);
  			attr_dev(button1, "class", "waves-effect waves-light btn-small red right svelte-16uu6ev");
  			add_location(button1, file$m, 277, 12, 5886);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, button0, anchor);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, button1, anchor);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(button0, "click", /*click_handler_1*/ ctx[33], false, false, false),
  				listen_dev(button1, "click", /*click_handler_2*/ ctx[34], false, false, false)
  			];
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(button0);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(button1);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_1$1.name,
  		type: "else",
  		source: "(271:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (264:10) {#if $store.selectedItemTemplate.isNew}
  function create_if_block_2$3(ctx) {
  	let button;
  	let dispose;

  	const block = {
  		c: function create() {
  			button = element("button");
  			button.textContent = "Create";
  			attr_dev(button, "class", "waves-effect waves-light btn-small green right svelte-16uu6ev");
  			add_location(button, file$m, 264, 12, 5492);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, button, anchor);
  			if (remount) dispose();
  			dispose = listen_dev(button, "click", /*click_handler*/ ctx[32], false, false, false);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(button);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$3.name,
  		type: "if",
  		source: "(264:10) {#if $store.selectedItemTemplate.isNew}",
  		ctx
  	});

  	return block;
  }

  // (302:14) {#each levels as lvl}
  function create_each_block_4$2(ctx) {
  	let option;
  	let t_value = /*lvl*/ ctx[57] + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*lvl*/ ctx[57];
  			option.value = option.__value;
  			add_location(option, file$m, 302, 16, 6688);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_4$2.name,
  		type: "each",
  		source: "(302:14) {#each levels as lvl}",
  		ctx
  	});

  	return block;
  }

  // (319:10) {:else}
  function create_else_block$2(ctx) {
  	let div;
  	let input;
  	let t0;
  	let label;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			input = element("input");
  			t0 = space();
  			label = element("label");
  			label.textContent = "ID";
  			attr_dev(input, "placeholder", "ID");
  			attr_dev(input, "id", "itemTemplate_id");
  			attr_dev(input, "type", "text");
  			input.disabled = true;
  			attr_dev(input, "class", "svelte-16uu6ev");
  			add_location(input, file$m, 320, 14, 7278);
  			attr_dev(label, "class", "active svelte-16uu6ev");
  			attr_dev(label, "for", "itemTemplate_id");
  			add_location(label, file$m, 327, 14, 7501);
  			attr_dev(div, "class", "input-field col s4");
  			add_location(div, file$m, 319, 12, 7231);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, input);
  			set_input_value(input, /*$store*/ ctx[4].selectedItemTemplate.id);
  			append_dev(div, t0);
  			append_dev(div, label);
  			if (remount) dispose();
  			dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[38]);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 16 && input.value !== /*$store*/ ctx[4].selectedItemTemplate.id) {
  				set_input_value(input, /*$store*/ ctx[4].selectedItemTemplate.id);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$2.name,
  		type: "else",
  		source: "(319:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (309:10) {#if $store.selectedItemTemplate.isNew}
  function create_if_block_1$6(ctx) {
  	let div;
  	let input;
  	let t0;
  	let label;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			input = element("input");
  			t0 = space();
  			label = element("label");
  			label.textContent = "ID";
  			attr_dev(input, "placeholder", "ID");
  			attr_dev(input, "id", "itemTemplate_id");
  			attr_dev(input, "type", "text");
  			attr_dev(input, "class", "svelte-16uu6ev");
  			add_location(input, file$m, 310, 14, 6929);
  			attr_dev(label, "class", "active svelte-16uu6ev");
  			attr_dev(label, "for", "itemTemplate_id");
  			add_location(label, file$m, 316, 14, 7127);
  			attr_dev(div, "class", "input-field col s4");
  			add_location(div, file$m, 309, 12, 6882);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, input);
  			set_input_value(input, /*$store*/ ctx[4].selectedItemTemplate.id);
  			append_dev(div, t0);
  			append_dev(div, label);
  			if (remount) dispose();
  			dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[37]);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 16 && input.value !== /*$store*/ ctx[4].selectedItemTemplate.id) {
  				set_input_value(input, /*$store*/ ctx[4].selectedItemTemplate.id);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$6.name,
  		type: "if",
  		source: "(309:10) {#if $store.selectedItemTemplate.isNew}",
  		ctx
  	});

  	return block;
  }

  // (369:14) {#each itemTypes as type}
  function create_each_block_3$2(ctx) {
  	let option;
  	let t_value = /*type*/ ctx[54].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*type*/ ctx[54];
  			option.value = option.__value;
  			add_location(option, file$m, 369, 16, 8814);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemTypes*/ 2 && t_value !== (t_value = /*type*/ ctx[54].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemTypes*/ 2 && option_value_value !== (option_value_value = /*type*/ ctx[54])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_3$2.name,
  		type: "each",
  		source: "(369:14) {#each itemTypes as type}",
  		ctx
  	});

  	return block;
  }

  // (382:14) {#each itemSubTypes as subType}
  function create_each_block_2$2(ctx) {
  	let option;
  	let t_value = /*subType*/ ctx[51].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*subType*/ ctx[51];
  			option.value = option.__value;
  			add_location(option, file$m, 382, 16, 9274);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemSubTypes*/ 4 && t_value !== (t_value = /*subType*/ ctx[51].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemSubTypes*/ 4 && option_value_value !== (option_value_value = /*subType*/ ctx[51])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_2$2.name,
  		type: "each",
  		source: "(382:14) {#each itemSubTypes as subType}",
  		ctx
  	});

  	return block;
  }

  // (398:14) {#each itemQualities as quality}
  function create_each_block_1$2(ctx) {
  	let option;
  	let t_value = /*quality*/ ctx[48].capitalize() + "";
  	let t;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t = text(t_value);
  			option.__value = option_value_value = /*quality*/ ctx[48];
  			option.value = option.__value;
  			add_location(option, file$m, 398, 16, 9796);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemQualities*/ 1 && t_value !== (t_value = /*quality*/ ctx[48].capitalize() + "")) set_data_dev(t, t_value);

  			if (dirty[0] & /*itemQualities*/ 1 && option_value_value !== (option_value_value = /*quality*/ ctx[48])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_1$2.name,
  		type: "each",
  		source: "(398:14) {#each itemQualities as quality}",
  		ctx
  	});

  	return block;
  }

  // (413:14) {#each itemSlots as slot}
  function create_each_block$6(ctx) {
  	let option;
  	let t0_value = /*slot*/ ctx[45].capitalize() + "";
  	let t0;
  	let t1;
  	let option_value_value;

  	const block = {
  		c: function create() {
  			option = element("option");
  			t0 = text(t0_value);
  			t1 = space();
  			attr_dev(option, "class", "select");
  			option.__value = option_value_value = /*slot*/ ctx[45];
  			option.value = option.__value;
  			add_location(option, file$m, 413, 16, 10288);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, option, anchor);
  			append_dev(option, t0);
  			append_dev(option, t1);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*itemSlots*/ 8 && t0_value !== (t0_value = /*slot*/ ctx[45].capitalize() + "")) set_data_dev(t0, t0_value);

  			if (dirty[0] & /*itemSlots*/ 8 && option_value_value !== (option_value_value = /*slot*/ ctx[45])) {
  				prop_dev(option, "__value", option_value_value);
  			}

  			option.value = option.__value;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(option);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$6.name,
  		type: "each",
  		source: "(413:14) {#each itemSlots as slot}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$r(ctx) {
  	let t0;
  	let div2;
  	let div1;
  	let div0;
  	let t1;
  	let current;

  	const itemstoolbar = new ItemsToolbar({
  			props: { create: /*newItem*/ ctx[11] },
  			$$inline: true
  		});

  	let each_value_5 = /*$store*/ ctx[4].itemTemplates;
  	validate_each_argument(each_value_5);
  	let each_blocks = [];

  	for (let i = 0; i < each_value_5.length; i += 1) {
  		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  	}

  	let if_block = /*$store*/ ctx[4].selectedItemTemplate && create_if_block$7(ctx);

  	const block = {
  		c: function create() {
  			create_component(itemstoolbar.$$.fragment);
  			t0 = space();
  			div2 = element("div");
  			div1 = element("div");
  			div0 = element("div");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			t1 = space();
  			if (if_block) if_block.c();
  			attr_dev(div0, "class", "collection svelte-16uu6ev");
  			add_location(div0, file$m, 236, 4, 4795);
  			attr_dev(div1, "class", "col s3");
  			add_location(div1, file$m, 235, 2, 4770);
  			attr_dev(div2, "class", "row");
  			add_location(div2, file$m, 233, 0, 4749);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(itemstoolbar, target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div2, anchor);
  			append_dev(div2, div1);
  			append_dev(div1, div0);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(div0, null);
  			}

  			append_dev(div2, t1);
  			if (if_block) if_block.m(div2, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*selectItemTemplate, $store*/ 16400) {
  				each_value_5 = /*$store*/ ctx[4].itemTemplates;
  				validate_each_argument(each_value_5);
  				let i;

  				for (i = 0; i < each_value_5.length; i += 1) {
  					const child_ctx = get_each_context_5(ctx, each_value_5, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block_5(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(div0, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value_5.length;
  			}

  			if (/*$store*/ ctx[4].selectedItemTemplate) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block$7(ctx);
  					if_block.c();
  					if_block.m(div2, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(itemstoolbar.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(itemstoolbar.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(itemstoolbar, detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div2);
  			destroy_each(each_blocks, detaching);
  			if (if_block) if_block.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$r.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$r($$self, $$props, $$invalidate) {
  	let $isLoading;
  	let $isAuthenticated;
  	let $authError;
  	let $userInfo;
  	let $authToken;
  	let $store;
  	validate_store(store, "store");
  	component_subscribe($$self, store, $$value => $$invalidate(4, $store = $$value));
  	let { location } = $$props;
  	let itemQualities = [];
  	let itemTypes = [];
  	let itemSubTypes = [];
  	let itemSlots = [];

  	// create level array
  	var levels = [];

  	for (var i = 1; i <= 50; i++) {
  		levels.push(i);
  	}

  	const { isLoading, isAuthenticated, login, logout, authToken, authError, userInfo } = getAuth();
  	validate_store(isLoading, "isLoading");
  	component_subscribe($$self, isLoading, value => $$invalidate(19, $isLoading = value));
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(20, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(23, $authToken = value));
  	validate_store(authError, "authError");
  	component_subscribe($$self, authError, value => $$invalidate(21, $authError = value));
  	validate_store(userInfo, "userInfo");
  	component_subscribe($$self, userInfo, value => $$invalidate(22, $userInfo = value));

  	const loadData = async cb => {
  		if ($isLoading && !$isAuthenticated) return;

  		getItemTemplates(
  			$authToken,
  			itemTemplates => {
  				store.setItemTemplates(itemTemplates);
  				if (cb) cb();
  			},
  			err => console.log(err)
  		);
  	};

  	onMount(async () => {
  		getItemQualities(q => $$invalidate(0, itemQualities = q));
  		getItemTypes(t => $$invalidate(1, itemTypes = t));
  		getItemSubTypes(st => $$invalidate(2, itemSubTypes = st));
  		getItemSlots(s => $$invalidate(3, itemSlots = s));

  		loadData(() => {
  			selectItemTemplate($store.itemTemplates[0]);
  		});
  	});

  	const newItem = () => {
  		let item = {
  			id: v4(),
  			name: "Unnamed Item",
  			description: "",
  			detail: "",
  			type: "",
  			slot: "inventory",
  			quality: "normal",
  			level: 1,
  			properties: new Map(),
  			attributes: new Map(),
  			noPickup: false,
  			tags: [],
  			isNew: true
  		};

  		selectItemTemplate(item);
  	};

  	const delItemTemplate = async () => {
  		deleteItemTemplate(
  			$authToken,
  			$store.selectedItemTemplate.id,
  			() => {
  				console.log("delete successful.");

  				loadData(() => {
  					if ($store.itemTemplates) {
  						store.setSelectedItemTemplate($store.itemTemplates[0]);
  					}
  				});
  			},
  			() => {
  				console.log("create error.");
  			}
  		);
  	};

  	const create = async () => {
  		createItemTemplate(
  			$authToken,
  			$store.selectedItemTemplate,
  			itemTemplate => {
  				console.log("create successful.");
  				loadData();
  				set_store_value(store, $store.selectedItemTemplate = itemTemplate, $store);
  			},
  			() => {
  				console.log("create error.");
  			}
  		);
  	};

  	const selectItemTemplate = itemTemplate => {
  		store.setSelectedItemTemplate(itemTemplate, () => {
  			var elems = document.querySelectorAll("select");
  			var instances = M.FormSelect.init(elems, {});

  			// second time to fix the selects
  			setTimeout(
  				function () {
  					var elems = document.querySelectorAll("select");
  					var instances = M.FormSelect.init(elems, {});
  				},
  				50
  			);
  		});
  	}; /*
  var targets = document.querySelectorAll(".autocomplete");
  const options = {
    data: {},
    onAutocomplete: function (roomName) {
      console.log(roomName);
    },
  };

  $store.rooms.forEach((value) => {
    options.data[value.name] = null;
  });
  var targetInstances = M.Autocomplete.init(targets, options);*/

  	const update = () => {
  		updateItemTemplate(
  			$authToken,
  			$store.selectedItemTemplate.id,
  			$store.selectedItemTemplate,
  			() => {
  				console.log("update successful.");
  				loadData();
  			},
  			() => {
  				console.log("update error.");
  			}
  		);
  	};

  	const writable_props = ["location"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<ItemTemplatesEditor> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("ItemTemplatesEditor", $$slots, []);

  	function change_handler_4(event) {
  		bubble($$self, event);
  	}

  	function change_handler_3(event) {
  		bubble($$self, event);
  	}

  	function change_handler_2(event) {
  		bubble($$self, event);
  	}

  	function change_handler_1(event) {
  		bubble($$self, event);
  	}

  	function change_handler(event) {
  		bubble($$self, event);
  	}

  	const click_handler = () => create();
  	const click_handler_1 = () => update();
  	const click_handler_2 = () => delItemTemplate();

  	function input0_input_handler() {
  		$store.selectedItemTemplate.name = this.value;
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function select0_change_handler() {
  		$store.selectedItemTemplate.level = select_value(this);
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function input_input_handler() {
  		$store.selectedItemTemplate.id = this.value;
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function input_input_handler_1() {
  		$store.selectedItemTemplate.id = this.value;
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function input1_input_handler() {
  		$store.selectedItemTemplate.description = this.value;
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function input2_input_handler() {
  		$store.selectedItemTemplate.detail = this.value;
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function select1_change_handler() {
  		$store.selectedItemTemplate.type = select_value(this);
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function select2_change_handler() {
  		$store.selectedItemTemplate.subType = select_value(this);
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function select3_change_handler() {
  		$store.selectedItemTemplate.quality = select_value(this);
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	function select4_change_handler() {
  		$store.selectedItemTemplate.slot = select_value(this);
  		store.set($store);
  		$$invalidate(5, levels);
  	}

  	$$self.$set = $$props => {
  		if ("location" in $$props) $$invalidate(16, location = $$props.location);
  	};

  	$$self.$capture_state = () => ({
  		ItemsToolbar,
  		store,
  		PlusIcon,
  		writable,
  		onMount,
  		createAuth,
  		getAuth,
  		uuidv4: v4,
  		axios: axios$1,
  		getItemTemplate,
  		getItemTemplates,
  		createItemTemplate,
  		updateItemTemplate,
  		deleteItemTemplate,
  		getItemTypes,
  		getItemSubTypes,
  		getItemSlots,
  		getItemQualities,
  		location,
  		itemQualities,
  		itemTypes,
  		itemSubTypes,
  		itemSlots,
  		levels,
  		i,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		authError,
  		userInfo,
  		loadData,
  		newItem,
  		delItemTemplate,
  		create,
  		selectItemTemplate,
  		update,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken,
  		$store
  	});

  	$$self.$inject_state = $$props => {
  		if ("location" in $$props) $$invalidate(16, location = $$props.location);
  		if ("itemQualities" in $$props) $$invalidate(0, itemQualities = $$props.itemQualities);
  		if ("itemTypes" in $$props) $$invalidate(1, itemTypes = $$props.itemTypes);
  		if ("itemSubTypes" in $$props) $$invalidate(2, itemSubTypes = $$props.itemSubTypes);
  		if ("itemSlots" in $$props) $$invalidate(3, itemSlots = $$props.itemSlots);
  		if ("levels" in $$props) $$invalidate(5, levels = $$props.levels);
  		if ("i" in $$props) i = $$props.i;
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*$isLoading, $isAuthenticated, $authError, $userInfo, $authToken*/ 16252928) {
  			 state = {
  				isLoading: $isLoading,
  				isAuthenticated: $isAuthenticated,
  				authError: $authError,
  				userInfo: $userInfo ? $userInfo.name : null,
  				authToken: $authToken.slice(0, 20)
  			};
  		}
  	};

  	return [
  		itemQualities,
  		itemTypes,
  		itemSubTypes,
  		itemSlots,
  		$store,
  		levels,
  		isLoading,
  		isAuthenticated,
  		authToken,
  		authError,
  		userInfo,
  		newItem,
  		delItemTemplate,
  		create,
  		selectItemTemplate,
  		update,
  		location,
  		i,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken,
  		login,
  		logout,
  		loadData,
  		change_handler_4,
  		change_handler_3,
  		change_handler_2,
  		change_handler_1,
  		change_handler,
  		click_handler,
  		click_handler_1,
  		click_handler_2,
  		input0_input_handler,
  		select0_change_handler,
  		input_input_handler,
  		input_input_handler_1,
  		input1_input_handler,
  		input2_input_handler,
  		select1_change_handler,
  		select2_change_handler,
  		select3_change_handler,
  		select4_change_handler
  	];
  }

  class ItemTemplatesEditor extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$r, create_fragment$r, safe_not_equal, { location: 16 }, [-1, -1, -1]);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "ItemTemplatesEditor",
  			options,
  			id: create_fragment$r.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*location*/ ctx[16] === undefined && !("location" in props)) {
  			console_1$7.warn("<ItemTemplatesEditor> was created without expected prop 'location'");
  		}
  	}

  	get location() {
  		throw new Error("<ItemTemplatesEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set location(value) {
  		throw new Error("<ItemTemplatesEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  function getWorldMap(token, cb, errorCb) {
    axios$1
      .get(`${backend}/world/map`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  /* src/creator/WorldEditor.svelte generated by Svelte v3.22.3 */

  const { console: console_1$8 } = globals;
  const file$n = "src/creator/WorldEditor.svelte";

  // (52:2) {#if $isAuthenticated}
  function create_if_block$8(ctx) {
  	let img_1;
  	let img_1_src_value;

  	const block = {
  		c: function create() {
  			img_1 = element("img");
  			attr_dev(img_1, "class", "responsive-img z-depth-3");
  			if (img_1.src !== (img_1_src_value = /*img*/ ctx[0])) attr_dev(img_1, "src", img_1_src_value);
  			attr_dev(img_1, "alt", "world map");
  			add_location(img_1, file$n, 52, 4, 940);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img_1, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*img*/ 1 && img_1.src !== (img_1_src_value = /*img*/ ctx[0])) {
  				attr_dev(img_1, "src", img_1_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img_1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$8.name,
  		type: "if",
  		source: "(52:2) {#if $isAuthenticated}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$s(ctx) {
  	let div;
  	let h4;
  	let t1;
  	let if_block = /*$isAuthenticated*/ ctx[1] && create_if_block$8(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			h4 = element("h4");
  			h4.textContent = "Map of Rooms";
  			t1 = space();
  			if (if_block) if_block.c();
  			add_location(h4, file$n, 50, 2, 889);
  			attr_dev(div, "class", "row");
  			add_location(div, file$n, 49, 0, 869);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, h4);
  			append_dev(div, t1);
  			if (if_block) if_block.m(div, null);
  		},
  		p: function update(ctx, [dirty]) {
  			if (/*$isAuthenticated*/ ctx[1]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block$8(ctx);
  					if_block.c();
  					if_block.m(div, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$s.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$s($$self, $$props, $$invalidate) {
  	let $isLoading;
  	let $isAuthenticated;
  	let $authError;
  	let $userInfo;
  	let $authToken;
  	let { location } = $$props;
  	let img;
  	const { isLoading, isAuthenticated, login, logout, authToken, authError, userInfo } = getAuth();
  	validate_store(isLoading, "isLoading");
  	component_subscribe($$self, isLoading, value => $$invalidate(9, $isLoading = value));
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(1, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(12, $authToken = value));
  	validate_store(authError, "authError");
  	component_subscribe($$self, authError, value => $$invalidate(10, $authError = value));
  	validate_store(userInfo, "userInfo");
  	component_subscribe($$self, userInfo, value => $$invalidate(11, $userInfo = value));

  	onMount(async () => {
  		
  	});

  	const writable_props = ["location"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<WorldEditor> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("WorldEditor", $$slots, []);

  	$$self.$set = $$props => {
  		if ("location" in $$props) $$invalidate(7, location = $$props.location);
  	};

  	$$self.$capture_state = () => ({
  		writable,
  		onMount,
  		createAuth,
  		getAuth,
  		getWorldMap,
  		axios: axios$1,
  		location,
  		img,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		authError,
  		userInfo,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken
  	});

  	$$self.$inject_state = $$props => {
  		if ("location" in $$props) $$invalidate(7, location = $$props.location);
  		if ("img" in $$props) $$invalidate(0, img = $$props.img);
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isLoading, $isAuthenticated, $authError, $userInfo, $authToken*/ 7682) {
  			 state = {
  				isLoading: $isLoading,
  				isAuthenticated: $isAuthenticated,
  				authError: $authError,
  				userInfo: $userInfo ? $userInfo.name : null,
  				authToken: $authToken.slice(0, 20)
  			};
  		}

  		if ($$self.$$.dirty & /*$isLoading, $isAuthenticated, $authToken*/ 4610) {
  			 {
  				if (!$isLoading && $isAuthenticated && authToken) {
  					getWorldMap(
  						$authToken,
  						world => {
  							$$invalidate(0, img = world);
  						},
  						err => console.log(err)
  					);
  				}
  			}
  		}
  	};

  	return [
  		img,
  		$isAuthenticated,
  		isLoading,
  		isAuthenticated,
  		authToken,
  		authError,
  		userInfo,
  		location
  	];
  }

  class WorldEditor extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$s, create_fragment$s, safe_not_equal, { location: 7 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "WorldEditor",
  			options,
  			id: create_fragment$s.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*location*/ ctx[7] === undefined && !("location" in props)) {
  			console_1$8.warn("<WorldEditor> was created without expected prop 'location'");
  		}
  	}

  	get location() {
  		throw new Error("<WorldEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set location(value) {
  		throw new Error("<WorldEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/creator/RoomsToolbar.svelte generated by Svelte v3.22.3 */

  const file$o = "src/creator/RoomsToolbar.svelte";

  function create_fragment$t(ctx) {
  	let div;
  	let ul;
  	let li0;
  	let t1;
  	let li1;
  	let button0;
  	let t3;
  	let li2;
  	let button1;
  	let t5;
  	let li3;
  	let button2;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			ul = element("ul");
  			li0 = element("li");
  			li0.textContent = "Manage Rooms";
  			t1 = space();
  			li1 = element("li");
  			button0 = element("button");
  			button0.textContent = "Create New Room";
  			t3 = space();
  			li2 = element("li");
  			button1 = element("button");
  			button1.textContent = "Create Exit";
  			t5 = space();
  			li3 = element("li");
  			button2 = element("button");
  			button2.textContent = "Create Action";
  			attr_dev(li0, "class", "header svelte-13xq72");
  			add_location(li0, file$o, 40, 4, 537);
  			attr_dev(button0, "class", "btn-flat green svelte-13xq72");
  			add_location(button0, file$o, 42, 6, 589);
  			attr_dev(li1, "class", "svelte-13xq72");
  			add_location(li1, file$o, 41, 4, 578);
  			attr_dev(button1, "class", "btn-flat blue svelte-13xq72");
  			add_location(button1, file$o, 47, 6, 712);
  			attr_dev(li2, "class", "svelte-13xq72");
  			add_location(li2, file$o, 46, 4, 701);
  			attr_dev(button2, "class", "btn-flat blue svelte-13xq72");
  			add_location(button2, file$o, 50, 6, 811);
  			attr_dev(li3, "class", "svelte-13xq72");
  			add_location(li3, file$o, 49, 4, 800);
  			attr_dev(ul, "class", "svelte-13xq72");
  			add_location(ul, file$o, 39, 2, 528);
  			attr_dev(div, "class", "row");
  			add_location(div, file$o, 38, 0, 508);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, ul);
  			append_dev(ul, li0);
  			append_dev(ul, t1);
  			append_dev(ul, li1);
  			append_dev(li1, button0);
  			append_dev(ul, t3);
  			append_dev(ul, li2);
  			append_dev(li2, button1);
  			append_dev(ul, t5);
  			append_dev(ul, li3);
  			append_dev(li3, button2);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(
  					button0,
  					"click",
  					function () {
  						if (is_function(/*createRoom*/ ctx[0]())) /*createRoom*/ ctx[0]().apply(this, arguments);
  					},
  					false,
  					false,
  					false
  				),
  				listen_dev(
  					button1,
  					"click",
  					function () {
  						if (is_function(/*addExit*/ ctx[1]())) /*addExit*/ ctx[1]().apply(this, arguments);
  					},
  					false,
  					false,
  					false
  				),
  				listen_dev(
  					button2,
  					"click",
  					function () {
  						if (is_function(/*addAction*/ ctx[2]())) /*addAction*/ ctx[2]().apply(this, arguments);
  					},
  					false,
  					false,
  					false
  				)
  			];
  		},
  		p: function update(new_ctx, [dirty]) {
  			ctx = new_ctx;
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$t.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$t($$self, $$props, $$invalidate) {
  	let { createRoom } = $$props;
  	let { addExit } = $$props;
  	let { addAction } = $$props;
  	const writable_props = ["createRoom", "addExit", "addAction"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RoomsToolbar> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("RoomsToolbar", $$slots, []);

  	$$self.$set = $$props => {
  		if ("createRoom" in $$props) $$invalidate(0, createRoom = $$props.createRoom);
  		if ("addExit" in $$props) $$invalidate(1, addExit = $$props.addExit);
  		if ("addAction" in $$props) $$invalidate(2, addAction = $$props.addAction);
  	};

  	$$self.$capture_state = () => ({ createRoom, addExit, addAction });

  	$$self.$inject_state = $$props => {
  		if ("createRoom" in $$props) $$invalidate(0, createRoom = $$props.createRoom);
  		if ("addExit" in $$props) $$invalidate(1, addExit = $$props.addExit);
  		if ("addAction" in $$props) $$invalidate(2, addAction = $$props.addAction);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [createRoom, addExit, addAction];
  }

  class RoomsToolbar extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$t, create_fragment$t, safe_not_equal, { createRoom: 0, addExit: 1, addAction: 2 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "RoomsToolbar",
  			options,
  			id: create_fragment$t.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*createRoom*/ ctx[0] === undefined && !("createRoom" in props)) {
  			console.warn("<RoomsToolbar> was created without expected prop 'createRoom'");
  		}

  		if (/*addExit*/ ctx[1] === undefined && !("addExit" in props)) {
  			console.warn("<RoomsToolbar> was created without expected prop 'addExit'");
  		}

  		if (/*addAction*/ ctx[2] === undefined && !("addAction" in props)) {
  			console.warn("<RoomsToolbar> was created without expected prop 'addAction'");
  		}
  	}

  	get createRoom() {
  		throw new Error("<RoomsToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set createRoom(value) {
  		throw new Error("<RoomsToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get addExit() {
  		throw new Error("<RoomsToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set addExit(value) {
  		throw new Error("<RoomsToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get addAction() {
  		throw new Error("<RoomsToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set addAction(value) {
  		throw new Error("<RoomsToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  function createStore$2() {
    const { subscribe, set, update } = writable({
      rooms: [],
      filteredRooms: [],
      selectedRoom: null,

      filter: "",
    });

    return {
      subscribe,
      setSelectedRoom: (room, cb) => {
        update((state) => {
          state.selectedRoom = room;
          return state;
        });
        if (cb) cb();
      },
      deleteExit: (exit) =>
        update((state) => {
          state.selectedRoom.exits = state.selectedRoom.exits.filter(
            (x) => x.name != exit.name
          );
          return state;
        }),
      createExit: () => {
        update((state) => {
          if (state.selectedRoom.exits == null) {
            state.selectedRoom.exits = [];
          }

          state.selectedRoom.exits.push({
            name: "New Exit",
            description: "todo",
            target: "select target",
          });
          return state;
        });
      },
      setFilter: (filter) => {
        update((state) => {
          state.filter = filter;
          state.filteredRooms = rooms.filter((x) => x.name.includes(filter));
          return state;
        });
      },
      setRooms: (rooms) => {
        update((state) => {
          console.log("SET ROOMS: COUNT " + rooms.length);
          state.rooms = rooms;
          state.filteredRooms = rooms;
          return state;
        });
      },
    };
  }

  const store$1 = createStore$2();

  function getRoom(token, id, cb, errorCb) {
    axios$1
      .get(`${backend}/rooms/${id}`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function deleteRoom(token, id, cb, errorCb) {
    axios$1
      .delete(`${backend}/rooms/${id}`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }

  function getRooms(token, cb, errorCb) {
    axios$1
      .get(`${backend}/rooms`, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })
      .then((result) => cb(result.data))
      .catch((err) => errorCb(err));
  }
  function updateRoom(token, id, room, cb, errorCb) {
    axios$1
      .put(`${backend}/rooms/${id}`, room, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",

          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data))
      .catch((err) => errorCb(err));
  }
  function createRoom(token, room, cb, errorCb) {
    axios$1
      .post(`${backend}/rooms`, room, {
        mode: "no-cors",
        credentials: "same-origin",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      })
      .then((r) => cb(r.data))
      .catch((err) => errorCb(err));
  }

  /* src/creator/RoomsEditor.svelte generated by Svelte v3.22.3 */

  const { console: console_1$9 } = globals;

  const file$p = "src/creator/RoomsEditor.svelte";

  function get_each_context$7(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[29] = list[i];
  	return child_ctx;
  }

  function get_each_context_1$3(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[32] = list[i];
  	return child_ctx;
  }

  // (228:10) {#if room.area}
  function create_if_block_5(ctx) {
  	let span;
  	let t_value = /*room*/ ctx[32].area + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text(t_value);
  			attr_dev(span, "class", "new badge");
  			attr_dev(span, "data-badge-caption", "");
  			add_location(span, file$p, 228, 12, 4789);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 1 && t_value !== (t_value = /*room*/ ctx[32].area + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_5.name,
  		type: "if",
  		source: "(228:10) {#if room.area}",
  		ctx
  	});

  	return block;
  }

  // (226:6) {#each $store.rooms as room}
  function create_each_block_1$3(ctx) {
  	let a;
  	let t0;
  	let t1_value = /*room*/ ctx[32].name + "";
  	let t1;
  	let t2;
  	let dispose;
  	let if_block = /*room*/ ctx[32].area && create_if_block_5(ctx);

  	const block = {
  		c: function create() {
  			a = element("a");
  			if (if_block) if_block.c();
  			t0 = space();
  			t1 = text(t1_value);
  			t2 = space();
  			attr_dev(a, "href", "#!");
  			attr_dev(a, "class", "collection-item svelte-175a01r");
  			add_location(a, file$p, 226, 8, 4683);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);
  			if (if_block) if_block.m(a, null);
  			append_dev(a, t0);
  			append_dev(a, t1);
  			append_dev(a, t2);
  			if (remount) dispose();

  			dispose = listen_dev(
  				a,
  				"click",
  				function () {
  					if (is_function(/*selectRoom*/ ctx[8](/*room*/ ctx[32]))) /*selectRoom*/ ctx[8](/*room*/ ctx[32]).apply(this, arguments);
  				},
  				false,
  				false,
  				false
  			);
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;

  			if (/*room*/ ctx[32].area) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_5(ctx);
  					if_block.c();
  					if_block.m(a, t0);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (dirty[0] & /*$store*/ 1 && t1_value !== (t1_value = /*room*/ ctx[32].name + "")) set_data_dev(t1, t1_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (if_block) if_block.d();
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_1$3.name,
  		type: "each",
  		source: "(226:6) {#each $store.rooms as room}",
  		ctx
  	});

  	return block;
  }

  // (237:2) {#if $store.selectedRoom}
  function create_if_block$9(ctx) {
  	let div13;
  	let div12;
  	let div0;
  	let span;
  	let t0_value = /*$store*/ ctx[0].selectedRoom.name + "";
  	let t0;
  	let t1;
  	let t2;
  	let div1;
  	let t3;
  	let div3;
  	let div2;
  	let input0;
  	let t4;
  	let label0;
  	let t6;
  	let t7;
  	let div5;
  	let div4;
  	let textarea0;
  	let t8;
  	let label1;
  	let t10;
  	let div7;
  	let div6;
  	let textarea1;
  	let t11;
  	let label2;
  	let t13;
  	let div11;
  	let div8;
  	let input1;
  	let t14;
  	let label3;
  	let t16;
  	let div9;
  	let input2;
  	let t17;
  	let label4;
  	let t19;
  	let div10;
  	let input3;
  	let t20;
  	let label5;
  	let t22;
  	let t23;
  	let current;
  	let dispose;

  	function select_block_type(ctx, dirty) {
  		if (/*$store*/ ctx[0].selectedRoom.isNew) return create_if_block_4$1;
  		return create_else_block_1$2;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block0 = current_block_type(ctx);

  	function select_block_type_1(ctx, dirty) {
  		if (/*$store*/ ctx[0].selectedRoom.isNew) return create_if_block_3$2;
  		return create_else_block$3;
  	}

  	let current_block_type_1 = select_block_type_1(ctx);
  	let if_block1 = current_block_type_1(ctx);
  	let if_block2 = /*$store*/ ctx[0].selectedRoom.coords && create_if_block_2$4(ctx);
  	let if_block3 = /*$store*/ ctx[0].selectedRoom.exits && create_if_block_1$7(ctx);

  	const block = {
  		c: function create() {
  			div13 = element("div");
  			div12 = element("div");
  			div0 = element("div");
  			span = element("span");
  			t0 = text(t0_value);
  			t1 = space();
  			if_block0.c();
  			t2 = space();
  			div1 = element("div");
  			t3 = space();
  			div3 = element("div");
  			div2 = element("div");
  			input0 = element("input");
  			t4 = space();
  			label0 = element("label");
  			label0.textContent = "Name";
  			t6 = space();
  			if_block1.c();
  			t7 = space();
  			div5 = element("div");
  			div4 = element("div");
  			textarea0 = element("textarea");
  			t8 = space();
  			label1 = element("label");
  			label1.textContent = "Description";
  			t10 = space();
  			div7 = element("div");
  			div6 = element("div");
  			textarea1 = element("textarea");
  			t11 = space();
  			label2 = element("label");
  			label2.textContent = "Detail (look)";
  			t13 = space();
  			div11 = element("div");
  			div8 = element("div");
  			input1 = element("input");
  			t14 = space();
  			label3 = element("label");
  			label3.textContent = "Area";
  			t16 = space();
  			div9 = element("div");
  			input2 = element("input");
  			t17 = space();
  			label4 = element("label");
  			label4.textContent = "Area Type";
  			t19 = space();
  			div10 = element("div");
  			input3 = element("input");
  			t20 = space();
  			label5 = element("label");
  			label5.textContent = "Room Type";
  			t22 = space();
  			if (if_block2) if_block2.c();
  			t23 = space();
  			if (if_block3) if_block3.c();
  			attr_dev(span, "class", "header svelte-175a01r");
  			add_location(span, file$p, 243, 10, 5077);
  			attr_dev(div0, "class", "row");
  			add_location(div0, file$p, 241, 8, 5048);
  			attr_dev(div1, "id", "general");
  			add_location(div1, file$p, 268, 8, 5796);
  			attr_dev(input0, "placeholder", "Name");
  			attr_dev(input0, "id", "room_name");
  			attr_dev(input0, "type", "text");
  			attr_dev(input0, "class", "svelte-175a01r");
  			add_location(input0, file$p, 272, 12, 5914);
  			attr_dev(label0, "class", "first_label svelte-175a01r");
  			attr_dev(label0, "for", "room_name");
  			add_location(label0, file$p, 278, 12, 6090);
  			attr_dev(div2, "class", "no-padding input-field col s6 svelte-175a01r");
  			add_location(div2, file$p, 271, 10, 5858);
  			attr_dev(div3, "class", "row");
  			add_location(div3, file$p, 270, 8, 5830);
  			attr_dev(textarea0, "placeholder", "Room Description");
  			attr_dev(textarea0, "id", "room_description");
  			attr_dev(textarea0, "rows", "8");
  			attr_dev(textarea0, "class", "materialize-textarea svelte-175a01r");
  			add_location(textarea0, file$p, 307, 12, 6969);
  			attr_dev(label1, "class", "active svelte-175a01r");
  			attr_dev(label1, "for", "room_description");
  			add_location(label1, file$p, 314, 12, 7224);
  			attr_dev(div4, "class", "input-field");
  			add_location(div4, file$p, 306, 10, 6931);
  			attr_dev(div5, "class", "row");
  			add_location(div5, file$p, 305, 8, 6903);
  			attr_dev(textarea1, "placeholder", "Room Details");
  			attr_dev(textarea1, "id", "room_detail");
  			attr_dev(textarea1, "rows", "4");
  			attr_dev(textarea1, "class", "materialize-textarea svelte-175a01r");
  			add_location(textarea1, file$p, 320, 12, 7396);
  			attr_dev(label2, "class", "active svelte-175a01r");
  			attr_dev(label2, "for", "room_detail");
  			add_location(label2, file$p, 327, 12, 7637);
  			attr_dev(div6, "class", "input-field");
  			add_location(div6, file$p, 319, 10, 7358);
  			attr_dev(div7, "class", "row");
  			add_location(div7, file$p, 318, 8, 7330);
  			attr_dev(input1, "placeholder", "Area");
  			attr_dev(input1, "id", "area");
  			attr_dev(input1, "type", "text");
  			attr_dev(input1, "class", "svelte-175a01r");
  			add_location(input1, file$p, 334, 12, 7825);
  			attr_dev(label3, "class", "active first_label svelte-175a01r");
  			attr_dev(label3, "for", "area");
  			add_location(label3, file$p, 340, 12, 7996);
  			attr_dev(div8, "class", "no-padding input-field col s4 svelte-175a01r");
  			add_location(div8, file$p, 333, 10, 7769);
  			attr_dev(input2, "placeholder", "Area Type");
  			attr_dev(input2, "id", "area_type");
  			attr_dev(input2, "type", "text");
  			attr_dev(input2, "class", "svelte-175a01r");
  			add_location(input2, file$p, 344, 12, 8127);
  			attr_dev(label4, "class", "active svelte-175a01r");
  			attr_dev(label4, "for", "area_type");
  			add_location(label4, file$p, 350, 12, 8312);
  			attr_dev(div9, "class", "input-field col s4");
  			add_location(div9, file$p, 343, 10, 8082);
  			attr_dev(input3, "placeholder", "Room Type");
  			attr_dev(input3, "id", "room_type");
  			attr_dev(input3, "type", "text");
  			attr_dev(input3, "class", "svelte-175a01r");
  			add_location(input3, file$p, 354, 12, 8441);
  			attr_dev(label5, "class", "active svelte-175a01r");
  			attr_dev(label5, "for", "room_type");
  			add_location(label5, file$p, 360, 12, 8626);
  			attr_dev(div10, "class", "input-field col s4");
  			add_location(div10, file$p, 353, 10, 8396);
  			attr_dev(div11, "class", "row");
  			add_location(div11, file$p, 331, 8, 7740);
  			attr_dev(div12, "class", "card-panel cyan darken-4");
  			add_location(div12, file$p, 239, 6, 5000);
  			attr_dev(div13, "class", "col s9");
  			add_location(div13, file$p, 237, 4, 4972);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div13, anchor);
  			append_dev(div13, div12);
  			append_dev(div12, div0);
  			append_dev(div0, span);
  			append_dev(span, t0);
  			append_dev(div0, t1);
  			if_block0.m(div0, null);
  			append_dev(div12, t2);
  			append_dev(div12, div1);
  			append_dev(div12, t3);
  			append_dev(div12, div3);
  			append_dev(div3, div2);
  			append_dev(div2, input0);
  			set_input_value(input0, /*$store*/ ctx[0].selectedRoom.name);
  			append_dev(div2, t4);
  			append_dev(div2, label0);
  			append_dev(div3, t6);
  			if_block1.m(div3, null);
  			append_dev(div12, t7);
  			append_dev(div12, div5);
  			append_dev(div5, div4);
  			append_dev(div4, textarea0);
  			set_input_value(textarea0, /*$store*/ ctx[0].selectedRoom.description);
  			append_dev(div4, t8);
  			append_dev(div4, label1);
  			append_dev(div12, t10);
  			append_dev(div12, div7);
  			append_dev(div7, div6);
  			append_dev(div6, textarea1);
  			set_input_value(textarea1, /*$store*/ ctx[0].selectedRoom.detail);
  			append_dev(div6, t11);
  			append_dev(div6, label2);
  			append_dev(div12, t13);
  			append_dev(div12, div11);
  			append_dev(div11, div8);
  			append_dev(div8, input1);
  			set_input_value(input1, /*$store*/ ctx[0].selectedRoom.area);
  			append_dev(div8, t14);
  			append_dev(div8, label3);
  			append_dev(div11, t16);
  			append_dev(div11, div9);
  			append_dev(div9, input2);
  			set_input_value(input2, /*$store*/ ctx[0].selectedRoom.areaType);
  			append_dev(div9, t17);
  			append_dev(div9, label4);
  			append_dev(div11, t19);
  			append_dev(div11, div10);
  			append_dev(div10, input3);
  			set_input_value(input3, /*$store*/ ctx[0].selectedRoom.roomType);
  			append_dev(div10, t20);
  			append_dev(div10, label5);
  			append_dev(div12, t22);
  			if (if_block2) if_block2.m(div12, null);
  			append_dev(div13, t23);
  			if (if_block3) if_block3.m(div13, null);
  			current = true;
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input0, "input", /*input0_input_handler*/ ctx[18]),
  				listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[21]),
  				listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[22]),
  				listen_dev(input1, "input", /*input1_input_handler*/ ctx[23]),
  				listen_dev(input2, "input", /*input2_input_handler*/ ctx[24]),
  				listen_dev(input3, "input", /*input3_input_handler*/ ctx[25])
  			];
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*$store*/ 1) && t0_value !== (t0_value = /*$store*/ ctx[0].selectedRoom.name + "")) set_data_dev(t0, t0_value);

  			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
  				if_block0.p(ctx, dirty);
  			} else {
  				if_block0.d(1);
  				if_block0 = current_block_type(ctx);

  				if (if_block0) {
  					if_block0.c();
  					if_block0.m(div0, null);
  				}
  			}

  			if (dirty[0] & /*$store*/ 1 && input0.value !== /*$store*/ ctx[0].selectedRoom.name) {
  				set_input_value(input0, /*$store*/ ctx[0].selectedRoom.name);
  			}

  			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
  				if_block1.p(ctx, dirty);
  			} else {
  				if_block1.d(1);
  				if_block1 = current_block_type_1(ctx);

  				if (if_block1) {
  					if_block1.c();
  					if_block1.m(div3, null);
  				}
  			}

  			if (dirty[0] & /*$store*/ 1) {
  				set_input_value(textarea0, /*$store*/ ctx[0].selectedRoom.description);
  			}

  			if (dirty[0] & /*$store*/ 1) {
  				set_input_value(textarea1, /*$store*/ ctx[0].selectedRoom.detail);
  			}

  			if (dirty[0] & /*$store*/ 1 && input1.value !== /*$store*/ ctx[0].selectedRoom.area) {
  				set_input_value(input1, /*$store*/ ctx[0].selectedRoom.area);
  			}

  			if (dirty[0] & /*$store*/ 1 && input2.value !== /*$store*/ ctx[0].selectedRoom.areaType) {
  				set_input_value(input2, /*$store*/ ctx[0].selectedRoom.areaType);
  			}

  			if (dirty[0] & /*$store*/ 1 && input3.value !== /*$store*/ ctx[0].selectedRoom.roomType) {
  				set_input_value(input3, /*$store*/ ctx[0].selectedRoom.roomType);
  			}

  			if (/*$store*/ ctx[0].selectedRoom.coords) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);
  				} else {
  					if_block2 = create_if_block_2$4(ctx);
  					if_block2.c();
  					if_block2.m(div12, null);
  				}
  			} else if (if_block2) {
  				if_block2.d(1);
  				if_block2 = null;
  			}

  			if (/*$store*/ ctx[0].selectedRoom.exits) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[0] & /*$store*/ 1) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block_1$7(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(div13, null);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block3);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block3);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div13);
  			if_block0.d();
  			if_block1.d();
  			if (if_block2) if_block2.d();
  			if (if_block3) if_block3.d();
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$9.name,
  		type: "if",
  		source: "(237:2) {#if $store.selectedRoom}",
  		ctx
  	});

  	return block;
  }

  // (253:10) {:else}
  function create_else_block_1$2(ctx) {
  	let button0;
  	let t1;
  	let button1;
  	let dispose;

  	const block = {
  		c: function create() {
  			button0 = element("button");
  			button0.textContent = "Update";
  			t1 = space();
  			button1 = element("button");
  			button1.textContent = "Delete";
  			attr_dev(button0, "class", "waves-effect waves-light btn-small green right svelte-175a01r");
  			add_location(button0, file$p, 253, 12, 5393);
  			attr_dev(button1, "class", "waves-effect waves-light btn-small red right svelte-175a01r");
  			add_location(button1, file$p, 259, 12, 5581);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, button0, anchor);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, button1, anchor);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(button0, "click", /*click_handler_1*/ ctx[16], false, false, false),
  				listen_dev(button1, "click", /*click_handler_2*/ ctx[17], false, false, false)
  			];
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(button0);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(button1);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_1$2.name,
  		type: "else",
  		source: "(253:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (246:10) {#if $store.selectedRoom.isNew}
  function create_if_block_4$1(ctx) {
  	let button;
  	let dispose;

  	const block = {
  		c: function create() {
  			button = element("button");
  			button.textContent = "Create";
  			attr_dev(button, "class", "waves-effect waves-light btn-small green right svelte-175a01r");
  			add_location(button, file$p, 246, 12, 5187);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, button, anchor);
  			if (remount) dispose();
  			dispose = listen_dev(button, "click", /*click_handler*/ ctx[15], false, false, false);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(button);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_4$1.name,
  		type: "if",
  		source: "(246:10) {#if $store.selectedRoom.isNew}",
  		ctx
  	});

  	return block;
  }

  // (292:10) {:else}
  function create_else_block$3(ctx) {
  	let div;
  	let input;
  	let t0;
  	let label;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			input = element("input");
  			t0 = space();
  			label = element("label");
  			label.textContent = "ID";
  			attr_dev(input, "placeholder", "ID");
  			attr_dev(input, "id", "room_id");
  			attr_dev(input, "type", "text");
  			input.disabled = true;
  			attr_dev(input, "class", "svelte-175a01r");
  			add_location(input, file$p, 293, 14, 6590);
  			attr_dev(label, "class", "active svelte-175a01r");
  			attr_dev(label, "for", "room_id");
  			add_location(label, file$p, 300, 14, 6797);
  			attr_dev(div, "class", "input-field col s6");
  			add_location(div, file$p, 292, 12, 6543);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, input);
  			set_input_value(input, /*$store*/ ctx[0].selectedRoom.id);
  			append_dev(div, t0);
  			append_dev(div, label);
  			if (remount) dispose();
  			dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[20]);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 1 && input.value !== /*$store*/ ctx[0].selectedRoom.id) {
  				set_input_value(input, /*$store*/ ctx[0].selectedRoom.id);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$3.name,
  		type: "else",
  		source: "(292:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (282:10) {#if $store.selectedRoom.isNew}
  function create_if_block_3$2(ctx) {
  	let div;
  	let input;
  	let t0;
  	let label;
  	let dispose;

  	const block = {
  		c: function create() {
  			div = element("div");
  			input = element("input");
  			t0 = space();
  			label = element("label");
  			label.textContent = "ID";
  			attr_dev(input, "placeholder", "ID");
  			attr_dev(input, "id", "room_id");
  			attr_dev(input, "type", "text");
  			attr_dev(input, "class", "svelte-175a01r");
  			add_location(input, file$p, 283, 14, 6265);
  			attr_dev(label, "class", "active svelte-175a01r");
  			attr_dev(label, "for", "room_id");
  			add_location(label, file$p, 289, 14, 6447);
  			attr_dev(div, "class", "input-field col s6");
  			add_location(div, file$p, 282, 12, 6218);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);
  			append_dev(div, input);
  			set_input_value(input, /*$store*/ ctx[0].selectedRoom.id);
  			append_dev(div, t0);
  			append_dev(div, label);
  			if (remount) dispose();
  			dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[19]);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 1 && input.value !== /*$store*/ ctx[0].selectedRoom.id) {
  				set_input_value(input, /*$store*/ ctx[0].selectedRoom.id);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$2.name,
  		type: "if",
  		source: "(282:10) {#if $store.selectedRoom.isNew}",
  		ctx
  	});

  	return block;
  }

  // (365:8) {#if $store.selectedRoom.coords}
  function create_if_block_2$4(ctx) {
  	let div3;
  	let div0;
  	let input0;
  	let t0;
  	let label0;
  	let t2;
  	let div1;
  	let input1;
  	let t3;
  	let label1;
  	let t5;
  	let div2;
  	let input2;
  	let t6;
  	let label2;
  	let dispose;

  	const block = {
  		c: function create() {
  			div3 = element("div");
  			div0 = element("div");
  			input0 = element("input");
  			t0 = space();
  			label0 = element("label");
  			label0.textContent = "X";
  			t2 = space();
  			div1 = element("div");
  			input1 = element("input");
  			t3 = space();
  			label1 = element("label");
  			label1.textContent = "Y";
  			t5 = space();
  			div2 = element("div");
  			input2 = element("input");
  			t6 = space();
  			label2 = element("label");
  			label2.textContent = "Z";
  			attr_dev(input0, "placeholder", "X");
  			attr_dev(input0, "id", "x");
  			attr_dev(input0, "type", "text");
  			attr_dev(input0, "class", "svelte-175a01r");
  			add_location(input0, file$p, 368, 14, 8855);
  			attr_dev(label0, "class", "first_label svelte-175a01r");
  			attr_dev(label0, "for", "x");
  			add_location(label0, file$p, 374, 14, 9036);
  			attr_dev(div0, "class", "no-padding input-field col s2 svelte-175a01r");
  			add_location(div0, file$p, 367, 12, 8797);
  			attr_dev(input1, "placeholder", "Y");
  			attr_dev(input1, "id", "y");
  			attr_dev(input1, "type", "text");
  			attr_dev(input1, "class", "svelte-175a01r");
  			add_location(input1, file$p, 378, 14, 9160);
  			attr_dev(label1, "class", "active svelte-175a01r");
  			attr_dev(label1, "for", "y");
  			add_location(label1, file$p, 384, 14, 9341);
  			attr_dev(div1, "class", "input-field col s2");
  			add_location(div1, file$p, 377, 12, 9113);
  			attr_dev(input2, "placeholder", "Z");
  			attr_dev(input2, "id", "z");
  			attr_dev(input2, "type", "text");
  			attr_dev(input2, "class", "svelte-175a01r");
  			add_location(input2, file$p, 388, 14, 9460);
  			attr_dev(label2, "class", "active svelte-175a01r");
  			attr_dev(label2, "for", "z");
  			add_location(label2, file$p, 394, 14, 9641);
  			attr_dev(div2, "class", "input-field col s2");
  			add_location(div2, file$p, 387, 12, 9413);
  			attr_dev(div3, "class", "row");
  			add_location(div3, file$p, 365, 10, 8766);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div3, anchor);
  			append_dev(div3, div0);
  			append_dev(div0, input0);
  			set_input_value(input0, /*$store*/ ctx[0].selectedRoom.coords.x);
  			append_dev(div0, t0);
  			append_dev(div0, label0);
  			append_dev(div3, t2);
  			append_dev(div3, div1);
  			append_dev(div1, input1);
  			set_input_value(input1, /*$store*/ ctx[0].selectedRoom.coords.y);
  			append_dev(div1, t3);
  			append_dev(div1, label1);
  			append_dev(div3, t5);
  			append_dev(div3, div2);
  			append_dev(div2, input2);
  			set_input_value(input2, /*$store*/ ctx[0].selectedRoom.coords.z);
  			append_dev(div2, t6);
  			append_dev(div2, label2);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input0, "input", /*input0_input_handler_1*/ ctx[26]),
  				listen_dev(input1, "input", /*input1_input_handler_1*/ ctx[27]),
  				listen_dev(input2, "input", /*input2_input_handler_1*/ ctx[28])
  			];
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store*/ 1 && input0.value !== /*$store*/ ctx[0].selectedRoom.coords.x) {
  				set_input_value(input0, /*$store*/ ctx[0].selectedRoom.coords.x);
  			}

  			if (dirty[0] & /*$store*/ 1 && input1.value !== /*$store*/ ctx[0].selectedRoom.coords.y) {
  				set_input_value(input1, /*$store*/ ctx[0].selectedRoom.coords.y);
  			}

  			if (dirty[0] & /*$store*/ 1 && input2.value !== /*$store*/ ctx[0].selectedRoom.coords.z) {
  				set_input_value(input2, /*$store*/ ctx[0].selectedRoom.coords.z);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div3);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$4.name,
  		type: "if",
  		source: "(365:8) {#if $store.selectedRoom.coords}",
  		ctx
  	});

  	return block;
  }

  // (401:6) {#if $store.selectedRoom.exits}
  function create_if_block_1$7(ctx) {
  	let h6;
  	let t1;
  	let ul;
  	let current;
  	let each_value = /*$store*/ ctx[0].selectedRoom.exits;
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  	}

  	const out = i => transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const block = {
  		c: function create() {
  			h6 = element("h6");
  			h6.textContent = "Exits";
  			t1 = space();
  			ul = element("ul");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			add_location(h6, file$p, 401, 8, 9791);
  			attr_dev(ul, "class", "collapsible");
  			add_location(ul, file$p, 402, 8, 9814);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, h6, anchor);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, ul, anchor);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(ul, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*$store, deleteExit*/ 65) {
  				each_value = /*$store*/ ctx[0].selectedRoom.exits;
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$7(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block$7(child_ctx);
  						each_blocks[i].c();
  						transition_in(each_blocks[i], 1);
  						each_blocks[i].m(ul, null);
  					}
  				}

  				group_outros();

  				for (i = each_value.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(h6);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(ul);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$7.name,
  		type: "if",
  		source: "(401:6) {#if $store.selectedRoom.exits}",
  		ctx
  	});

  	return block;
  }

  // (404:10) {#each $store.selectedRoom.exits as exit}
  function create_each_block$7(ctx) {
  	let current;

  	const actioneditor = new ActionEditor({
  			props: {
  				exit: /*exit*/ ctx[29],
  				deleteExit: /*deleteExit*/ ctx[6]
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(actioneditor.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(actioneditor, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const actioneditor_changes = {};
  			if (dirty[0] & /*$store*/ 1) actioneditor_changes.exit = /*exit*/ ctx[29];
  			actioneditor.$set(actioneditor_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(actioneditor.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(actioneditor.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(actioneditor, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$7.name,
  		type: "each",
  		source: "(404:10) {#each $store.selectedRoom.exits as exit}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$u(ctx) {
  	let t0;
  	let div2;
  	let div1;
  	let div0;
  	let t1;
  	let current;

  	const roomstoolbar = new RoomsToolbar({
  			props: {
  				createRoom: /*newRoom*/ ctx[3],
  				addExit: /*createExit*/ ctx[7]
  			},
  			$$inline: true
  		});

  	let each_value_1 = /*$store*/ ctx[0].rooms;
  	validate_each_argument(each_value_1);
  	let each_blocks = [];

  	for (let i = 0; i < each_value_1.length; i += 1) {
  		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  	}

  	let if_block = /*$store*/ ctx[0].selectedRoom && create_if_block$9(ctx);

  	const block = {
  		c: function create() {
  			create_component(roomstoolbar.$$.fragment);
  			t0 = space();
  			div2 = element("div");
  			div1 = element("div");
  			div0 = element("div");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			t1 = space();
  			if (if_block) if_block.c();
  			attr_dev(div0, "class", "collection svelte-175a01r");
  			add_location(div0, file$p, 224, 4, 4615);
  			attr_dev(div1, "class", "col s3");
  			add_location(div1, file$p, 223, 2, 4590);
  			attr_dev(div2, "class", "row");
  			add_location(div2, file$p, 221, 0, 4569);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(roomstoolbar, target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div2, anchor);
  			append_dev(div2, div1);
  			append_dev(div1, div0);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(div0, null);
  			}

  			append_dev(div2, t1);
  			if (if_block) if_block.m(div2, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*selectRoom, $store*/ 257) {
  				each_value_1 = /*$store*/ ctx[0].rooms;
  				validate_each_argument(each_value_1);
  				let i;

  				for (i = 0; i < each_value_1.length; i += 1) {
  					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block_1$3(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(div0, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value_1.length;
  			}

  			if (/*$store*/ ctx[0].selectedRoom) {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty[0] & /*$store*/ 1) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block$9(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(div2, null);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(roomstoolbar.$$.fragment, local);
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(roomstoolbar.$$.fragment, local);
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(roomstoolbar, detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div2);
  			destroy_each(each_blocks, detaching);
  			if (if_block) if_block.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$u.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$u($$self, $$props, $$invalidate) {
  	let $isAuthenticated;
  	let $authToken;
  	let $store;
  	validate_store(store$1, "store");
  	component_subscribe($$self, store$1, $$value => $$invalidate(0, $store = $$value));
  	let { location } = $$props;
  	const { isAuthenticated, authToken } = getAuth();
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(12, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(13, $authToken = value));

  	const loadData = async cb => {
  		if (!$isAuthenticated) return;

  		getRooms(
  			$authToken,
  			rooms => {
  				store$1.setRooms(rooms);
  				if (cb) cb();
  			},
  			err => console.log(err)
  		);
  	};

  	onMount(async () => {
  		document.addEventListener("DOMContentLoaded", function () {
  			var elems = document.querySelectorAll(".collapsible");
  			var instances = M.Collapsible.init(elems);
  		});

  		loadData(() => {
  			selectRoom($store.rooms[0]);
  		});
  	});

  	const newRoom = () => {
  		let newRoom = {
  			name: "New Room",
  			description: "",
  			detail: "",
  			areaType: "",
  			area: "",
  			id: v4(),
  			isNew: true,
  			exits: [],
  			actions: []
  		};

  		selectRoom(newRoom);
  	};

  	const delRoom = async room => {
  		deleteRoom(
  			$authToken,
  			$store.selectedRoom.id,
  			() => {
  				console.log("delete successful.");

  				loadData(() => {
  					store$1.setSelectedRoom($store.rooms[0]);
  				});
  			},
  			() => {
  				console.log("create error.");
  			}
  		);
  	};

  	const create = async () => {
  		createRoom(
  			$authToken,
  			$store.selectedRoom,
  			room => {
  				console.log("create successful.");
  				loadData();
  				set_store_value(store$1, $store.selectedRoom = room, $store);
  			},
  			() => {
  				console.log("create error.");
  			}
  		);
  	};

  	const deleteExit = exit => {
  		store$1.deleteExit(exit);
  	};

  	const createExit = () => {
  		store$1.createExit();
  		M.updateTextFields();
  		var elems = document.querySelectorAll(".collapsible");

  		if (elems != undefined) {
  			var instances = M.Collapsible.init(elems, {});
  		}
  	};

  	const selectRoom = room => {
  		store$1.setSelectedRoom(room, () => {
  			M.updateTextFields();
  			var elems = document.querySelectorAll(".collapsible");

  			if (elems != undefined) {
  				var instances = M.Collapsible.init(elems, {});
  			}

  			M.updateTextFields();

  			// second time to fix the selects
  			setTimeout(
  				function () {
  					var elems = document.querySelectorAll(".collapsible");

  					if (elems != undefined) {
  						var instances = M.Collapsible.init(elems, {});
  					}

  					M.updateTextFields();
  					var textareas = document.querySelectorAll(".materialize-textarea");

  					textareas.forEach(e => {
  						M.textareaAutoResize(e);
  					});
  				},
  				50
  			);

  			var el = document.querySelectorAll(".tabs");
  			var instance = M.Tabs.init(el, {});
  		});

  		var targets = document.querySelectorAll(".autocomplete");

  		const options = {
  			data: {},
  			onAutocomplete(roomName) {
  				console.log(roomName);
  			}
  		};

  		$store.rooms.forEach(value => {
  			options.data[value.name] = null;
  		});

  		var targetInstances = M.Autocomplete.init(targets, options);
  	};

  	const update = () => {
  		updateRoom(
  			$authToken,
  			$store.selectedRoom.id,
  			$store.selectedRoom,
  			() => {
  				console.log("update successful.");
  				loadData();
  			},
  			() => {
  				console.log("update error.");
  			}
  		);
  	};

  	const writable_props = ["location"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<RoomsEditor> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("RoomsEditor", $$slots, []);
  	const click_handler = () => create();
  	const click_handler_1 = () => update();
  	const click_handler_2 = () => delRoom();

  	function input0_input_handler() {
  		$store.selectedRoom.name = this.value;
  		store$1.set($store);
  	}

  	function input_input_handler() {
  		$store.selectedRoom.id = this.value;
  		store$1.set($store);
  	}

  	function input_input_handler_1() {
  		$store.selectedRoom.id = this.value;
  		store$1.set($store);
  	}

  	function textarea0_input_handler() {
  		$store.selectedRoom.description = this.value;
  		store$1.set($store);
  	}

  	function textarea1_input_handler() {
  		$store.selectedRoom.detail = this.value;
  		store$1.set($store);
  	}

  	function input1_input_handler() {
  		$store.selectedRoom.area = this.value;
  		store$1.set($store);
  	}

  	function input2_input_handler() {
  		$store.selectedRoom.areaType = this.value;
  		store$1.set($store);
  	}

  	function input3_input_handler() {
  		$store.selectedRoom.roomType = this.value;
  		store$1.set($store);
  	}

  	function input0_input_handler_1() {
  		$store.selectedRoom.coords.x = this.value;
  		store$1.set($store);
  	}

  	function input1_input_handler_1() {
  		$store.selectedRoom.coords.y = this.value;
  		store$1.set($store);
  	}

  	function input2_input_handler_1() {
  		$store.selectedRoom.coords.z = this.value;
  		store$1.set($store);
  	}

  	$$self.$set = $$props => {
  		if ("location" in $$props) $$invalidate(10, location = $$props.location);
  	};

  	$$self.$capture_state = () => ({
  		ActionEditor,
  		RoomsToolbar,
  		store: store$1,
  		PlusIcon,
  		writable,
  		onMount,
  		getAuth,
  		uuidv4: v4,
  		axios: axios$1,
  		getRoom,
  		deleteRoom,
  		getRooms,
  		updateRoom,
  		createRoom,
  		location,
  		isAuthenticated,
  		authToken,
  		loadData,
  		newRoom,
  		delRoom,
  		create,
  		deleteExit,
  		createExit,
  		selectRoom,
  		update,
  		state,
  		$isAuthenticated,
  		$authToken,
  		$store
  	});

  	$$self.$inject_state = $$props => {
  		if ("location" in $$props) $$invalidate(10, location = $$props.location);
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*$isAuthenticated, $authToken*/ 12288) {
  			 state = {
  				isAuthenticated: $isAuthenticated,
  				authToken: $authToken.slice(0, 20)
  			};
  		}
  	};

  	return [
  		$store,
  		isAuthenticated,
  		authToken,
  		newRoom,
  		delRoom,
  		create,
  		deleteExit,
  		createExit,
  		selectRoom,
  		update,
  		location,
  		state,
  		$isAuthenticated,
  		$authToken,
  		loadData,
  		click_handler,
  		click_handler_1,
  		click_handler_2,
  		input0_input_handler,
  		input_input_handler,
  		input_input_handler_1,
  		textarea0_input_handler,
  		textarea1_input_handler,
  		input1_input_handler,
  		input2_input_handler,
  		input3_input_handler,
  		input0_input_handler_1,
  		input1_input_handler_1,
  		input2_input_handler_1
  	];
  }

  class RoomsEditor extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$u, create_fragment$u, safe_not_equal, { location: 10 }, [-1, -1]);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "RoomsEditor",
  			options,
  			id: create_fragment$u.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*location*/ ctx[10] === undefined && !("location" in props)) {
  			console_1$9.warn("<RoomsEditor> was created without expected prop 'location'");
  		}
  	}

  	get location() {
  		throw new Error("<RoomsEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set location(value) {
  		throw new Error("<RoomsEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  function createSubMenuStore() {
    const { subscribe, set, update} = writable({
      active: false,
      entries: [{ name: "Item1" }],
    });

    return {
      subscribe,
      show: () =>
        update((menu) => {
          menu.active = true;
          return menu;
        }),
      hide: () =>
        update((menu) => {
          menu.active = false;
          return menu;
        }),
      setItems: (items) => {
        update((menu) => {
          menu.entries = items;

          return menu;
        });
      },
    };
  }

  function createUserStore() {
    const { subscribe, set, update } = writable({
      name: "marcus",
      loggedIn: false,
    });

    return {
      subscribe,
      logIn: () =>
        update((user) => {
          user.loggedIn = true;
          return user;
        }),
      logOut: () =>
        update((user) => {
          user.loggedIn = false;
          return user;
        }),
    };
  }

  const user$1 = createUserStore();
  const subMenu = createSubMenuStore();

  /* src/creator/Creator.svelte generated by Svelte v3.22.3 */
  const file$q = "src/creator/Creator.svelte";

  // (53:0) <Router>
  function create_default_slot$4(ctx) {
  	let row;
  	let t0;
  	let t1;
  	let t2;
  	let current;

  	const route0 = new Route({
  			props: { path: "rooms", component: RoomsEditor },
  			$$inline: true
  		});

  	const route1 = new Route({
  			props: { path: "items", component: ItemsEditor },
  			$$inline: true
  		});

  	const route2 = new Route({
  			props: { path: "world", component: WorldEditor },
  			$$inline: true
  		});

  	const route3 = new Route({
  			props: {
  				path: "item-templates",
  				component: SampleEditor
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			row = element("row");
  			create_component(route0.$$.fragment);
  			t0 = space();
  			create_component(route1.$$.fragment);
  			t1 = space();
  			create_component(route2.$$.fragment);
  			t2 = space();
  			create_component(route3.$$.fragment);
  			add_location(row, file$q, 53, 2, 1135);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, row, anchor);
  			mount_component(route0, row, null);
  			append_dev(row, t0);
  			mount_component(route1, row, null);
  			append_dev(row, t1);
  			mount_component(route2, row, null);
  			append_dev(row, t2);
  			mount_component(route3, row, null);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(route0.$$.fragment, local);
  			transition_in(route1.$$.fragment, local);
  			transition_in(route2.$$.fragment, local);
  			transition_in(route3.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(route0.$$.fragment, local);
  			transition_out(route1.$$.fragment, local);
  			transition_out(route2.$$.fragment, local);
  			transition_out(route3.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(row);
  			destroy_component(route0);
  			destroy_component(route1);
  			destroy_component(route2);
  			destroy_component(route3);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$4.name,
  		type: "slot",
  		source: "(53:0) <Router>",
  		ctx
  	});

  	return block;
  }

  function create_fragment$v(ctx) {
  	let current;

  	const router = new Router({
  			props: {
  				$$slots: { default: [create_default_slot$4] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(router.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(router, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const router_changes = {};

  			if (dirty & /*$$scope*/ 1) {
  				router_changes.$$scope = { dirty, ctx };
  			}

  			router.$set(router_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(router.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(router.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(router, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$v.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$v($$self, $$props, $$invalidate) {
  	onMount(async () => {
  		var elems = document.querySelectorAll(".tabs");
  		let instance = M.Tabs.init(elems);
  		document.body.style.backgroundImage = "";

  		subMenu.setItems([
  			{ name: "ROOMS", nav: "creator/rooms" },
  			{ name: "ITEMS", nav: "creator/items" },
  			{
  				name: "ITEM TEMPLATES",
  				nav: "creator/item-templates"
  			},
  			{ name: "WORLD", nav: "creator/world" }
  		]);

  		subMenu.show();
  	});

  	onDestroy(async () => {
  		subMenu.hide();
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Creator> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Creator", $$slots, []);

  	$$self.$capture_state = () => ({
  		ItemsEditor,
  		SampleEditor,
  		ItemTemplatesEditor,
  		WorldEditor,
  		RoomsEditor,
  		Router,
  		Route,
  		writable,
  		onMount,
  		onDestroy,
  		subMenu,
  		axios: axios$1
  	});

  	return [];
  }

  class Creator extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Creator",
  			options,
  			id: create_fragment$v.name
  		});
  	}
  }

  /* src/characters/CharacterScore.svelte generated by Svelte v3.22.3 */
  const file$r = "src/characters/CharacterScore.svelte";

  function create_fragment$w(ctx) {
  	let div1;
  	let div0;
  	let img;
  	let img_src_value;
  	let t0;
  	let span0;
  	let t1;
  	let t2;
  	let t3;
  	let span1;
  	let t4;
  	let t5;
  	let t6;
  	let t7_value = /*cclass*/ ctx[2].name + "";
  	let t7;
  	let t8;
  	let span2;
  	let t9;

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			div0 = element("div");
  			img = element("img");
  			t0 = space();
  			span0 = element("span");
  			t1 = text(/*xp*/ ctx[3]);
  			t2 = text(" XP");
  			t3 = space();
  			span1 = element("span");
  			t4 = text("LVL ");
  			t5 = text(/*level*/ ctx[1]);
  			t6 = text(" - ");
  			t7 = text(t7_value);
  			t8 = space();
  			span2 = element("span");
  			t9 = text(/*name*/ ctx[0]);
  			if (img.src !== (img_src_value = /*avatar*/ ctx[4]())) attr_dev(img, "src", img_src_value);
  			attr_dev(img, "alt", "");
  			attr_dev(img, "class", "circle img z-depth-2 svelte-1elv10p");
  			add_location(img, file$r, 40, 4, 784);
  			attr_dev(span0, "class", "card-title svelte-1elv10p");
  			add_location(span0, file$r, 42, 4, 850);
  			attr_dev(span1, "class", "card-title svelte-1elv10p");
  			add_location(span1, file$r, 43, 4, 894);
  			attr_dev(span2, "class", "card-content");
  			add_location(span2, file$r, 44, 4, 958);
  			attr_dev(div0, "class", "card-content white-text");
  			add_location(div0, file$r, 38, 2, 741);
  			attr_dev(div1, "class", "card cyan darken-3 hoverable characterCard center-align svelte-1elv10p");
  			add_location(div1, file$r, 37, 0, 669);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			append_dev(div1, div0);
  			append_dev(div0, img);
  			append_dev(div0, t0);
  			append_dev(div0, span0);
  			append_dev(span0, t1);
  			append_dev(span0, t2);
  			append_dev(div0, t3);
  			append_dev(div0, span1);
  			append_dev(span1, t4);
  			append_dev(span1, t5);
  			append_dev(span1, t6);
  			append_dev(span1, t7);
  			append_dev(div0, t8);
  			append_dev(div0, span2);
  			append_dev(span2, t9);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*xp*/ 8) set_data_dev(t1, /*xp*/ ctx[3]);
  			if (dirty & /*level*/ 2) set_data_dev(t5, /*level*/ ctx[1]);
  			if (dirty & /*cclass*/ 4 && t7_value !== (t7_value = /*cclass*/ ctx[2].name + "")) set_data_dev(t7, t7_value);
  			if (dirty & /*name*/ 1) set_data_dev(t9, /*name*/ ctx[0]);
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$w.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$w($$self, $$props, $$invalidate) {
  	let { name } = $$props;
  	let { level } = $$props;
  	let { cclass } = $$props;
  	let { xp } = $$props;

  	function formattedDate() {
  		return moment(created).format("MMMM Do YYYY, h:mm:ss a");
  	}

  	function avatar() {
  		let num = 1 + Math.abs(name.hashCode() % 12);
  		return "img/avatars/" + num + "p.png";
  	}

  	const writable_props = ["name", "level", "cclass", "xp"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharacterScore> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("CharacterScore", $$slots, []);

  	$$self.$set = $$props => {
  		if ("name" in $$props) $$invalidate(0, name = $$props.name);
  		if ("level" in $$props) $$invalidate(1, level = $$props.level);
  		if ("cclass" in $$props) $$invalidate(2, cclass = $$props.cclass);
  		if ("xp" in $$props) $$invalidate(3, xp = $$props.xp);
  	};

  	$$self.$capture_state = () => ({
  		MediaQuery: MediaQuery$1,
  		fade,
  		moment,
  		name,
  		level,
  		cclass,
  		xp,
  		formattedDate,
  		avatar
  	});

  	$$self.$inject_state = $$props => {
  		if ("name" in $$props) $$invalidate(0, name = $$props.name);
  		if ("level" in $$props) $$invalidate(1, level = $$props.level);
  		if ("cclass" in $$props) $$invalidate(2, cclass = $$props.cclass);
  		if ("xp" in $$props) $$invalidate(3, xp = $$props.xp);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [name, level, cclass, xp, avatar];
  }

  class CharacterScore extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$w, create_fragment$w, safe_not_equal, { name: 0, level: 1, cclass: 2, xp: 3 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "CharacterScore",
  			options,
  			id: create_fragment$w.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*name*/ ctx[0] === undefined && !("name" in props)) {
  			console.warn("<CharacterScore> was created without expected prop 'name'");
  		}

  		if (/*level*/ ctx[1] === undefined && !("level" in props)) {
  			console.warn("<CharacterScore> was created without expected prop 'level'");
  		}

  		if (/*cclass*/ ctx[2] === undefined && !("cclass" in props)) {
  			console.warn("<CharacterScore> was created without expected prop 'cclass'");
  		}

  		if (/*xp*/ ctx[3] === undefined && !("xp" in props)) {
  			console.warn("<CharacterScore> was created without expected prop 'xp'");
  		}
  	}

  	get name() {
  		throw new Error("<CharacterScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set name(value) {
  		throw new Error("<CharacterScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get level() {
  		throw new Error("<CharacterScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set level(value) {
  		throw new Error("<CharacterScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get cclass() {
  		throw new Error("<CharacterScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set cclass(value) {
  		throw new Error("<CharacterScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xp() {
  		throw new Error("<CharacterScore>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xp(value) {
  		throw new Error("<CharacterScore>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/characters/Characters.svelte generated by Svelte v3.22.3 */

  const { console: console_1$a } = globals;
  const file$s = "src/characters/Characters.svelte";

  function get_each_context$8(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[16] = list[i];
  	return child_ctx;
  }

  function get_each_context_1$4(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[16] = list[i];
  	return child_ctx;
  }

  // (57:4) {#each topTen as character}
  function create_each_block_1$4(ctx) {
  	let div;
  	let t;
  	let current;

  	const characterscore = new CharacterScore({
  			props: {
  				name: /*character*/ ctx[16].name,
  				level: /*character*/ ctx[16].level,
  				xp: /*character*/ ctx[16].xp,
  				cclass: /*character*/ ctx[16].class
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			div = element("div");
  			create_component(characterscore.$$.fragment);
  			t = space();
  			attr_dev(div, "class", "col s3");
  			add_location(div, file$s, 57, 6, 1127);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			mount_component(characterscore, div, null);
  			append_dev(div, t);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const characterscore_changes = {};
  			if (dirty & /*topTen*/ 2) characterscore_changes.name = /*character*/ ctx[16].name;
  			if (dirty & /*topTen*/ 2) characterscore_changes.level = /*character*/ ctx[16].level;
  			if (dirty & /*topTen*/ 2) characterscore_changes.xp = /*character*/ ctx[16].xp;
  			if (dirty & /*topTen*/ 2) characterscore_changes.cclass = /*character*/ ctx[16].class;
  			characterscore.$set(characterscore_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(characterscore.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(characterscore.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			destroy_component(characterscore);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_1$4.name,
  		type: "each",
  		source: "(57:4) {#each topTen as character}",
  		ctx
  	});

  	return block;
  }

  // (83:8) {#each data as character}
  function create_each_block$8(ctx) {
  	let tr;
  	let td0;
  	let t0_value = /*character*/ ctx[16].level + "";
  	let t0;
  	let t1;
  	let td1;
  	let t2_value = /*character*/ ctx[16].name + "";
  	let t2;
  	let t3;
  	let td2;
  	let t4_value = /*character*/ ctx[16].class.name + "";
  	let t4;
  	let t5;
  	let td3;
  	let t6_value = /*character*/ ctx[16].description + "";
  	let t6;
  	let t7;
  	let td4;
  	let t8_value = /*character*/ ctx[16].xp + "";
  	let t8;
  	let t9;

  	const block = {
  		c: function create() {
  			tr = element("tr");
  			td0 = element("td");
  			t0 = text(t0_value);
  			t1 = space();
  			td1 = element("td");
  			t2 = text(t2_value);
  			t3 = space();
  			td2 = element("td");
  			t4 = text(t4_value);
  			t5 = space();
  			td3 = element("td");
  			t6 = text(t6_value);
  			t7 = space();
  			td4 = element("td");
  			t8 = text(t8_value);
  			t9 = space();
  			add_location(td0, file$s, 84, 12, 1635);
  			add_location(td1, file$s, 85, 12, 1674);
  			add_location(td2, file$s, 86, 12, 1712);
  			add_location(td3, file$s, 87, 12, 1756);
  			add_location(td4, file$s, 88, 12, 1801);
  			add_location(tr, file$s, 83, 10, 1618);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, tr, anchor);
  			append_dev(tr, td0);
  			append_dev(td0, t0);
  			append_dev(tr, t1);
  			append_dev(tr, td1);
  			append_dev(td1, t2);
  			append_dev(tr, t3);
  			append_dev(tr, td2);
  			append_dev(td2, t4);
  			append_dev(tr, t5);
  			append_dev(tr, td3);
  			append_dev(td3, t6);
  			append_dev(tr, t7);
  			append_dev(tr, td4);
  			append_dev(td4, t8);
  			append_dev(tr, t9);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*character*/ ctx[16].level + "")) set_data_dev(t0, t0_value);
  			if (dirty & /*data*/ 1 && t2_value !== (t2_value = /*character*/ ctx[16].name + "")) set_data_dev(t2, t2_value);
  			if (dirty & /*data*/ 1 && t4_value !== (t4_value = /*character*/ ctx[16].class.name + "")) set_data_dev(t4, t4_value);
  			if (dirty & /*data*/ 1 && t6_value !== (t6_value = /*character*/ ctx[16].description + "")) set_data_dev(t6, t6_value);
  			if (dirty & /*data*/ 1 && t8_value !== (t8_value = /*character*/ ctx[16].xp + "")) set_data_dev(t8, t8_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(tr);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$8.name,
  		type: "each",
  		source: "(83:8) {#each data as character}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$x(ctx) {
  	let div2;
  	let div0;
  	let t0;
  	let div1;
  	let table;
  	let thead;
  	let tr;
  	let th0;
  	let t2;
  	let th1;
  	let t4;
  	let th2;
  	let t6;
  	let th3;
  	let t8;
  	let th4;
  	let t10;
  	let tbody;
  	let current;
  	let each_value_1 = /*topTen*/ ctx[1];
  	validate_each_argument(each_value_1);
  	let each_blocks_1 = [];

  	for (let i = 0; i < each_value_1.length; i += 1) {
  		each_blocks_1[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
  	}

  	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
  		each_blocks_1[i] = null;
  	});

  	let each_value = /*data*/ ctx[0];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			div2 = element("div");
  			div0 = element("div");

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].c();
  			}

  			t0 = space();
  			div1 = element("div");
  			table = element("table");
  			thead = element("thead");
  			tr = element("tr");
  			th0 = element("th");
  			th0.textContent = "Level";
  			t2 = space();
  			th1 = element("th");
  			th1.textContent = "Name";
  			t4 = space();
  			th2 = element("th");
  			th2.textContent = "Class";
  			t6 = space();
  			th3 = element("th");
  			th3.textContent = "Description";
  			t8 = space();
  			th4 = element("th");
  			th4.textContent = "XP";
  			t10 = space();
  			tbody = element("tbody");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			attr_dev(div0, "class", "row");
  			add_location(div0, file$s, 54, 2, 1070);
  			add_location(th0, file$s, 73, 10, 1413);
  			add_location(th1, file$s, 74, 10, 1438);
  			add_location(th2, file$s, 75, 10, 1462);
  			add_location(th3, file$s, 76, 10, 1487);
  			add_location(th4, file$s, 77, 10, 1518);
  			add_location(tr, file$s, 72, 8, 1398);
  			add_location(thead, file$s, 71, 6, 1382);
  			add_location(tbody, file$s, 81, 6, 1566);
  			add_location(table, file$s, 70, 4, 1368);
  			add_location(div1, file$s, 68, 2, 1357);
  			add_location(div2, file$s, 52, 0, 1061);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div2, anchor);
  			append_dev(div2, div0);

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				each_blocks_1[i].m(div0, null);
  			}

  			append_dev(div2, t0);
  			append_dev(div2, div1);
  			append_dev(div1, table);
  			append_dev(table, thead);
  			append_dev(thead, tr);
  			append_dev(tr, th0);
  			append_dev(tr, t2);
  			append_dev(tr, th1);
  			append_dev(tr, t4);
  			append_dev(tr, th2);
  			append_dev(tr, t6);
  			append_dev(tr, th3);
  			append_dev(tr, t8);
  			append_dev(tr, th4);
  			append_dev(table, t10);
  			append_dev(table, tbody);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(tbody, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*topTen*/ 2) {
  				each_value_1 = /*topTen*/ ctx[1];
  				validate_each_argument(each_value_1);
  				let i;

  				for (i = 0; i < each_value_1.length; i += 1) {
  					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

  					if (each_blocks_1[i]) {
  						each_blocks_1[i].p(child_ctx, dirty);
  						transition_in(each_blocks_1[i], 1);
  					} else {
  						each_blocks_1[i] = create_each_block_1$4(child_ctx);
  						each_blocks_1[i].c();
  						transition_in(each_blocks_1[i], 1);
  						each_blocks_1[i].m(div0, null);
  					}
  				}

  				group_outros();

  				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}

  			if (dirty & /*data*/ 1) {
  				each_value = /*data*/ ctx[0];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$8(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block$8(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(tbody, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value_1.length; i += 1) {
  				transition_in(each_blocks_1[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			each_blocks_1 = each_blocks_1.filter(Boolean);

  			for (let i = 0; i < each_blocks_1.length; i += 1) {
  				transition_out(each_blocks_1[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div2);
  			destroy_each(each_blocks_1, detaching);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$x.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$x($$self, $$props, $$invalidate) {
  	let $isLoading;
  	let $isAuthenticated;
  	let $authError;
  	let $userInfo;
  	let $authToken;
  	let data = [];
  	let topTen = [];
  	const { isLoading, isAuthenticated, login, logout, authToken, authError, userInfo } = getAuth();
  	validate_store(isLoading, "isLoading");
  	component_subscribe($$self, isLoading, value => $$invalidate(8, $isLoading = value));
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(9, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(12, $authToken = value));
  	validate_store(authError, "authError");
  	component_subscribe($$self, authError, value => $$invalidate(10, $authError = value));
  	validate_store(userInfo, "userInfo");
  	component_subscribe($$self, userInfo, value => $$invalidate(11, $userInfo = value));

  	const loadData = async () => {
  		if ($isLoading && !$isAuthenticated) return;

  		getCharacters(
  			$authToken,
  			characters => {
  				$$invalidate(0, data = characters.slice(0, 100));
  				$$invalidate(1, topTen = characters.slice(0, 8));
  			},
  			err => console.log(err)
  		);
  	};

  	onMount(async () => {
  		await loadData();
  		console.log("Finished loading characters");
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<Characters> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Characters", $$slots, []);

  	$$self.$capture_state = () => ({
  		CharacterScore,
  		onMount,
  		createAuth,
  		getAuth,
  		axios: axios$1,
  		onInterval,
  		getCharacters,
  		data,
  		topTen,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		authError,
  		userInfo,
  		loadData,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken
  	});

  	$$self.$inject_state = $$props => {
  		if ("data" in $$props) $$invalidate(0, data = $$props.data);
  		if ("topTen" in $$props) $$invalidate(1, topTen = $$props.topTen);
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isLoading, $isAuthenticated, $authError, $userInfo, $authToken*/ 7936) {
  			 state = {
  				isLoading: $isLoading,
  				isAuthenticated: $isAuthenticated,
  				authError: $authError,
  				userInfo: $userInfo ? $userInfo.name : null,
  				authToken: $authToken.slice(0, 20)
  			};
  		}
  	};

  	return [data, topTen, isLoading, isAuthenticated, authToken, authError, userInfo];
  }

  class Characters extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Characters",
  			options,
  			id: create_fragment$x.name
  		});
  	}
  }

  /* src/UserForm.svelte generated by Svelte v3.22.3 */

  const { console: console_1$b } = globals;
  const file$t = "src/UserForm.svelte";

  function create_fragment$y(ctx) {
  	let div10;
  	let h3;
  	let t1;
  	let form;
  	let div1;
  	let div0;
  	let input0;
  	let t2;
  	let label0;
  	let t4;
  	let div3;
  	let div2;
  	let input1;
  	let t5;
  	let label1;
  	let t7;
  	let div5;
  	let div4;
  	let input2;
  	let t8;
  	let label2;
  	let t10;
  	let div7;
  	let div6;
  	let input3;
  	let t11;
  	let label3;
  	let t13;
  	let div9;
  	let div8;
  	let button;
  	let t14;
  	let i;
  	let dispose;

  	const block = {
  		c: function create() {
  			div10 = element("div");
  			h3 = element("h3");
  			h3.textContent = "Your Account data";
  			t1 = space();
  			form = element("form");
  			div1 = element("div");
  			div0 = element("div");
  			input0 = element("input");
  			t2 = space();
  			label0 = element("label");
  			label0.textContent = "Reference ID";
  			t4 = space();
  			div3 = element("div");
  			div2 = element("div");
  			input1 = element("input");
  			t5 = space();
  			label1 = element("label");
  			label1.textContent = "Name";
  			t7 = space();
  			div5 = element("div");
  			div4 = element("div");
  			input2 = element("input");
  			t8 = space();
  			label2 = element("label");
  			label2.textContent = "Nickname";
  			t10 = space();
  			div7 = element("div");
  			div6 = element("div");
  			input3 = element("input");
  			t11 = space();
  			label3 = element("label");
  			label3.textContent = "E-Mail";
  			t13 = space();
  			div9 = element("div");
  			div8 = element("div");
  			button = element("button");
  			t14 = text("Submit\n        ");
  			i = element("i");
  			i.textContent = "send";
  			add_location(h3, file$t, 69, 2, 1186);
  			attr_dev(input0, "id", "refid");
  			attr_dev(input0, "type", "text");
  			input0.disabled = true;
  			attr_dev(input0, "class", "svelte-10o4r89");
  			add_location(input0, file$t, 74, 8, 1309);
  			attr_dev(label0, "id", "refidlabel");
  			attr_dev(label0, "for", "refid");
  			attr_dev(label0, "class", "active svelte-10o4r89");
  			add_location(label0, file$t, 75, 8, 1386);
  			attr_dev(div0, "class", "input-field col s12");
  			add_location(div0, file$t, 73, 6, 1267);
  			attr_dev(div1, "class", "row");
  			add_location(div1, file$t, 72, 4, 1243);
  			attr_dev(input1, "id", "username");
  			attr_dev(input1, "type", "text");
  			attr_dev(input1, "class", "validate svelte-10o4r89");
  			add_location(input1, file$t, 81, 8, 1552);
  			attr_dev(label1, "for", "username");
  			attr_dev(label1, "class", "active");
  			add_location(label1, file$t, 87, 8, 1687);
  			attr_dev(div2, "class", "input-field col s12");
  			add_location(div2, file$t, 80, 6, 1510);
  			attr_dev(div3, "class", "row");
  			add_location(div3, file$t, 79, 4, 1486);
  			attr_dev(input2, "id", "usernickname");
  			attr_dev(input2, "type", "text");
  			attr_dev(input2, "class", "validate svelte-10o4r89");
  			add_location(input2, file$t, 92, 8, 1831);
  			attr_dev(label2, "for", "usernickname");
  			attr_dev(label2, "class", "active");
  			add_location(label2, file$t, 98, 8, 1974);
  			attr_dev(div4, "class", "input-field col s12");
  			add_location(div4, file$t, 91, 6, 1789);
  			attr_dev(div5, "class", "row");
  			add_location(div5, file$t, 90, 4, 1765);
  			attr_dev(input3, "id", "useremail");
  			attr_dev(input3, "type", "text");
  			attr_dev(input3, "class", "validate svelte-10o4r89");
  			add_location(input3, file$t, 103, 8, 2126);
  			attr_dev(label3, "for", "useremail");
  			attr_dev(label3, "class", "active");
  			add_location(label3, file$t, 109, 8, 2263);
  			attr_dev(div6, "class", "input-field col s12");
  			add_location(div6, file$t, 102, 6, 2084);
  			attr_dev(div7, "class", "row");
  			add_location(div7, file$t, 101, 4, 2060);
  			attr_dev(form, "class", "col s12");
  			add_location(form, file$t, 70, 2, 1215);
  			attr_dev(i, "class", "material-icons right");
  			add_location(i, file$t, 121, 8, 2541);
  			attr_dev(button, "class", "btn waves-effect waves-light");
  			add_location(button, file$t, 116, 6, 2415);
  			attr_dev(div8, "class", "input-field col s12");
  			add_location(div8, file$t, 115, 4, 2375);
  			attr_dev(div9, "class", "row");
  			add_location(div9, file$t, 114, 2, 2353);
  			attr_dev(div10, "class", "row");
  			add_location(div10, file$t, 68, 0, 1166);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div10, anchor);
  			append_dev(div10, h3);
  			append_dev(div10, t1);
  			append_dev(div10, form);
  			append_dev(form, div1);
  			append_dev(div1, div0);
  			append_dev(div0, input0);
  			set_input_value(input0, /*$user*/ ctx[0].refid);
  			append_dev(div0, t2);
  			append_dev(div0, label0);
  			append_dev(form, t4);
  			append_dev(form, div3);
  			append_dev(div3, div2);
  			append_dev(div2, input1);
  			set_input_value(input1, /*$user*/ ctx[0].name);
  			append_dev(div2, t5);
  			append_dev(div2, label1);
  			append_dev(form, t7);
  			append_dev(form, div5);
  			append_dev(div5, div4);
  			append_dev(div4, input2);
  			set_input_value(input2, /*$user*/ ctx[0].nickname);
  			append_dev(div4, t8);
  			append_dev(div4, label2);
  			append_dev(form, t10);
  			append_dev(form, div7);
  			append_dev(div7, div6);
  			append_dev(div6, input3);
  			set_input_value(input3, /*$user*/ ctx[0].email);
  			append_dev(div6, t11);
  			append_dev(div6, label3);
  			append_dev(div10, t13);
  			append_dev(div10, div9);
  			append_dev(div9, div8);
  			append_dev(div8, button);
  			append_dev(button, t14);
  			append_dev(button, i);
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input0, "input", /*input0_input_handler*/ ctx[16]),
  				listen_dev(input1, "input", /*input1_input_handler*/ ctx[17]),
  				listen_dev(input2, "input", /*input2_input_handler*/ ctx[18]),
  				listen_dev(input3, "input", /*input3_input_handler*/ ctx[19]),
  				listen_dev(button, "click", /*click_handler*/ ctx[20], false, false, false)
  			];
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*$user*/ 1 && input0.value !== /*$user*/ ctx[0].refid) {
  				set_input_value(input0, /*$user*/ ctx[0].refid);
  			}

  			if (dirty & /*$user*/ 1 && input1.value !== /*$user*/ ctx[0].name) {
  				set_input_value(input1, /*$user*/ ctx[0].name);
  			}

  			if (dirty & /*$user*/ 1 && input2.value !== /*$user*/ ctx[0].nickname) {
  				set_input_value(input2, /*$user*/ ctx[0].nickname);
  			}

  			if (dirty & /*$user*/ 1 && input3.value !== /*$user*/ ctx[0].email) {
  				set_input_value(input3, /*$user*/ ctx[0].email);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div10);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$y.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$y($$self, $$props, $$invalidate) {
  	let $isLoading;
  	let $isAuthenticated;
  	let $authError;
  	let $userInfo;
  	let $authToken;
  	let $user;
  	let user = writable({});
  	validate_store(user, "user");
  	component_subscribe($$self, user, value => $$invalidate(0, $user = value));
  	const { isLoading, isAuthenticated, login, logout, authToken, authError, userInfo } = getAuth();
  	validate_store(isLoading, "isLoading");
  	component_subscribe($$self, isLoading, value => $$invalidate(9, $isLoading = value));
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(10, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(13, $authToken = value));
  	validate_store(authError, "authError");
  	component_subscribe($$self, authError, value => $$invalidate(11, $authError = value));
  	validate_store(userInfo, "userInfo");
  	component_subscribe($$self, userInfo, value => $$invalidate(12, $userInfo = value));

  	async function handleSubmit(event) {
  		if ($isAuthenticated) {
  			updateUser($authToken, $user, () => {
  				console.log("user updated ");
  			});
  		}
  	}

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<UserForm> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("UserForm", $$slots, []);

  	function input0_input_handler() {
  		$user.refid = this.value;
  		user.set($user);
  	}

  	function input1_input_handler() {
  		$user.name = this.value;
  		user.set($user);
  	}

  	function input2_input_handler() {
  		$user.nickname = this.value;
  		user.set($user);
  	}

  	function input3_input_handler() {
  		$user.email = this.value;
  		user.set($user);
  	}

  	const click_handler = () => handleSubmit();

  	$$self.$capture_state = () => ({
  		writable,
  		onMount,
  		createAuth,
  		getAuth,
  		axios: axios$1,
  		onInterval,
  		getUser,
  		updateUser,
  		user,
  		isLoading,
  		isAuthenticated,
  		login,
  		logout,
  		authToken,
  		authError,
  		userInfo,
  		handleSubmit,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken,
  		$user
  	});

  	$$self.$inject_state = $$props => {
  		if ("user" in $$props) $$invalidate(1, user = $$props.user);
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isLoading, $isAuthenticated, $authError, $userInfo, $authToken*/ 15872) {
  			 state = {
  				isLoading: $isLoading,
  				isAuthenticated: $isAuthenticated,
  				authError: $authError,
  				userInfo: $userInfo ? $userInfo.name : null,
  				authToken: $authToken.slice(0, 20),
  				user
  			};
  		}

  		if ($$self.$$.dirty & /*$authToken*/ 8192) {
  			 {
  				getUser(
  					$authToken,
  					u => {
  						user.set(u);
  					},
  					err => console.log(err)
  				);
  			}
  		}
  	};

  	return [
  		$user,
  		user,
  		isLoading,
  		isAuthenticated,
  		authToken,
  		authError,
  		userInfo,
  		handleSubmit,
  		state,
  		$isLoading,
  		$isAuthenticated,
  		$authError,
  		$userInfo,
  		$authToken,
  		login,
  		logout,
  		input0_input_handler,
  		input1_input_handler,
  		input2_input_handler,
  		input3_input_handler,
  		click_handler
  	];
  }

  class UserForm extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "UserForm",
  			options,
  			id: create_fragment$y.name
  		});
  	}
  }

  /* src/AppContent.svelte generated by Svelte v3.22.3 */

  // (21:0) <Route path="play" component="{Game}">
  function create_default_slot_1$1(ctx) {
  	let current;
  	const game = new Game({ $$inline: true });

  	const block = {
  		c: function create() {
  			create_component(game.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(game, target, anchor);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(game.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(game.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(game, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1$1.name,
  		type: "slot",
  		source: "(21:0) <Route path=\\\"play\\\" component=\\\"{Game}\\\">",
  		ctx
  	});

  	return block;
  }

  // (24:0) <Route path="/">
  function create_default_slot$5(ctx) {
  	let current;
  	const welcome = new Welcome({ $$inline: true });

  	const block = {
  		c: function create() {
  			create_component(welcome.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(welcome, target, anchor);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(welcome.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(welcome.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(welcome, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$5.name,
  		type: "slot",
  		source: "(24:0) <Route path=\\\"/\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$z(ctx) {
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let current;

  	const route0 = new Route({
  			props: { path: "account", component: UserForm },
  			$$inline: true
  		});

  	const route1 = new Route({
  			props: { path: "creator/*", component: Creator },
  			$$inline: true
  		});

  	const route2 = new Route({
  			props: { path: "list", component: Characters },
  			$$inline: true
  		});

  	const route3 = new Route({
  			props: { path: "credits", component: Credits },
  			$$inline: true
  		});

  	const route4 = new Route({
  			props: {
  				path: "play",
  				component: Game,
  				$$slots: { default: [create_default_slot_1$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const route5 = new Route({
  			props: {
  				path: "/",
  				$$slots: { default: [create_default_slot$5] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(route0.$$.fragment);
  			t0 = space();
  			create_component(route1.$$.fragment);
  			t1 = space();
  			create_component(route2.$$.fragment);
  			t2 = space();
  			create_component(route3.$$.fragment);
  			t3 = space();
  			create_component(route4.$$.fragment);
  			t4 = space();
  			create_component(route5.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(route0, target, anchor);
  			insert_dev(target, t0, anchor);
  			mount_component(route1, target, anchor);
  			insert_dev(target, t1, anchor);
  			mount_component(route2, target, anchor);
  			insert_dev(target, t2, anchor);
  			mount_component(route3, target, anchor);
  			insert_dev(target, t3, anchor);
  			mount_component(route4, target, anchor);
  			insert_dev(target, t4, anchor);
  			mount_component(route5, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const route4_changes = {};

  			if (dirty & /*$$scope*/ 1) {
  				route4_changes.$$scope = { dirty, ctx };
  			}

  			route4.$set(route4_changes);
  			const route5_changes = {};

  			if (dirty & /*$$scope*/ 1) {
  				route5_changes.$$scope = { dirty, ctx };
  			}

  			route5.$set(route5_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(route0.$$.fragment, local);
  			transition_in(route1.$$.fragment, local);
  			transition_in(route2.$$.fragment, local);
  			transition_in(route3.$$.fragment, local);
  			transition_in(route4.$$.fragment, local);
  			transition_in(route5.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(route0.$$.fragment, local);
  			transition_out(route1.$$.fragment, local);
  			transition_out(route2.$$.fragment, local);
  			transition_out(route3.$$.fragment, local);
  			transition_out(route4.$$.fragment, local);
  			transition_out(route5.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(route0, detaching);
  			if (detaching) detach_dev(t0);
  			destroy_component(route1, detaching);
  			if (detaching) detach_dev(t1);
  			destroy_component(route2, detaching);
  			if (detaching) detach_dev(t2);
  			destroy_component(route3, detaching);
  			if (detaching) detach_dev(t3);
  			destroy_component(route4, detaching);
  			if (detaching) detach_dev(t4);
  			destroy_component(route5, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$z.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$z($$self, $$props, $$invalidate) {
  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AppContent> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("AppContent", $$slots, []);

  	$$self.$capture_state = () => ({
  		Credits,
  		Router,
  		Link,
  		Route,
  		navigate,
  		Game,
  		Welcome,
  		Creator,
  		Characters,
  		UserForm
  	});

  	return [];
  }

  class AppContent extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "AppContent",
  			options,
  			id: create_fragment$z.name
  		});
  	}
  }

  /* src/App.svelte generated by Svelte v3.22.3 */
  const file$u = "src/App.svelte";

  function get_each_context_1$5(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[9] = list[i];
  	return child_ctx;
  }

  function get_each_context$9(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[9] = list[i];
  	return child_ctx;
  }

  // (144:12) <NavLink to="/">
  function create_default_slot_9(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text("Tales");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_9.name,
  		type: "slot",
  		source: "(144:12) <NavLink to=\\\"/\\\">",
  		ctx
  	});

  	return block;
  }

  // (151:12) <NavLink to="/play">
  function create_default_slot_8(ctx) {
  	let span1;
  	let span0;
  	let t;
  	let current;
  	const playicon = new PlayIcon({ props: { size: "18" }, $$inline: true });

  	const block = {
  		c: function create() {
  			span1 = element("span");
  			span0 = element("span");
  			create_component(playicon.$$.fragment);
  			t = text("\n                Play");
  			attr_dev(span0, "class", "iconspacing valign-wrapper svelte-1sie3jl");
  			add_location(span0, file$u, 152, 16, 3533);
  			attr_dev(span1, "class", "valign-wrapper");
  			add_location(span1, file$u, 151, 14, 3487);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span1, anchor);
  			append_dev(span1, span0);
  			mount_component(playicon, span0, null);
  			append_dev(span1, t);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(playicon.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(playicon.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span1);
  			destroy_component(playicon);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_8.name,
  		type: "slot",
  		source: "(151:12) <NavLink to=\\\"/play\\\">",
  		ctx
  	});

  	return block;
  }

  // (161:10) {#if $isAuthenticated}
  function create_if_block_3$3(ctx) {
  	let li0;
  	let t;
  	let li1;
  	let current;

  	const navlink0 = new NavLink({
  			props: {
  				to: "/list",
  				$$slots: { default: [create_default_slot_7] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const navlink1 = new NavLink({
  			props: {
  				to: "/creator/rooms",
  				$$slots: { default: [create_default_slot_6] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			li0 = element("li");
  			create_component(navlink0.$$.fragment);
  			t = space();
  			li1 = element("li");
  			create_component(navlink1.$$.fragment);
  			add_location(li0, file$u, 161, 12, 3768);
  			add_location(li1, file$u, 171, 12, 4096);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li0, anchor);
  			mount_component(navlink0, li0, null);
  			insert_dev(target, t, anchor);
  			insert_dev(target, li1, anchor);
  			mount_component(navlink1, li1, null);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navlink0.$$.fragment, local);
  			transition_in(navlink1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navlink0.$$.fragment, local);
  			transition_out(navlink1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li0);
  			destroy_component(navlink0);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(li1);
  			destroy_component(navlink1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$3.name,
  		type: "if",
  		source: "(161:10) {#if $isAuthenticated}",
  		ctx
  	});

  	return block;
  }

  // (163:14) <NavLink to="/list">
  function create_default_slot_7(ctx) {
  	let span1;
  	let span0;
  	let t;
  	let current;
  	const usersicon = new UsersIcon({ props: { size: "18" }, $$inline: true });

  	const block = {
  		c: function create() {
  			span1 = element("span");
  			span0 = element("span");
  			create_component(usersicon.$$.fragment);
  			t = text("\n                  Top Characters");
  			attr_dev(span0, "class", "iconspacing valign-wrapper svelte-1sie3jl");
  			add_location(span0, file$u, 164, 18, 3872);
  			attr_dev(span1, "class", "valign-wrapper");
  			add_location(span1, file$u, 163, 16, 3824);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span1, anchor);
  			append_dev(span1, span0);
  			mount_component(usersicon, span0, null);
  			append_dev(span1, t);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(usersicon.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(usersicon.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span1);
  			destroy_component(usersicon);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_7.name,
  		type: "slot",
  		source: "(163:14) <NavLink to=\\\"/list\\\">",
  		ctx
  	});

  	return block;
  }

  // (173:14) <NavLink to="/creator/rooms">
  function create_default_slot_6(ctx) {
  	let span1;
  	let span0;
  	let t;
  	let current;
  	const editicon = new EditIcon({ props: { size: "18" }, $$inline: true });

  	const block = {
  		c: function create() {
  			span1 = element("span");
  			span0 = element("span");
  			create_component(editicon.$$.fragment);
  			t = text("\n                  Creator");
  			attr_dev(span0, "class", "iconspacing valign-wrapper svelte-1sie3jl");
  			add_location(span0, file$u, 174, 18, 4209);
  			attr_dev(span1, "class", "valign-wrapper");
  			add_location(span1, file$u, 173, 16, 4161);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span1, anchor);
  			append_dev(span1, span0);
  			mount_component(editicon, span0, null);
  			append_dev(span1, t);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(editicon.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(editicon.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span1);
  			destroy_component(editicon);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_6.name,
  		type: "slot",
  		source: "(173:14) <NavLink to=\\\"/creator/rooms\\\">",
  		ctx
  	});

  	return block;
  }

  // (184:12) <NavLink to="signup">
  function create_default_slot_5(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text("News");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_5.name,
  		type: "slot",
  		source: "(184:12) <NavLink to=\\\"signup\\\">",
  		ctx
  	});

  	return block;
  }

  // (190:6) {#if $subMenu.active}
  function create_if_block_1$8(ctx) {
  	let current;

  	const mediaquery = new MediaQuery({
  			props: {
  				query: "(max-width: 1280px)",
  				$$slots: {
  					default: [
  						create_default_slot_2$1,
  						({ matches }) => ({ 8: matches }),
  						({ matches }) => matches ? 256 : 0
  					]
  				},
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(mediaquery.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(mediaquery, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const mediaquery_changes = {};

  			if (dirty & /*$$scope, $subMenu, matches*/ 16644) {
  				mediaquery_changes.$$scope = { dirty, ctx };
  			}

  			mediaquery.$set(mediaquery_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(mediaquery.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(mediaquery.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(mediaquery, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$8.name,
  		type: "if",
  		source: "(190:6) {#if $subMenu.active}",
  		ctx
  	});

  	return block;
  }

  // (202:10) {:else}
  function create_else_block_1$3(ctx) {
  	let div;
  	let ul;
  	let current;
  	let each_value_1 = /*$subMenu*/ ctx[2].entries;
  	validate_each_argument(each_value_1);
  	let each_blocks = [];

  	for (let i = 0; i < each_value_1.length; i += 1) {
  		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
  	}

  	const out = i => transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const block = {
  		c: function create() {
  			div = element("div");
  			ul = element("ul");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			attr_dev(ul, "class", "tabs tabs-transparent");
  			add_location(ul, file$u, 203, 14, 5080);
  			attr_dev(div, "class", "nav-content container");
  			add_location(div, file$u, 202, 12, 5030);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, ul);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(ul, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$subMenu*/ 4) {
  				each_value_1 = /*$subMenu*/ ctx[2].entries;
  				validate_each_argument(each_value_1);
  				let i;

  				for (i = 0; i < each_value_1.length; i += 1) {
  					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block_1$5(child_ctx);
  						each_blocks[i].c();
  						transition_in(each_blocks[i], 1);
  						each_blocks[i].m(ul, null);
  					}
  				}

  				group_outros();

  				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value_1.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_1$3.name,
  		type: "else",
  		source: "(202:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (192:10) {#if matches}
  function create_if_block_2$5(ctx) {
  	let div;
  	let ul;
  	let current;
  	let each_value = /*$subMenu*/ ctx[2].entries;
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  	}

  	const out = i => transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const block = {
  		c: function create() {
  			div = element("div");
  			ul = element("ul");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			attr_dev(ul, "class", "tabs tabs-transparent");
  			add_location(ul, file$u, 193, 14, 4724);
  			attr_dev(div, "class", "nav-content");
  			add_location(div, file$u, 192, 12, 4684);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, ul);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(ul, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$subMenu*/ 4) {
  				each_value = /*$subMenu*/ ctx[2].entries;
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$9(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block$9(child_ctx);
  						each_blocks[i].c();
  						transition_in(each_blocks[i], 1);
  						each_blocks[i].m(ul, null);
  					}
  				}

  				group_outros();

  				for (i = each_value.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$5.name,
  		type: "if",
  		source: "(192:10) {#if matches}",
  		ctx
  	});

  	return block;
  }

  // (207:20) <NavLink to="{entry.nav}">
  function create_default_slot_4(ctx) {
  	let t_value = /*entry*/ ctx[9].name + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$subMenu*/ 4 && t_value !== (t_value = /*entry*/ ctx[9].name + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_4.name,
  		type: "slot",
  		source: "(207:20) <NavLink to=\\\"{entry.nav}\\\">",
  		ctx
  	});

  	return block;
  }

  // (205:16) {#each $subMenu.entries as entry}
  function create_each_block_1$5(ctx) {
  	let li;
  	let t;
  	let current;

  	const navlink = new NavLink({
  			props: {
  				to: /*entry*/ ctx[9].nav,
  				$$slots: { default: [create_default_slot_4] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			li = element("li");
  			create_component(navlink.$$.fragment);
  			t = space();
  			attr_dev(li, "class", "tab");
  			add_location(li, file$u, 205, 18, 5183);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li, anchor);
  			mount_component(navlink, li, null);
  			append_dev(li, t);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const navlink_changes = {};
  			if (dirty & /*$subMenu*/ 4) navlink_changes.to = /*entry*/ ctx[9].nav;

  			if (dirty & /*$$scope, $subMenu*/ 16388) {
  				navlink_changes.$$scope = { dirty, ctx };
  			}

  			navlink.$set(navlink_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navlink.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navlink.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  			destroy_component(navlink);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block_1$5.name,
  		type: "each",
  		source: "(205:16) {#each $subMenu.entries as entry}",
  		ctx
  	});

  	return block;
  }

  // (197:20) <NavLink to="{entry.nav}">
  function create_default_slot_3$1(ctx) {
  	let t_value = /*entry*/ ctx[9].name + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*$subMenu*/ 4 && t_value !== (t_value = /*entry*/ ctx[9].name + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_3$1.name,
  		type: "slot",
  		source: "(197:20) <NavLink to=\\\"{entry.nav}\\\">",
  		ctx
  	});

  	return block;
  }

  // (195:16) {#each $subMenu.entries as entry}
  function create_each_block$9(ctx) {
  	let li;
  	let t;
  	let current;

  	const navlink = new NavLink({
  			props: {
  				to: /*entry*/ ctx[9].nav,
  				$$slots: { default: [create_default_slot_3$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			li = element("li");
  			create_component(navlink.$$.fragment);
  			t = space();
  			attr_dev(li, "class", "tab");
  			add_location(li, file$u, 195, 18, 4827);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li, anchor);
  			mount_component(navlink, li, null);
  			append_dev(li, t);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const navlink_changes = {};
  			if (dirty & /*$subMenu*/ 4) navlink_changes.to = /*entry*/ ctx[9].nav;

  			if (dirty & /*$$scope, $subMenu*/ 16388) {
  				navlink_changes.$$scope = { dirty, ctx };
  			}

  			navlink.$set(navlink_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navlink.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navlink.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  			destroy_component(navlink);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$9.name,
  		type: "each",
  		source: "(195:16) {#each $subMenu.entries as entry}",
  		ctx
  	});

  	return block;
  }

  // (191:8) <MediaQuery query="(max-width: 1280px)" let:matches>
  function create_default_slot_2$1(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block_2$5, create_else_block_1$3];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*matches*/ ctx[8]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty();
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_2$1.name,
  		type: "slot",
  		source: "(191:8) <MediaQuery query=\\\"(max-width: 1280px)\\\" let:matches>",
  		ctx
  	});

  	return block;
  }

  // (224:6) {:else}
  function create_else_block$4(ctx) {
  	let main;
  	let current;
  	const appcontent = new AppContent({ $$inline: true });

  	const block = {
  		c: function create() {
  			main = element("main");
  			create_component(appcontent.$$.fragment);
  			add_location(main, file$u, 224, 8, 5593);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, main, anchor);
  			mount_component(appcontent, main, null);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(appcontent.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(appcontent.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(main);
  			destroy_component(appcontent);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$4.name,
  		type: "else",
  		source: "(224:6) {:else}",
  		ctx
  	});

  	return block;
  }

  // (219:6) {#if matches}
  function create_if_block$a(ctx) {
  	let main;
  	let current;
  	const appcontent = new AppContent({ $$inline: true });

  	const block = {
  		c: function create() {
  			main = element("main");
  			create_component(appcontent.$$.fragment);
  			attr_dev(main, "class", "container");
  			add_location(main, file$u, 219, 8, 5504);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, main, anchor);
  			mount_component(appcontent, main, null);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(appcontent.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(appcontent.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(main);
  			destroy_component(appcontent);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$a.name,
  		type: "if",
  		source: "(219:6) {#if matches}",
  		ctx
  	});

  	return block;
  }

  // (218:4) <MediaQuery query="(min-width: 1281px)" let:matches>
  function create_default_slot_1$2(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block$a, create_else_block$4];
  	const if_blocks = [];

  	function select_block_type_1(ctx, dirty) {
  		if (/*matches*/ ctx[8]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_1(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty();
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_1(ctx);

  			if (current_block_type_index !== previous_block_index) {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1$2.name,
  		type: "slot",
  		source: "(218:4) <MediaQuery query=\\\"(min-width: 1281px)\\\" let:matches>",
  		ctx
  	});

  	return block;
  }

  // (135:2) <Router url="{url}">
  function create_default_slot$6(ctx) {
  	let nav;
  	let div;
  	let a;
  	let span1;
  	let span0;
  	let t0;
  	let t1;
  	let ul;
  	let li0;
  	let t2;
  	let t3;
  	let li1;
  	let t4;
  	let t5;
  	let t6;
  	let current;
  	const bookopenicon = new BookOpenIcon({ props: { size: "24" }, $$inline: true });

  	const navlink0 = new NavLink({
  			props: {
  				to: "/",
  				$$slots: { default: [create_default_slot_9] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const navlink1 = new NavLink({
  			props: {
  				to: "/play",
  				$$slots: { default: [create_default_slot_8] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	let if_block0 = /*$isAuthenticated*/ ctx[1] && create_if_block_3$3(ctx);

  	const navlink2 = new NavLink({
  			props: {
  				to: "signup",
  				$$slots: { default: [create_default_slot_5] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const usermenu = new UserMenu({ $$inline: true });
  	let if_block1 = /*$subMenu*/ ctx[2].active && create_if_block_1$8(ctx);

  	const mediaquery = new MediaQuery({
  			props: {
  				query: "(min-width: 1281px)",
  				$$slots: {
  					default: [
  						create_default_slot_1$2,
  						({ matches }) => ({ 8: matches }),
  						({ matches }) => matches ? 256 : 0
  					]
  				},
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			nav = element("nav");
  			div = element("div");
  			a = element("a");
  			span1 = element("span");
  			span0 = element("span");
  			create_component(bookopenicon.$$.fragment);
  			t0 = space();
  			create_component(navlink0.$$.fragment);
  			t1 = space();
  			ul = element("ul");
  			li0 = element("li");
  			create_component(navlink1.$$.fragment);
  			t2 = space();
  			if (if_block0) if_block0.c();
  			t3 = space();
  			li1 = element("li");
  			create_component(navlink2.$$.fragment);
  			t4 = space();
  			create_component(usermenu.$$.fragment);
  			t5 = space();
  			if (if_block1) if_block1.c();
  			t6 = space();
  			create_component(mediaquery.$$.fragment);
  			attr_dev(span0, "class", "iconspacing svelte-1sie3jl");
  			add_location(span0, file$u, 139, 12, 3201);
  			attr_dev(span1, "class", "valign-wrapper italic");
  			add_location(span1, file$u, 138, 10, 3152);
  			attr_dev(a, "href", "#");
  			attr_dev(a, "class", "brand-logo svelte-1sie3jl");
  			add_location(a, file$u, 137, 8, 3110);
  			add_location(li0, file$u, 149, 10, 3435);
  			add_location(li1, file$u, 182, 10, 4439);
  			attr_dev(ul, "class", "right hide-on-small-only");
  			add_location(ul, file$u, 147, 8, 3386);
  			attr_dev(div, "class", "nav-wrapper container");
  			add_location(div, file$u, 136, 6, 3066);
  			attr_dev(nav, "class", "nav-extended svelte-1sie3jl");
  			add_location(nav, file$u, 135, 4, 3033);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, nav, anchor);
  			append_dev(nav, div);
  			append_dev(div, a);
  			append_dev(a, span1);
  			append_dev(span1, span0);
  			mount_component(bookopenicon, span0, null);
  			append_dev(span1, t0);
  			mount_component(navlink0, span1, null);
  			append_dev(div, t1);
  			append_dev(div, ul);
  			append_dev(ul, li0);
  			mount_component(navlink1, li0, null);
  			append_dev(ul, t2);
  			if (if_block0) if_block0.m(ul, null);
  			append_dev(ul, t3);
  			append_dev(ul, li1);
  			mount_component(navlink2, li1, null);
  			append_dev(ul, t4);
  			mount_component(usermenu, ul, null);
  			append_dev(nav, t5);
  			if (if_block1) if_block1.m(nav, null);
  			insert_dev(target, t6, anchor);
  			mount_component(mediaquery, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const navlink0_changes = {};

  			if (dirty & /*$$scope*/ 16384) {
  				navlink0_changes.$$scope = { dirty, ctx };
  			}

  			navlink0.$set(navlink0_changes);
  			const navlink1_changes = {};

  			if (dirty & /*$$scope*/ 16384) {
  				navlink1_changes.$$scope = { dirty, ctx };
  			}

  			navlink1.$set(navlink1_changes);

  			if (/*$isAuthenticated*/ ctx[1]) {
  				if (if_block0) {
  					if (dirty & /*$isAuthenticated*/ 2) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_3$3(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(ul, t3);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			const navlink2_changes = {};

  			if (dirty & /*$$scope*/ 16384) {
  				navlink2_changes.$$scope = { dirty, ctx };
  			}

  			navlink2.$set(navlink2_changes);

  			if (/*$subMenu*/ ctx[2].active) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty & /*$subMenu*/ 4) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_1$8(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(nav, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			const mediaquery_changes = {};

  			if (dirty & /*$$scope, matches*/ 16640) {
  				mediaquery_changes.$$scope = { dirty, ctx };
  			}

  			mediaquery.$set(mediaquery_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(bookopenicon.$$.fragment, local);
  			transition_in(navlink0.$$.fragment, local);
  			transition_in(navlink1.$$.fragment, local);
  			transition_in(if_block0);
  			transition_in(navlink2.$$.fragment, local);
  			transition_in(usermenu.$$.fragment, local);
  			transition_in(if_block1);
  			transition_in(mediaquery.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(bookopenicon.$$.fragment, local);
  			transition_out(navlink0.$$.fragment, local);
  			transition_out(navlink1.$$.fragment, local);
  			transition_out(if_block0);
  			transition_out(navlink2.$$.fragment, local);
  			transition_out(usermenu.$$.fragment, local);
  			transition_out(if_block1);
  			transition_out(mediaquery.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(nav);
  			destroy_component(bookopenicon);
  			destroy_component(navlink0);
  			destroy_component(navlink1);
  			if (if_block0) if_block0.d();
  			destroy_component(navlink2);
  			destroy_component(usermenu);
  			if (if_block1) if_block1.d();
  			if (detaching) detach_dev(t6);
  			destroy_component(mediaquery, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$6.name,
  		type: "slot",
  		source: "(135:2) <Router url=\\\"{url}\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$A(ctx) {
  	let script0;
  	let script0_src_value;
  	let link0;
  	let script1;
  	let script1_src_value;
  	let link1;
  	let t;
  	let div;
  	let current;

  	const router = new Router({
  			props: {
  				url: /*url*/ ctx[0],
  				$$slots: { default: [create_default_slot$6] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			script0 = element("script");
  			link0 = element("link");
  			script1 = element("script");
  			link1 = element("link");
  			t = space();
  			div = element("div");
  			create_component(router.$$.fragment);
  			if (script0.src !== (script0_src_value = "https://cdn.auth0.com/js/auth0/9.0/auth0.min.js")) attr_dev(script0, "src", script0_src_value);
  			add_location(script0, file$u, 114, 2, 2540);
  			attr_dev(link0, "rel", "stylesheet");
  			attr_dev(link0, "href", "https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css");
  			add_location(link0, file$u, 117, 2, 2618);
  			if (script1.src !== (script1_src_value = "https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0-beta/js/materialize.min.js")) attr_dev(script1, "src", script1_src_value);
  			add_location(script1, file$u, 121, 2, 2744);
  			attr_dev(link1, "rel", "stylesheet");
  			attr_dev(link1, "href", "https://fonts.googleapis.com/icon?family=Material+Icons");
  			add_location(link1, file$u, 125, 2, 2862);
  			attr_dev(div, "class", "root default");
  			add_location(div, file$u, 132, 0, 2978);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			append_dev(document.head, script0);
  			append_dev(document.head, link0);
  			append_dev(document.head, script1);
  			append_dev(document.head, link1);
  			insert_dev(target, t, anchor);
  			insert_dev(target, div, anchor);
  			mount_component(router, div, null);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const router_changes = {};
  			if (dirty & /*url*/ 1) router_changes.url = /*url*/ ctx[0];

  			if (dirty & /*$$scope, $subMenu, $isAuthenticated*/ 16390) {
  				router_changes.$$scope = { dirty, ctx };
  			}

  			router.$set(router_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(router.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(router.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			detach_dev(script0);
  			detach_dev(link0);
  			detach_dev(script1);
  			detach_dev(link1);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(div);
  			destroy_component(router);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$A.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$A($$self, $$props, $$invalidate) {
  	let $isAuthenticated;
  	let $authToken;
  	let $subMenu;
  	validate_store(subMenu, "subMenu");
  	component_subscribe($$self, subMenu, $$value => $$invalidate(2, $subMenu = $$value));

  	const config = {
  		domain: "owndnd.eu.auth0.com",
  		client_id: "mxcEqTuAUOzrL798mbVTpqFxpGGVp3gI",
  		audience: "http://talesofapirate.com/dnd/api"
  	};

  	const { isAuthenticated, authToken } = createAuth(config);
  	validate_store(isAuthenticated, "isAuthenticated");
  	component_subscribe($$self, isAuthenticated, value => $$invalidate(1, $isAuthenticated = value));
  	validate_store(authToken, "authToken");
  	component_subscribe($$self, authToken, value => $$invalidate(6, $authToken = value));

  	String.prototype.capitalize = function () {
  		return this.charAt(0).toUpperCase() + this.slice(1);
  	};

  	onMount(async () => {
  		
  	}); //var elems = document.querySelectorAll(".tabs");
  	//let instance = M.Tabs.init(elems);

  	let { url = "" } = $$props;
  	const writable_props = ["url"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("App", $$slots, []);

  	$$self.$set = $$props => {
  		if ("url" in $$props) $$invalidate(0, url = $$props.url);
  	};

  	$$self.$capture_state = () => ({
  		Sprites,
  		AppContent,
  		MediaQuery,
  		HashIcon,
  		ShieldIcon,
  		BookOpenIcon,
  		EditIcon,
  		PlayIcon,
  		UsersIcon,
  		Router,
  		Link,
  		Route,
  		navigate,
  		Game,
  		Welcome,
  		Creator,
  		Characters,
  		UserForm,
  		afterUpdate,
  		onMount,
  		NavLink,
  		user: user$1,
  		subMenu,
  		fade,
  		UserMenu,
  		createAuth,
  		config,
  		isAuthenticated,
  		authToken,
  		url,
  		state,
  		$isAuthenticated,
  		$authToken,
  		$subMenu
  	});

  	$$self.$inject_state = $$props => {
  		if ("url" in $$props) $$invalidate(0, url = $$props.url);
  		if ("state" in $$props) state = $$props.state;
  	};

  	let state;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*$isAuthenticated, $authToken*/ 66) {
  			 state = {
  				isAuthenticated: $isAuthenticated,
  				authToken: $authToken.slice(0, 20)
  			};
  		}
  	};

  	return [url, $isAuthenticated, $subMenu, isAuthenticated, authToken];
  }

  class App extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$A, create_fragment$A, safe_not_equal, { url: 0 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "App",
  			options,
  			id: create_fragment$A.name
  		});
  	}

  	get url() {
  		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set url(value) {
  		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  Object.defineProperty(String.prototype, "hashCode", {
      value: function () {
        var hash = 0,
          i,
          chr;
        for (i = 0; i < this.length; i++) {
          chr = this.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0; // Convert to 32bit integer
        }
        return hash;
      },
    });

  const app = new App({
  	target: document.body,
  	props: {}
  });

  M.AutoInit();

  return app;

}());
//# sourceMappingURL=bundle.js.map
